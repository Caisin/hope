// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"hope/apps/admin/internal/data/ent/predicate"
	"hope/apps/admin/internal/data/ent/sysjob"
	"hope/apps/admin/internal/data/ent/sysjoblog"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// SysJobUpdate is the builder for updating SysJob entities.
type SysJobUpdate struct {
	config
	hooks    []Hook
	mutation *SysJobMutation
}

// Where appends a list predicates to the SysJobUpdate builder.
func (sju *SysJobUpdate) Where(ps ...predicate.SysJob) *SysJobUpdate {
	sju.mutation.Where(ps...)
	return sju
}

// SetJobName sets the "jobName" field.
func (sju *SysJobUpdate) SetJobName(s string) *SysJobUpdate {
	sju.mutation.SetJobName(s)
	return sju
}

// SetNillableJobName sets the "jobName" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableJobName(s *string) *SysJobUpdate {
	if s != nil {
		sju.SetJobName(*s)
	}
	return sju
}

// ClearJobName clears the value of the "jobName" field.
func (sju *SysJobUpdate) ClearJobName() *SysJobUpdate {
	sju.mutation.ClearJobName()
	return sju
}

// SetJobGroup sets the "jobGroup" field.
func (sju *SysJobUpdate) SetJobGroup(s string) *SysJobUpdate {
	sju.mutation.SetJobGroup(s)
	return sju
}

// SetNillableJobGroup sets the "jobGroup" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableJobGroup(s *string) *SysJobUpdate {
	if s != nil {
		sju.SetJobGroup(*s)
	}
	return sju
}

// ClearJobGroup clears the value of the "jobGroup" field.
func (sju *SysJobUpdate) ClearJobGroup() *SysJobUpdate {
	sju.mutation.ClearJobGroup()
	return sju
}

// SetJobType sets the "jobType" field.
func (sju *SysJobUpdate) SetJobType(i int32) *SysJobUpdate {
	sju.mutation.ResetJobType()
	sju.mutation.SetJobType(i)
	return sju
}

// SetNillableJobType sets the "jobType" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableJobType(i *int32) *SysJobUpdate {
	if i != nil {
		sju.SetJobType(*i)
	}
	return sju
}

// AddJobType adds i to the "jobType" field.
func (sju *SysJobUpdate) AddJobType(i int32) *SysJobUpdate {
	sju.mutation.AddJobType(i)
	return sju
}

// ClearJobType clears the value of the "jobType" field.
func (sju *SysJobUpdate) ClearJobType() *SysJobUpdate {
	sju.mutation.ClearJobType()
	return sju
}

// SetCronExpression sets the "cronExpression" field.
func (sju *SysJobUpdate) SetCronExpression(s string) *SysJobUpdate {
	sju.mutation.SetCronExpression(s)
	return sju
}

// SetNillableCronExpression sets the "cronExpression" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableCronExpression(s *string) *SysJobUpdate {
	if s != nil {
		sju.SetCronExpression(*s)
	}
	return sju
}

// ClearCronExpression clears the value of the "cronExpression" field.
func (sju *SysJobUpdate) ClearCronExpression() *SysJobUpdate {
	sju.mutation.ClearCronExpression()
	return sju
}

// SetInvokeTarget sets the "invokeTarget" field.
func (sju *SysJobUpdate) SetInvokeTarget(s string) *SysJobUpdate {
	sju.mutation.SetInvokeTarget(s)
	return sju
}

// SetNillableInvokeTarget sets the "invokeTarget" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableInvokeTarget(s *string) *SysJobUpdate {
	if s != nil {
		sju.SetInvokeTarget(*s)
	}
	return sju
}

// ClearInvokeTarget clears the value of the "invokeTarget" field.
func (sju *SysJobUpdate) ClearInvokeTarget() *SysJobUpdate {
	sju.mutation.ClearInvokeTarget()
	return sju
}

// SetArgs sets the "args" field.
func (sju *SysJobUpdate) SetArgs(s string) *SysJobUpdate {
	sju.mutation.SetArgs(s)
	return sju
}

// SetNillableArgs sets the "args" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableArgs(s *string) *SysJobUpdate {
	if s != nil {
		sju.SetArgs(*s)
	}
	return sju
}

// ClearArgs clears the value of the "args" field.
func (sju *SysJobUpdate) ClearArgs() *SysJobUpdate {
	sju.mutation.ClearArgs()
	return sju
}

// SetExecPolicy sets the "execPolicy" field.
func (sju *SysJobUpdate) SetExecPolicy(i int32) *SysJobUpdate {
	sju.mutation.ResetExecPolicy()
	sju.mutation.SetExecPolicy(i)
	return sju
}

// SetNillableExecPolicy sets the "execPolicy" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableExecPolicy(i *int32) *SysJobUpdate {
	if i != nil {
		sju.SetExecPolicy(*i)
	}
	return sju
}

// AddExecPolicy adds i to the "execPolicy" field.
func (sju *SysJobUpdate) AddExecPolicy(i int32) *SysJobUpdate {
	sju.mutation.AddExecPolicy(i)
	return sju
}

// ClearExecPolicy clears the value of the "execPolicy" field.
func (sju *SysJobUpdate) ClearExecPolicy() *SysJobUpdate {
	sju.mutation.ClearExecPolicy()
	return sju
}

// SetConcurrent sets the "concurrent" field.
func (sju *SysJobUpdate) SetConcurrent(i int32) *SysJobUpdate {
	sju.mutation.ResetConcurrent()
	sju.mutation.SetConcurrent(i)
	return sju
}

// SetNillableConcurrent sets the "concurrent" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableConcurrent(i *int32) *SysJobUpdate {
	if i != nil {
		sju.SetConcurrent(*i)
	}
	return sju
}

// AddConcurrent adds i to the "concurrent" field.
func (sju *SysJobUpdate) AddConcurrent(i int32) *SysJobUpdate {
	sju.mutation.AddConcurrent(i)
	return sju
}

// ClearConcurrent clears the value of the "concurrent" field.
func (sju *SysJobUpdate) ClearConcurrent() *SysJobUpdate {
	sju.mutation.ClearConcurrent()
	return sju
}

// SetState sets the "state" field.
func (sju *SysJobUpdate) SetState(s sysjob.State) *SysJobUpdate {
	sju.mutation.SetState(s)
	return sju
}

// SetNillableState sets the "state" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableState(s *sysjob.State) *SysJobUpdate {
	if s != nil {
		sju.SetState(*s)
	}
	return sju
}

// SetEntryId sets the "entryId" field.
func (sju *SysJobUpdate) SetEntryId(i int32) *SysJobUpdate {
	sju.mutation.ResetEntryId()
	sju.mutation.SetEntryId(i)
	return sju
}

// SetNillableEntryId sets the "entryId" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableEntryId(i *int32) *SysJobUpdate {
	if i != nil {
		sju.SetEntryId(*i)
	}
	return sju
}

// AddEntryId adds i to the "entryId" field.
func (sju *SysJobUpdate) AddEntryId(i int32) *SysJobUpdate {
	sju.mutation.AddEntryId(i)
	return sju
}

// ClearEntryId clears the value of the "entryId" field.
func (sju *SysJobUpdate) ClearEntryId() *SysJobUpdate {
	sju.mutation.ClearEntryId()
	return sju
}

// SetUpdatedAt sets the "updatedAt" field.
func (sju *SysJobUpdate) SetUpdatedAt(t time.Time) *SysJobUpdate {
	sju.mutation.SetUpdatedAt(t)
	return sju
}

// SetCreateBy sets the "createBy" field.
func (sju *SysJobUpdate) SetCreateBy(i int64) *SysJobUpdate {
	sju.mutation.ResetCreateBy()
	sju.mutation.SetCreateBy(i)
	return sju
}

// SetNillableCreateBy sets the "createBy" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableCreateBy(i *int64) *SysJobUpdate {
	if i != nil {
		sju.SetCreateBy(*i)
	}
	return sju
}

// AddCreateBy adds i to the "createBy" field.
func (sju *SysJobUpdate) AddCreateBy(i int64) *SysJobUpdate {
	sju.mutation.AddCreateBy(i)
	return sju
}

// SetUpdateBy sets the "updateBy" field.
func (sju *SysJobUpdate) SetUpdateBy(i int64) *SysJobUpdate {
	sju.mutation.ResetUpdateBy()
	sju.mutation.SetUpdateBy(i)
	return sju
}

// SetNillableUpdateBy sets the "updateBy" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableUpdateBy(i *int64) *SysJobUpdate {
	if i != nil {
		sju.SetUpdateBy(*i)
	}
	return sju
}

// AddUpdateBy adds i to the "updateBy" field.
func (sju *SysJobUpdate) AddUpdateBy(i int64) *SysJobUpdate {
	sju.mutation.AddUpdateBy(i)
	return sju
}

// SetTenantId sets the "tenantId" field.
func (sju *SysJobUpdate) SetTenantId(i int64) *SysJobUpdate {
	sju.mutation.ResetTenantId()
	sju.mutation.SetTenantId(i)
	return sju
}

// SetNillableTenantId sets the "tenantId" field if the given value is not nil.
func (sju *SysJobUpdate) SetNillableTenantId(i *int64) *SysJobUpdate {
	if i != nil {
		sju.SetTenantId(*i)
	}
	return sju
}

// AddTenantId adds i to the "tenantId" field.
func (sju *SysJobUpdate) AddTenantId(i int64) *SysJobUpdate {
	sju.mutation.AddTenantId(i)
	return sju
}

// AddLogIDs adds the "logs" edge to the SysJobLog entity by IDs.
func (sju *SysJobUpdate) AddLogIDs(ids ...int64) *SysJobUpdate {
	sju.mutation.AddLogIDs(ids...)
	return sju
}

// AddLogs adds the "logs" edges to the SysJobLog entity.
func (sju *SysJobUpdate) AddLogs(s ...*SysJobLog) *SysJobUpdate {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sju.AddLogIDs(ids...)
}

// Mutation returns the SysJobMutation object of the builder.
func (sju *SysJobUpdate) Mutation() *SysJobMutation {
	return sju.mutation
}

// ClearLogs clears all "logs" edges to the SysJobLog entity.
func (sju *SysJobUpdate) ClearLogs() *SysJobUpdate {
	sju.mutation.ClearLogs()
	return sju
}

// RemoveLogIDs removes the "logs" edge to SysJobLog entities by IDs.
func (sju *SysJobUpdate) RemoveLogIDs(ids ...int64) *SysJobUpdate {
	sju.mutation.RemoveLogIDs(ids...)
	return sju
}

// RemoveLogs removes "logs" edges to SysJobLog entities.
func (sju *SysJobUpdate) RemoveLogs(s ...*SysJobLog) *SysJobUpdate {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sju.RemoveLogIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (sju *SysJobUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	sju.defaults()
	if len(sju.hooks) == 0 {
		if err = sju.check(); err != nil {
			return 0, err
		}
		affected, err = sju.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*SysJobMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = sju.check(); err != nil {
				return 0, err
			}
			sju.mutation = mutation
			affected, err = sju.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(sju.hooks) - 1; i >= 0; i-- {
			if sju.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = sju.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, sju.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (sju *SysJobUpdate) SaveX(ctx context.Context) int {
	affected, err := sju.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (sju *SysJobUpdate) Exec(ctx context.Context) error {
	_, err := sju.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sju *SysJobUpdate) ExecX(ctx context.Context) {
	if err := sju.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (sju *SysJobUpdate) defaults() {
	if _, ok := sju.mutation.UpdatedAt(); !ok {
		v := sysjob.UpdateDefaultUpdatedAt()
		sju.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (sju *SysJobUpdate) check() error {
	if v, ok := sju.mutation.State(); ok {
		if err := sysjob.StateValidator(v); err != nil {
			return &ValidationError{Name: "state", err: fmt.Errorf("ent: validator failed for field \"state\": %w", err)}
		}
	}
	return nil
}

func (sju *SysJobUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   sysjob.Table,
			Columns: sysjob.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt64,
				Column: sysjob.FieldID,
			},
		},
	}
	if ps := sju.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := sju.mutation.JobName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldJobName,
		})
	}
	if sju.mutation.JobNameCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldJobName,
		})
	}
	if value, ok := sju.mutation.JobGroup(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldJobGroup,
		})
	}
	if sju.mutation.JobGroupCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldJobGroup,
		})
	}
	if value, ok := sju.mutation.JobType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldJobType,
		})
	}
	if value, ok := sju.mutation.AddedJobType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldJobType,
		})
	}
	if sju.mutation.JobTypeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldJobType,
		})
	}
	if value, ok := sju.mutation.CronExpression(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldCronExpression,
		})
	}
	if sju.mutation.CronExpressionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldCronExpression,
		})
	}
	if value, ok := sju.mutation.InvokeTarget(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldInvokeTarget,
		})
	}
	if sju.mutation.InvokeTargetCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldInvokeTarget,
		})
	}
	if value, ok := sju.mutation.Args(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldArgs,
		})
	}
	if sju.mutation.ArgsCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldArgs,
		})
	}
	if value, ok := sju.mutation.ExecPolicy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldExecPolicy,
		})
	}
	if value, ok := sju.mutation.AddedExecPolicy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldExecPolicy,
		})
	}
	if sju.mutation.ExecPolicyCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldExecPolicy,
		})
	}
	if value, ok := sju.mutation.Concurrent(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldConcurrent,
		})
	}
	if value, ok := sju.mutation.AddedConcurrent(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldConcurrent,
		})
	}
	if sju.mutation.ConcurrentCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldConcurrent,
		})
	}
	if value, ok := sju.mutation.State(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: sysjob.FieldState,
		})
	}
	if value, ok := sju.mutation.EntryId(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldEntryId,
		})
	}
	if value, ok := sju.mutation.AddedEntryId(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldEntryId,
		})
	}
	if sju.mutation.EntryIdCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldEntryId,
		})
	}
	if value, ok := sju.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: sysjob.FieldUpdatedAt,
		})
	}
	if value, ok := sju.mutation.CreateBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldCreateBy,
		})
	}
	if value, ok := sju.mutation.AddedCreateBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldCreateBy,
		})
	}
	if value, ok := sju.mutation.UpdateBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldUpdateBy,
		})
	}
	if value, ok := sju.mutation.AddedUpdateBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldUpdateBy,
		})
	}
	if value, ok := sju.mutation.TenantId(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldTenantId,
		})
	}
	if value, ok := sju.mutation.AddedTenantId(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldTenantId,
		})
	}
	if sju.mutation.LogsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sysjob.LogsTable,
			Columns: []string{sysjob.LogsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: sysjoblog.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sju.mutation.RemovedLogsIDs(); len(nodes) > 0 && !sju.mutation.LogsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sysjob.LogsTable,
			Columns: []string{sysjob.LogsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: sysjoblog.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sju.mutation.LogsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sysjob.LogsTable,
			Columns: []string{sysjob.LogsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: sysjoblog.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, sju.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{sysjob.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}

// SysJobUpdateOne is the builder for updating a single SysJob entity.
type SysJobUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *SysJobMutation
}

// SetJobName sets the "jobName" field.
func (sjuo *SysJobUpdateOne) SetJobName(s string) *SysJobUpdateOne {
	sjuo.mutation.SetJobName(s)
	return sjuo
}

// SetNillableJobName sets the "jobName" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableJobName(s *string) *SysJobUpdateOne {
	if s != nil {
		sjuo.SetJobName(*s)
	}
	return sjuo
}

// ClearJobName clears the value of the "jobName" field.
func (sjuo *SysJobUpdateOne) ClearJobName() *SysJobUpdateOne {
	sjuo.mutation.ClearJobName()
	return sjuo
}

// SetJobGroup sets the "jobGroup" field.
func (sjuo *SysJobUpdateOne) SetJobGroup(s string) *SysJobUpdateOne {
	sjuo.mutation.SetJobGroup(s)
	return sjuo
}

// SetNillableJobGroup sets the "jobGroup" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableJobGroup(s *string) *SysJobUpdateOne {
	if s != nil {
		sjuo.SetJobGroup(*s)
	}
	return sjuo
}

// ClearJobGroup clears the value of the "jobGroup" field.
func (sjuo *SysJobUpdateOne) ClearJobGroup() *SysJobUpdateOne {
	sjuo.mutation.ClearJobGroup()
	return sjuo
}

// SetJobType sets the "jobType" field.
func (sjuo *SysJobUpdateOne) SetJobType(i int32) *SysJobUpdateOne {
	sjuo.mutation.ResetJobType()
	sjuo.mutation.SetJobType(i)
	return sjuo
}

// SetNillableJobType sets the "jobType" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableJobType(i *int32) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetJobType(*i)
	}
	return sjuo
}

// AddJobType adds i to the "jobType" field.
func (sjuo *SysJobUpdateOne) AddJobType(i int32) *SysJobUpdateOne {
	sjuo.mutation.AddJobType(i)
	return sjuo
}

// ClearJobType clears the value of the "jobType" field.
func (sjuo *SysJobUpdateOne) ClearJobType() *SysJobUpdateOne {
	sjuo.mutation.ClearJobType()
	return sjuo
}

// SetCronExpression sets the "cronExpression" field.
func (sjuo *SysJobUpdateOne) SetCronExpression(s string) *SysJobUpdateOne {
	sjuo.mutation.SetCronExpression(s)
	return sjuo
}

// SetNillableCronExpression sets the "cronExpression" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableCronExpression(s *string) *SysJobUpdateOne {
	if s != nil {
		sjuo.SetCronExpression(*s)
	}
	return sjuo
}

// ClearCronExpression clears the value of the "cronExpression" field.
func (sjuo *SysJobUpdateOne) ClearCronExpression() *SysJobUpdateOne {
	sjuo.mutation.ClearCronExpression()
	return sjuo
}

// SetInvokeTarget sets the "invokeTarget" field.
func (sjuo *SysJobUpdateOne) SetInvokeTarget(s string) *SysJobUpdateOne {
	sjuo.mutation.SetInvokeTarget(s)
	return sjuo
}

// SetNillableInvokeTarget sets the "invokeTarget" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableInvokeTarget(s *string) *SysJobUpdateOne {
	if s != nil {
		sjuo.SetInvokeTarget(*s)
	}
	return sjuo
}

// ClearInvokeTarget clears the value of the "invokeTarget" field.
func (sjuo *SysJobUpdateOne) ClearInvokeTarget() *SysJobUpdateOne {
	sjuo.mutation.ClearInvokeTarget()
	return sjuo
}

// SetArgs sets the "args" field.
func (sjuo *SysJobUpdateOne) SetArgs(s string) *SysJobUpdateOne {
	sjuo.mutation.SetArgs(s)
	return sjuo
}

// SetNillableArgs sets the "args" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableArgs(s *string) *SysJobUpdateOne {
	if s != nil {
		sjuo.SetArgs(*s)
	}
	return sjuo
}

// ClearArgs clears the value of the "args" field.
func (sjuo *SysJobUpdateOne) ClearArgs() *SysJobUpdateOne {
	sjuo.mutation.ClearArgs()
	return sjuo
}

// SetExecPolicy sets the "execPolicy" field.
func (sjuo *SysJobUpdateOne) SetExecPolicy(i int32) *SysJobUpdateOne {
	sjuo.mutation.ResetExecPolicy()
	sjuo.mutation.SetExecPolicy(i)
	return sjuo
}

// SetNillableExecPolicy sets the "execPolicy" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableExecPolicy(i *int32) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetExecPolicy(*i)
	}
	return sjuo
}

// AddExecPolicy adds i to the "execPolicy" field.
func (sjuo *SysJobUpdateOne) AddExecPolicy(i int32) *SysJobUpdateOne {
	sjuo.mutation.AddExecPolicy(i)
	return sjuo
}

// ClearExecPolicy clears the value of the "execPolicy" field.
func (sjuo *SysJobUpdateOne) ClearExecPolicy() *SysJobUpdateOne {
	sjuo.mutation.ClearExecPolicy()
	return sjuo
}

// SetConcurrent sets the "concurrent" field.
func (sjuo *SysJobUpdateOne) SetConcurrent(i int32) *SysJobUpdateOne {
	sjuo.mutation.ResetConcurrent()
	sjuo.mutation.SetConcurrent(i)
	return sjuo
}

// SetNillableConcurrent sets the "concurrent" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableConcurrent(i *int32) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetConcurrent(*i)
	}
	return sjuo
}

// AddConcurrent adds i to the "concurrent" field.
func (sjuo *SysJobUpdateOne) AddConcurrent(i int32) *SysJobUpdateOne {
	sjuo.mutation.AddConcurrent(i)
	return sjuo
}

// ClearConcurrent clears the value of the "concurrent" field.
func (sjuo *SysJobUpdateOne) ClearConcurrent() *SysJobUpdateOne {
	sjuo.mutation.ClearConcurrent()
	return sjuo
}

// SetState sets the "state" field.
func (sjuo *SysJobUpdateOne) SetState(s sysjob.State) *SysJobUpdateOne {
	sjuo.mutation.SetState(s)
	return sjuo
}

// SetNillableState sets the "state" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableState(s *sysjob.State) *SysJobUpdateOne {
	if s != nil {
		sjuo.SetState(*s)
	}
	return sjuo
}

// SetEntryId sets the "entryId" field.
func (sjuo *SysJobUpdateOne) SetEntryId(i int32) *SysJobUpdateOne {
	sjuo.mutation.ResetEntryId()
	sjuo.mutation.SetEntryId(i)
	return sjuo
}

// SetNillableEntryId sets the "entryId" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableEntryId(i *int32) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetEntryId(*i)
	}
	return sjuo
}

// AddEntryId adds i to the "entryId" field.
func (sjuo *SysJobUpdateOne) AddEntryId(i int32) *SysJobUpdateOne {
	sjuo.mutation.AddEntryId(i)
	return sjuo
}

// ClearEntryId clears the value of the "entryId" field.
func (sjuo *SysJobUpdateOne) ClearEntryId() *SysJobUpdateOne {
	sjuo.mutation.ClearEntryId()
	return sjuo
}

// SetUpdatedAt sets the "updatedAt" field.
func (sjuo *SysJobUpdateOne) SetUpdatedAt(t time.Time) *SysJobUpdateOne {
	sjuo.mutation.SetUpdatedAt(t)
	return sjuo
}

// SetCreateBy sets the "createBy" field.
func (sjuo *SysJobUpdateOne) SetCreateBy(i int64) *SysJobUpdateOne {
	sjuo.mutation.ResetCreateBy()
	sjuo.mutation.SetCreateBy(i)
	return sjuo
}

// SetNillableCreateBy sets the "createBy" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableCreateBy(i *int64) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetCreateBy(*i)
	}
	return sjuo
}

// AddCreateBy adds i to the "createBy" field.
func (sjuo *SysJobUpdateOne) AddCreateBy(i int64) *SysJobUpdateOne {
	sjuo.mutation.AddCreateBy(i)
	return sjuo
}

// SetUpdateBy sets the "updateBy" field.
func (sjuo *SysJobUpdateOne) SetUpdateBy(i int64) *SysJobUpdateOne {
	sjuo.mutation.ResetUpdateBy()
	sjuo.mutation.SetUpdateBy(i)
	return sjuo
}

// SetNillableUpdateBy sets the "updateBy" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableUpdateBy(i *int64) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetUpdateBy(*i)
	}
	return sjuo
}

// AddUpdateBy adds i to the "updateBy" field.
func (sjuo *SysJobUpdateOne) AddUpdateBy(i int64) *SysJobUpdateOne {
	sjuo.mutation.AddUpdateBy(i)
	return sjuo
}

// SetTenantId sets the "tenantId" field.
func (sjuo *SysJobUpdateOne) SetTenantId(i int64) *SysJobUpdateOne {
	sjuo.mutation.ResetTenantId()
	sjuo.mutation.SetTenantId(i)
	return sjuo
}

// SetNillableTenantId sets the "tenantId" field if the given value is not nil.
func (sjuo *SysJobUpdateOne) SetNillableTenantId(i *int64) *SysJobUpdateOne {
	if i != nil {
		sjuo.SetTenantId(*i)
	}
	return sjuo
}

// AddTenantId adds i to the "tenantId" field.
func (sjuo *SysJobUpdateOne) AddTenantId(i int64) *SysJobUpdateOne {
	sjuo.mutation.AddTenantId(i)
	return sjuo
}

// AddLogIDs adds the "logs" edge to the SysJobLog entity by IDs.
func (sjuo *SysJobUpdateOne) AddLogIDs(ids ...int64) *SysJobUpdateOne {
	sjuo.mutation.AddLogIDs(ids...)
	return sjuo
}

// AddLogs adds the "logs" edges to the SysJobLog entity.
func (sjuo *SysJobUpdateOne) AddLogs(s ...*SysJobLog) *SysJobUpdateOne {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sjuo.AddLogIDs(ids...)
}

// Mutation returns the SysJobMutation object of the builder.
func (sjuo *SysJobUpdateOne) Mutation() *SysJobMutation {
	return sjuo.mutation
}

// ClearLogs clears all "logs" edges to the SysJobLog entity.
func (sjuo *SysJobUpdateOne) ClearLogs() *SysJobUpdateOne {
	sjuo.mutation.ClearLogs()
	return sjuo
}

// RemoveLogIDs removes the "logs" edge to SysJobLog entities by IDs.
func (sjuo *SysJobUpdateOne) RemoveLogIDs(ids ...int64) *SysJobUpdateOne {
	sjuo.mutation.RemoveLogIDs(ids...)
	return sjuo
}

// RemoveLogs removes "logs" edges to SysJobLog entities.
func (sjuo *SysJobUpdateOne) RemoveLogs(s ...*SysJobLog) *SysJobUpdateOne {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sjuo.RemoveLogIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (sjuo *SysJobUpdateOne) Select(field string, fields ...string) *SysJobUpdateOne {
	sjuo.fields = append([]string{field}, fields...)
	return sjuo
}

// Save executes the query and returns the updated SysJob entity.
func (sjuo *SysJobUpdateOne) Save(ctx context.Context) (*SysJob, error) {
	var (
		err  error
		node *SysJob
	)
	sjuo.defaults()
	if len(sjuo.hooks) == 0 {
		if err = sjuo.check(); err != nil {
			return nil, err
		}
		node, err = sjuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*SysJobMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = sjuo.check(); err != nil {
				return nil, err
			}
			sjuo.mutation = mutation
			node, err = sjuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(sjuo.hooks) - 1; i >= 0; i-- {
			if sjuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = sjuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, sjuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (sjuo *SysJobUpdateOne) SaveX(ctx context.Context) *SysJob {
	node, err := sjuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (sjuo *SysJobUpdateOne) Exec(ctx context.Context) error {
	_, err := sjuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sjuo *SysJobUpdateOne) ExecX(ctx context.Context) {
	if err := sjuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (sjuo *SysJobUpdateOne) defaults() {
	if _, ok := sjuo.mutation.UpdatedAt(); !ok {
		v := sysjob.UpdateDefaultUpdatedAt()
		sjuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (sjuo *SysJobUpdateOne) check() error {
	if v, ok := sjuo.mutation.State(); ok {
		if err := sysjob.StateValidator(v); err != nil {
			return &ValidationError{Name: "state", err: fmt.Errorf("ent: validator failed for field \"state\": %w", err)}
		}
	}
	return nil
}

func (sjuo *SysJobUpdateOne) sqlSave(ctx context.Context) (_node *SysJob, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   sysjob.Table,
			Columns: sysjob.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt64,
				Column: sysjob.FieldID,
			},
		},
	}
	id, ok := sjuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing SysJob.ID for update")}
	}
	_spec.Node.ID.Value = id
	if fields := sjuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, sysjob.FieldID)
		for _, f := range fields {
			if !sysjob.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != sysjob.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := sjuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := sjuo.mutation.JobName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldJobName,
		})
	}
	if sjuo.mutation.JobNameCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldJobName,
		})
	}
	if value, ok := sjuo.mutation.JobGroup(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldJobGroup,
		})
	}
	if sjuo.mutation.JobGroupCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldJobGroup,
		})
	}
	if value, ok := sjuo.mutation.JobType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldJobType,
		})
	}
	if value, ok := sjuo.mutation.AddedJobType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldJobType,
		})
	}
	if sjuo.mutation.JobTypeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldJobType,
		})
	}
	if value, ok := sjuo.mutation.CronExpression(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldCronExpression,
		})
	}
	if sjuo.mutation.CronExpressionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldCronExpression,
		})
	}
	if value, ok := sjuo.mutation.InvokeTarget(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldInvokeTarget,
		})
	}
	if sjuo.mutation.InvokeTargetCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldInvokeTarget,
		})
	}
	if value, ok := sjuo.mutation.Args(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: sysjob.FieldArgs,
		})
	}
	if sjuo.mutation.ArgsCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: sysjob.FieldArgs,
		})
	}
	if value, ok := sjuo.mutation.ExecPolicy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldExecPolicy,
		})
	}
	if value, ok := sjuo.mutation.AddedExecPolicy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldExecPolicy,
		})
	}
	if sjuo.mutation.ExecPolicyCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldExecPolicy,
		})
	}
	if value, ok := sjuo.mutation.Concurrent(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldConcurrent,
		})
	}
	if value, ok := sjuo.mutation.AddedConcurrent(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldConcurrent,
		})
	}
	if sjuo.mutation.ConcurrentCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldConcurrent,
		})
	}
	if value, ok := sjuo.mutation.State(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: sysjob.FieldState,
		})
	}
	if value, ok := sjuo.mutation.EntryId(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldEntryId,
		})
	}
	if value, ok := sjuo.mutation.AddedEntryId(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Value:  value,
			Column: sysjob.FieldEntryId,
		})
	}
	if sjuo.mutation.EntryIdCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt32,
			Column: sysjob.FieldEntryId,
		})
	}
	if value, ok := sjuo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: sysjob.FieldUpdatedAt,
		})
	}
	if value, ok := sjuo.mutation.CreateBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldCreateBy,
		})
	}
	if value, ok := sjuo.mutation.AddedCreateBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldCreateBy,
		})
	}
	if value, ok := sjuo.mutation.UpdateBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldUpdateBy,
		})
	}
	if value, ok := sjuo.mutation.AddedUpdateBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldUpdateBy,
		})
	}
	if value, ok := sjuo.mutation.TenantId(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldTenantId,
		})
	}
	if value, ok := sjuo.mutation.AddedTenantId(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: sysjob.FieldTenantId,
		})
	}
	if sjuo.mutation.LogsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sysjob.LogsTable,
			Columns: []string{sysjob.LogsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: sysjoblog.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sjuo.mutation.RemovedLogsIDs(); len(nodes) > 0 && !sjuo.mutation.LogsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sysjob.LogsTable,
			Columns: []string{sysjob.LogsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: sysjoblog.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sjuo.mutation.LogsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sysjob.LogsTable,
			Columns: []string{sysjob.LogsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt64,
					Column: sysjoblog.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &SysJob{config: sjuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, sjuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{sysjob.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}
