// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"hope/apps/admin/internal/data/ent/syscolumns"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// SysColumns is the model entity for the SysColumns schema.
type SysColumns struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// ColumnId holds the value of the "columnId" field.
	ColumnId int32 `json:"columnId,omitempty"`
	// ColumnName holds the value of the "columnName" field.
	ColumnName string `json:"columnName,omitempty"`
	// ColumnComment holds the value of the "columnComment" field.
	ColumnComment string `json:"columnComment,omitempty"`
	// ColumnType holds the value of the "columnType" field.
	ColumnType string `json:"columnType,omitempty"`
	// GoType holds the value of the "goType" field.
	GoType string `json:"goType,omitempty"`
	// GoField holds the value of the "goField" field.
	GoField string `json:"goField,omitempty"`
	// JsonField holds the value of the "jsonField" field.
	JsonField string `json:"jsonField,omitempty"`
	// IsPk holds the value of the "isPk" field.
	IsPk string `json:"isPk,omitempty"`
	// IsIncrement holds the value of the "isIncrement" field.
	IsIncrement string `json:"isIncrement,omitempty"`
	// IsRequired holds the value of the "isRequired" field.
	IsRequired string `json:"isRequired,omitempty"`
	// IsInsert holds the value of the "isInsert" field.
	IsInsert string `json:"isInsert,omitempty"`
	// IsEdit holds the value of the "isEdit" field.
	IsEdit string `json:"isEdit,omitempty"`
	// IsList holds the value of the "isList" field.
	IsList string `json:"isList,omitempty"`
	// IsQuery holds the value of the "isQuery" field.
	IsQuery string `json:"isQuery,omitempty"`
	// QueryType holds the value of the "queryType" field.
	QueryType string `json:"queryType,omitempty"`
	// HtmlType holds the value of the "htmlType" field.
	HtmlType string `json:"htmlType,omitempty"`
	// DictType holds the value of the "dictType" field.
	DictType string `json:"dictType,omitempty"`
	// Sort holds the value of the "sort" field.
	Sort int32 `json:"sort,omitempty"`
	// List holds the value of the "list" field.
	List string `json:"list,omitempty"`
	// Pk holds the value of the "pk" field.
	Pk bool `json:"pk,omitempty"`
	// Required holds the value of the "required" field.
	Required bool `json:"required,omitempty"`
	// SuperColumn holds the value of the "superColumn" field.
	SuperColumn bool `json:"superColumn,omitempty"`
	// UsableColumn holds the value of the "usableColumn" field.
	UsableColumn bool `json:"usableColumn,omitempty"`
	// Increment holds the value of the "increment" field.
	Increment bool `json:"increment,omitempty"`
	// Insert holds the value of the "insert" field.
	Insert bool `json:"insert,omitempty"`
	// Edit holds the value of the "edit" field.
	Edit bool `json:"edit,omitempty"`
	// Query holds the value of the "query" field.
	Query bool `json:"query,omitempty"`
	// Remark holds the value of the "remark" field.
	Remark string `json:"remark,omitempty"`
	// FkLabelName holds the value of the "fkLabelName" field.
	FkLabelName string `json:"fkLabelName,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	// 创建时间
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	// 更新时间
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
	// CreateBy holds the value of the "createBy" field.
	// 创建者
	CreateBy int64 `json:"createBy,omitempty"`
	// UpdateBy holds the value of the "updateBy" field.
	// 更新者
	UpdateBy int64 `json:"updateBy,omitempty"`
	// TenantId holds the value of the "tenantId" field.
	// 租户
	TenantId int64 `json:"tenantId,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*SysColumns) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case syscolumns.FieldPk, syscolumns.FieldRequired, syscolumns.FieldSuperColumn, syscolumns.FieldUsableColumn, syscolumns.FieldIncrement, syscolumns.FieldInsert, syscolumns.FieldEdit, syscolumns.FieldQuery:
			values[i] = new(sql.NullBool)
		case syscolumns.FieldID, syscolumns.FieldColumnId, syscolumns.FieldSort, syscolumns.FieldCreateBy, syscolumns.FieldUpdateBy, syscolumns.FieldTenantId:
			values[i] = new(sql.NullInt64)
		case syscolumns.FieldColumnName, syscolumns.FieldColumnComment, syscolumns.FieldColumnType, syscolumns.FieldGoType, syscolumns.FieldGoField, syscolumns.FieldJsonField, syscolumns.FieldIsPk, syscolumns.FieldIsIncrement, syscolumns.FieldIsRequired, syscolumns.FieldIsInsert, syscolumns.FieldIsEdit, syscolumns.FieldIsList, syscolumns.FieldIsQuery, syscolumns.FieldQueryType, syscolumns.FieldHtmlType, syscolumns.FieldDictType, syscolumns.FieldList, syscolumns.FieldRemark, syscolumns.FieldFkLabelName:
			values[i] = new(sql.NullString)
		case syscolumns.FieldCreatedAt, syscolumns.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type SysColumns", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the SysColumns fields.
func (sc *SysColumns) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case syscolumns.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			sc.ID = int64(value.Int64)
		case syscolumns.FieldColumnId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field columnId", values[i])
			} else if value.Valid {
				sc.ColumnId = int32(value.Int64)
			}
		case syscolumns.FieldColumnName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field columnName", values[i])
			} else if value.Valid {
				sc.ColumnName = value.String
			}
		case syscolumns.FieldColumnComment:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field columnComment", values[i])
			} else if value.Valid {
				sc.ColumnComment = value.String
			}
		case syscolumns.FieldColumnType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field columnType", values[i])
			} else if value.Valid {
				sc.ColumnType = value.String
			}
		case syscolumns.FieldGoType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field goType", values[i])
			} else if value.Valid {
				sc.GoType = value.String
			}
		case syscolumns.FieldGoField:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field goField", values[i])
			} else if value.Valid {
				sc.GoField = value.String
			}
		case syscolumns.FieldJsonField:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field jsonField", values[i])
			} else if value.Valid {
				sc.JsonField = value.String
			}
		case syscolumns.FieldIsPk:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isPk", values[i])
			} else if value.Valid {
				sc.IsPk = value.String
			}
		case syscolumns.FieldIsIncrement:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isIncrement", values[i])
			} else if value.Valid {
				sc.IsIncrement = value.String
			}
		case syscolumns.FieldIsRequired:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isRequired", values[i])
			} else if value.Valid {
				sc.IsRequired = value.String
			}
		case syscolumns.FieldIsInsert:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isInsert", values[i])
			} else if value.Valid {
				sc.IsInsert = value.String
			}
		case syscolumns.FieldIsEdit:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isEdit", values[i])
			} else if value.Valid {
				sc.IsEdit = value.String
			}
		case syscolumns.FieldIsList:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isList", values[i])
			} else if value.Valid {
				sc.IsList = value.String
			}
		case syscolumns.FieldIsQuery:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isQuery", values[i])
			} else if value.Valid {
				sc.IsQuery = value.String
			}
		case syscolumns.FieldQueryType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field queryType", values[i])
			} else if value.Valid {
				sc.QueryType = value.String
			}
		case syscolumns.FieldHtmlType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field htmlType", values[i])
			} else if value.Valid {
				sc.HtmlType = value.String
			}
		case syscolumns.FieldDictType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dictType", values[i])
			} else if value.Valid {
				sc.DictType = value.String
			}
		case syscolumns.FieldSort:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sort", values[i])
			} else if value.Valid {
				sc.Sort = int32(value.Int64)
			}
		case syscolumns.FieldList:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field list", values[i])
			} else if value.Valid {
				sc.List = value.String
			}
		case syscolumns.FieldPk:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field pk", values[i])
			} else if value.Valid {
				sc.Pk = value.Bool
			}
		case syscolumns.FieldRequired:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field required", values[i])
			} else if value.Valid {
				sc.Required = value.Bool
			}
		case syscolumns.FieldSuperColumn:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field superColumn", values[i])
			} else if value.Valid {
				sc.SuperColumn = value.Bool
			}
		case syscolumns.FieldUsableColumn:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field usableColumn", values[i])
			} else if value.Valid {
				sc.UsableColumn = value.Bool
			}
		case syscolumns.FieldIncrement:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field increment", values[i])
			} else if value.Valid {
				sc.Increment = value.Bool
			}
		case syscolumns.FieldInsert:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field insert", values[i])
			} else if value.Valid {
				sc.Insert = value.Bool
			}
		case syscolumns.FieldEdit:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field edit", values[i])
			} else if value.Valid {
				sc.Edit = value.Bool
			}
		case syscolumns.FieldQuery:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field query", values[i])
			} else if value.Valid {
				sc.Query = value.Bool
			}
		case syscolumns.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				sc.Remark = value.String
			}
		case syscolumns.FieldFkLabelName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field fkLabelName", values[i])
			} else if value.Valid {
				sc.FkLabelName = value.String
			}
		case syscolumns.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdAt", values[i])
			} else if value.Valid {
				sc.CreatedAt = value.Time
			}
		case syscolumns.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedAt", values[i])
			} else if value.Valid {
				sc.UpdatedAt = value.Time
			}
		case syscolumns.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field createBy", values[i])
			} else if value.Valid {
				sc.CreateBy = value.Int64
			}
		case syscolumns.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updateBy", values[i])
			} else if value.Valid {
				sc.UpdateBy = value.Int64
			}
		case syscolumns.FieldTenantId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenantId", values[i])
			} else if value.Valid {
				sc.TenantId = value.Int64
			}
		}
	}
	return nil
}

// Update returns a builder for updating this SysColumns.
// Note that you need to call SysColumns.Unwrap() before calling this method if this SysColumns
// was returned from a transaction, and the transaction was committed or rolled back.
func (sc *SysColumns) Update() *SysColumnsUpdateOne {
	return (&SysColumnsClient{config: sc.config}).UpdateOne(sc)
}

// Unwrap unwraps the SysColumns entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (sc *SysColumns) Unwrap() *SysColumns {
	tx, ok := sc.config.driver.(*txDriver)
	if !ok {
		panic("ent: SysColumns is not a transactional entity")
	}
	sc.config.driver = tx.drv
	return sc
}

// String implements the fmt.Stringer.
func (sc *SysColumns) String() string {
	var builder strings.Builder
	builder.WriteString("SysColumns(")
	builder.WriteString(fmt.Sprintf("id=%v", sc.ID))
	builder.WriteString(", columnId=")
	builder.WriteString(fmt.Sprintf("%v", sc.ColumnId))
	builder.WriteString(", columnName=")
	builder.WriteString(sc.ColumnName)
	builder.WriteString(", columnComment=")
	builder.WriteString(sc.ColumnComment)
	builder.WriteString(", columnType=")
	builder.WriteString(sc.ColumnType)
	builder.WriteString(", goType=")
	builder.WriteString(sc.GoType)
	builder.WriteString(", goField=")
	builder.WriteString(sc.GoField)
	builder.WriteString(", jsonField=")
	builder.WriteString(sc.JsonField)
	builder.WriteString(", isPk=")
	builder.WriteString(sc.IsPk)
	builder.WriteString(", isIncrement=")
	builder.WriteString(sc.IsIncrement)
	builder.WriteString(", isRequired=")
	builder.WriteString(sc.IsRequired)
	builder.WriteString(", isInsert=")
	builder.WriteString(sc.IsInsert)
	builder.WriteString(", isEdit=")
	builder.WriteString(sc.IsEdit)
	builder.WriteString(", isList=")
	builder.WriteString(sc.IsList)
	builder.WriteString(", isQuery=")
	builder.WriteString(sc.IsQuery)
	builder.WriteString(", queryType=")
	builder.WriteString(sc.QueryType)
	builder.WriteString(", htmlType=")
	builder.WriteString(sc.HtmlType)
	builder.WriteString(", dictType=")
	builder.WriteString(sc.DictType)
	builder.WriteString(", sort=")
	builder.WriteString(fmt.Sprintf("%v", sc.Sort))
	builder.WriteString(", list=")
	builder.WriteString(sc.List)
	builder.WriteString(", pk=")
	builder.WriteString(fmt.Sprintf("%v", sc.Pk))
	builder.WriteString(", required=")
	builder.WriteString(fmt.Sprintf("%v", sc.Required))
	builder.WriteString(", superColumn=")
	builder.WriteString(fmt.Sprintf("%v", sc.SuperColumn))
	builder.WriteString(", usableColumn=")
	builder.WriteString(fmt.Sprintf("%v", sc.UsableColumn))
	builder.WriteString(", increment=")
	builder.WriteString(fmt.Sprintf("%v", sc.Increment))
	builder.WriteString(", insert=")
	builder.WriteString(fmt.Sprintf("%v", sc.Insert))
	builder.WriteString(", edit=")
	builder.WriteString(fmt.Sprintf("%v", sc.Edit))
	builder.WriteString(", query=")
	builder.WriteString(fmt.Sprintf("%v", sc.Query))
	builder.WriteString(", remark=")
	builder.WriteString(sc.Remark)
	builder.WriteString(", fkLabelName=")
	builder.WriteString(sc.FkLabelName)
	builder.WriteString(", createdAt=")
	builder.WriteString(sc.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updatedAt=")
	builder.WriteString(sc.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", createBy=")
	builder.WriteString(fmt.Sprintf("%v", sc.CreateBy))
	builder.WriteString(", updateBy=")
	builder.WriteString(fmt.Sprintf("%v", sc.UpdateBy))
	builder.WriteString(", tenantId=")
	builder.WriteString(fmt.Sprintf("%v", sc.TenantId))
	builder.WriteByte(')')
	return builder.String()
}

// SysColumnsSlice is a parsable slice of SysColumns.
type SysColumnsSlice []*SysColumns

func (sc SysColumnsSlice) config(cfg config) {
	for _i := range sc {
		sc[_i].config = cfg
	}
}
