// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"hope/apps/admin/internal/data/ent/systables"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// SysTables is the model entity for the SysTables schema.
type SysTables struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// TableName holds the value of the "tableName" field.
	// 表名称
	TableName string `json:"tableName,omitempty"`
	// TableComment holds the value of the "tableComment" field.
	// 表备注
	TableComment string `json:"tableComment,omitempty"`
	// ClassName holds the value of the "className" field.
	// 类名
	ClassName string `json:"className,omitempty"`
	// TplCategory holds the value of the "tplCategory" field.
	TplCategory string `json:"tplCategory,omitempty"`
	// PackageName holds the value of the "packageName" field.
	// 包名
	PackageName string `json:"packageName,omitempty"`
	// ModuleName holds the value of the "moduleName" field.
	// go文件名
	ModuleName string `json:"moduleName,omitempty"`
	// ModuleFrontName holds the value of the "moduleFrontName" field.
	// 前端文件名
	ModuleFrontName string `json:"moduleFrontName,omitempty"`
	// BusinessName holds the value of the "businessName" field.
	BusinessName string `json:"businessName,omitempty"`
	// FunctionName holds the value of the "functionName" field.
	// 功能名称
	FunctionName string `json:"functionName,omitempty"`
	// FunctionAuthor holds the value of the "functionAuthor" field.
	// 功能作者
	FunctionAuthor string `json:"functionAuthor,omitempty"`
	// PkColumn holds the value of the "pkColumn" field.
	PkColumn string `json:"pkColumn,omitempty"`
	// PkGoField holds the value of the "pkGoField" field.
	PkGoField string `json:"pkGoField,omitempty"`
	// PkJsonField holds the value of the "pkJsonField" field.
	PkJsonField string `json:"pkJsonField,omitempty"`
	// Options holds the value of the "options" field.
	Options string `json:"options,omitempty"`
	// TreeCode holds the value of the "treeCode" field.
	TreeCode string `json:"treeCode,omitempty"`
	// TreeParentCode holds the value of the "treeParentCode" field.
	TreeParentCode string `json:"treeParentCode,omitempty"`
	// TreeName holds the value of the "treeName" field.
	TreeName string `json:"treeName,omitempty"`
	// Tree holds the value of the "tree" field.
	Tree bool `json:"tree,omitempty"`
	// Crud holds the value of the "crud" field.
	Crud bool `json:"crud,omitempty"`
	// Remark holds the value of the "remark" field.
	Remark string `json:"remark,omitempty"`
	// IsDataScope holds the value of the "isDataScope" field.
	IsDataScope int32 `json:"isDataScope,omitempty"`
	// IsActions holds the value of the "isActions" field.
	IsActions int32 `json:"isActions,omitempty"`
	// IsAuth holds the value of the "isAuth" field.
	IsAuth int32 `json:"isAuth,omitempty"`
	// IsLogicalDelete holds the value of the "isLogicalDelete" field.
	IsLogicalDelete string `json:"isLogicalDelete,omitempty"`
	// LogicalDelete holds the value of the "logicalDelete" field.
	LogicalDelete bool `json:"logicalDelete,omitempty"`
	// LogicalDeleteColumn holds the value of the "logicalDeleteColumn" field.
	LogicalDeleteColumn string `json:"logicalDeleteColumn,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	// 创建时间
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	// 更新时间
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
	// CreateBy holds the value of the "createBy" field.
	// 创建者
	CreateBy int64 `json:"createBy,omitempty"`
	// UpdateBy holds the value of the "updateBy" field.
	// 更新者
	UpdateBy int64 `json:"updateBy,omitempty"`
	// TenantId holds the value of the "tenantId" field.
	// 租户
	TenantId int64 `json:"tenantId,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*SysTables) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case systables.FieldTree, systables.FieldCrud, systables.FieldLogicalDelete:
			values[i] = new(sql.NullBool)
		case systables.FieldID, systables.FieldIsDataScope, systables.FieldIsActions, systables.FieldIsAuth, systables.FieldCreateBy, systables.FieldUpdateBy, systables.FieldTenantId:
			values[i] = new(sql.NullInt64)
		case systables.FieldTableName, systables.FieldTableComment, systables.FieldClassName, systables.FieldTplCategory, systables.FieldPackageName, systables.FieldModuleName, systables.FieldModuleFrontName, systables.FieldBusinessName, systables.FieldFunctionName, systables.FieldFunctionAuthor, systables.FieldPkColumn, systables.FieldPkGoField, systables.FieldPkJsonField, systables.FieldOptions, systables.FieldTreeCode, systables.FieldTreeParentCode, systables.FieldTreeName, systables.FieldRemark, systables.FieldIsLogicalDelete, systables.FieldLogicalDeleteColumn:
			values[i] = new(sql.NullString)
		case systables.FieldCreatedAt, systables.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type SysTables", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the SysTables fields.
func (st *SysTables) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case systables.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			st.ID = int64(value.Int64)
		case systables.FieldTableName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tableName", values[i])
			} else if value.Valid {
				st.TableName = value.String
			}
		case systables.FieldTableComment:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tableComment", values[i])
			} else if value.Valid {
				st.TableComment = value.String
			}
		case systables.FieldClassName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field className", values[i])
			} else if value.Valid {
				st.ClassName = value.String
			}
		case systables.FieldTplCategory:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tplCategory", values[i])
			} else if value.Valid {
				st.TplCategory = value.String
			}
		case systables.FieldPackageName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field packageName", values[i])
			} else if value.Valid {
				st.PackageName = value.String
			}
		case systables.FieldModuleName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field moduleName", values[i])
			} else if value.Valid {
				st.ModuleName = value.String
			}
		case systables.FieldModuleFrontName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field moduleFrontName", values[i])
			} else if value.Valid {
				st.ModuleFrontName = value.String
			}
		case systables.FieldBusinessName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field businessName", values[i])
			} else if value.Valid {
				st.BusinessName = value.String
			}
		case systables.FieldFunctionName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field functionName", values[i])
			} else if value.Valid {
				st.FunctionName = value.String
			}
		case systables.FieldFunctionAuthor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field functionAuthor", values[i])
			} else if value.Valid {
				st.FunctionAuthor = value.String
			}
		case systables.FieldPkColumn:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pkColumn", values[i])
			} else if value.Valid {
				st.PkColumn = value.String
			}
		case systables.FieldPkGoField:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pkGoField", values[i])
			} else if value.Valid {
				st.PkGoField = value.String
			}
		case systables.FieldPkJsonField:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pkJsonField", values[i])
			} else if value.Valid {
				st.PkJsonField = value.String
			}
		case systables.FieldOptions:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field options", values[i])
			} else if value.Valid {
				st.Options = value.String
			}
		case systables.FieldTreeCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field treeCode", values[i])
			} else if value.Valid {
				st.TreeCode = value.String
			}
		case systables.FieldTreeParentCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field treeParentCode", values[i])
			} else if value.Valid {
				st.TreeParentCode = value.String
			}
		case systables.FieldTreeName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field treeName", values[i])
			} else if value.Valid {
				st.TreeName = value.String
			}
		case systables.FieldTree:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field tree", values[i])
			} else if value.Valid {
				st.Tree = value.Bool
			}
		case systables.FieldCrud:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field crud", values[i])
			} else if value.Valid {
				st.Crud = value.Bool
			}
		case systables.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				st.Remark = value.String
			}
		case systables.FieldIsDataScope:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field isDataScope", values[i])
			} else if value.Valid {
				st.IsDataScope = int32(value.Int64)
			}
		case systables.FieldIsActions:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field isActions", values[i])
			} else if value.Valid {
				st.IsActions = int32(value.Int64)
			}
		case systables.FieldIsAuth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field isAuth", values[i])
			} else if value.Valid {
				st.IsAuth = int32(value.Int64)
			}
		case systables.FieldIsLogicalDelete:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field isLogicalDelete", values[i])
			} else if value.Valid {
				st.IsLogicalDelete = value.String
			}
		case systables.FieldLogicalDelete:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field logicalDelete", values[i])
			} else if value.Valid {
				st.LogicalDelete = value.Bool
			}
		case systables.FieldLogicalDeleteColumn:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field logicalDeleteColumn", values[i])
			} else if value.Valid {
				st.LogicalDeleteColumn = value.String
			}
		case systables.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdAt", values[i])
			} else if value.Valid {
				st.CreatedAt = value.Time
			}
		case systables.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedAt", values[i])
			} else if value.Valid {
				st.UpdatedAt = value.Time
			}
		case systables.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field createBy", values[i])
			} else if value.Valid {
				st.CreateBy = value.Int64
			}
		case systables.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updateBy", values[i])
			} else if value.Valid {
				st.UpdateBy = value.Int64
			}
		case systables.FieldTenantId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenantId", values[i])
			} else if value.Valid {
				st.TenantId = value.Int64
			}
		}
	}
	return nil
}

// Update returns a builder for updating this SysTables.
// Note that you need to call SysTables.Unwrap() before calling this method if this SysTables
// was returned from a transaction, and the transaction was committed or rolled back.
func (st *SysTables) Update() *SysTablesUpdateOne {
	return (&SysTablesClient{config: st.config}).UpdateOne(st)
}

// Unwrap unwraps the SysTables entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (st *SysTables) Unwrap() *SysTables {
	tx, ok := st.config.driver.(*txDriver)
	if !ok {
		panic("ent: SysTables is not a transactional entity")
	}
	st.config.driver = tx.drv
	return st
}

// String implements the fmt.Stringer.
func (st *SysTables) String() string {
	var builder strings.Builder
	builder.WriteString("SysTables(")
	builder.WriteString(fmt.Sprintf("id=%v", st.ID))
	builder.WriteString(", tableName=")
	builder.WriteString(st.TableName)
	builder.WriteString(", tableComment=")
	builder.WriteString(st.TableComment)
	builder.WriteString(", className=")
	builder.WriteString(st.ClassName)
	builder.WriteString(", tplCategory=")
	builder.WriteString(st.TplCategory)
	builder.WriteString(", packageName=")
	builder.WriteString(st.PackageName)
	builder.WriteString(", moduleName=")
	builder.WriteString(st.ModuleName)
	builder.WriteString(", moduleFrontName=")
	builder.WriteString(st.ModuleFrontName)
	builder.WriteString(", businessName=")
	builder.WriteString(st.BusinessName)
	builder.WriteString(", functionName=")
	builder.WriteString(st.FunctionName)
	builder.WriteString(", functionAuthor=")
	builder.WriteString(st.FunctionAuthor)
	builder.WriteString(", pkColumn=")
	builder.WriteString(st.PkColumn)
	builder.WriteString(", pkGoField=")
	builder.WriteString(st.PkGoField)
	builder.WriteString(", pkJsonField=")
	builder.WriteString(st.PkJsonField)
	builder.WriteString(", options=")
	builder.WriteString(st.Options)
	builder.WriteString(", treeCode=")
	builder.WriteString(st.TreeCode)
	builder.WriteString(", treeParentCode=")
	builder.WriteString(st.TreeParentCode)
	builder.WriteString(", treeName=")
	builder.WriteString(st.TreeName)
	builder.WriteString(", tree=")
	builder.WriteString(fmt.Sprintf("%v", st.Tree))
	builder.WriteString(", crud=")
	builder.WriteString(fmt.Sprintf("%v", st.Crud))
	builder.WriteString(", remark=")
	builder.WriteString(st.Remark)
	builder.WriteString(", isDataScope=")
	builder.WriteString(fmt.Sprintf("%v", st.IsDataScope))
	builder.WriteString(", isActions=")
	builder.WriteString(fmt.Sprintf("%v", st.IsActions))
	builder.WriteString(", isAuth=")
	builder.WriteString(fmt.Sprintf("%v", st.IsAuth))
	builder.WriteString(", isLogicalDelete=")
	builder.WriteString(st.IsLogicalDelete)
	builder.WriteString(", logicalDelete=")
	builder.WriteString(fmt.Sprintf("%v", st.LogicalDelete))
	builder.WriteString(", logicalDeleteColumn=")
	builder.WriteString(st.LogicalDeleteColumn)
	builder.WriteString(", createdAt=")
	builder.WriteString(st.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updatedAt=")
	builder.WriteString(st.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", createBy=")
	builder.WriteString(fmt.Sprintf("%v", st.CreateBy))
	builder.WriteString(", updateBy=")
	builder.WriteString(fmt.Sprintf("%v", st.UpdateBy))
	builder.WriteString(", tenantId=")
	builder.WriteString(fmt.Sprintf("%v", st.TenantId))
	builder.WriteByte(')')
	return builder.String()
}

// SysTablesSlice is a parsable slice of SysTables.
type SysTablesSlice []*SysTables

func (st SysTablesSlice) config(cfg config) {
	for _i := range st {
		st[_i].config = cfg
	}
}
