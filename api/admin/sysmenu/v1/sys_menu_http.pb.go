// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type SysMenuHTTPServer interface {
	BatchDeleteSysMenu(context.Context, *SysMenuBatchDeleteReq) (*SysMenuDeleteReply, error)
	CreateSysMenu(context.Context, *SysMenuCreateReq) (*SysMenuCreateReply, error)
	DeleteSysMenu(context.Context, *SysMenuDeleteReq) (*SysMenuDeleteReply, error)
	GetSysMenu(context.Context, *SysMenuReq) (*SysMenuReply, error)
	GetSysMenuPage(context.Context, *SysMenuPageReq) (*SysMenuPageReply, error)
	UpdateSysMenu(context.Context, *SysMenuUpdateReq) (*SysMenuUpdateReply, error)
}

func RegisterSysMenuHTTPServer(s *http.Server, srv SysMenuHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/sys/menu/page", _SysMenu_GetSysMenuPage0_HTTP_Handler(srv))
	r.GET("/v1/sys/menu/{id}", _SysMenu_GetSysMenu0_HTTP_Handler(srv))
	r.PUT("/v1/sys/menu/{id}", _SysMenu_UpdateSysMenu0_HTTP_Handler(srv))
	r.POST("/v1/sys/menu", _SysMenu_CreateSysMenu0_HTTP_Handler(srv))
	r.DELETE("/v1/sys/menu/{id}", _SysMenu_DeleteSysMenu0_HTTP_Handler(srv))
	r.DELETE("/v1/sys/menu", _SysMenu_BatchDeleteSysMenu0_HTTP_Handler(srv))
}

func _SysMenu_GetSysMenuPage0_HTTP_Handler(srv SysMenuHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SysMenuPageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/sysmenu.v1.SysMenu/GetSysMenuPage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSysMenuPage(ctx, req.(*SysMenuPageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SysMenuPageReply)
		return ctx.Result(200, reply)
	}
}

func _SysMenu_GetSysMenu0_HTTP_Handler(srv SysMenuHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SysMenuReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/sysmenu.v1.SysMenu/GetSysMenu")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSysMenu(ctx, req.(*SysMenuReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SysMenuReply)
		return ctx.Result(200, reply)
	}
}

func _SysMenu_UpdateSysMenu0_HTTP_Handler(srv SysMenuHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SysMenuUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/sysmenu.v1.SysMenu/UpdateSysMenu")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSysMenu(ctx, req.(*SysMenuUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SysMenuUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _SysMenu_CreateSysMenu0_HTTP_Handler(srv SysMenuHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SysMenuCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/sysmenu.v1.SysMenu/CreateSysMenu")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateSysMenu(ctx, req.(*SysMenuCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SysMenuCreateReply)
		return ctx.Result(200, reply)
	}
}

func _SysMenu_DeleteSysMenu0_HTTP_Handler(srv SysMenuHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SysMenuDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/sysmenu.v1.SysMenu/DeleteSysMenu")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteSysMenu(ctx, req.(*SysMenuDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SysMenuDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _SysMenu_BatchDeleteSysMenu0_HTTP_Handler(srv SysMenuHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SysMenuBatchDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/sysmenu.v1.SysMenu/BatchDeleteSysMenu")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteSysMenu(ctx, req.(*SysMenuBatchDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SysMenuDeleteReply)
		return ctx.Result(200, reply)
	}
}

type SysMenuHTTPClient interface {
	BatchDeleteSysMenu(ctx context.Context, req *SysMenuBatchDeleteReq, opts ...http.CallOption) (rsp *SysMenuDeleteReply, err error)
	CreateSysMenu(ctx context.Context, req *SysMenuCreateReq, opts ...http.CallOption) (rsp *SysMenuCreateReply, err error)
	DeleteSysMenu(ctx context.Context, req *SysMenuDeleteReq, opts ...http.CallOption) (rsp *SysMenuDeleteReply, err error)
	GetSysMenu(ctx context.Context, req *SysMenuReq, opts ...http.CallOption) (rsp *SysMenuReply, err error)
	GetSysMenuPage(ctx context.Context, req *SysMenuPageReq, opts ...http.CallOption) (rsp *SysMenuPageReply, err error)
	UpdateSysMenu(ctx context.Context, req *SysMenuUpdateReq, opts ...http.CallOption) (rsp *SysMenuUpdateReply, err error)
}

type SysMenuHTTPClientImpl struct {
	cc *http.Client
}

func NewSysMenuHTTPClient(client *http.Client) SysMenuHTTPClient {
	return &SysMenuHTTPClientImpl{client}
}

func (c *SysMenuHTTPClientImpl) BatchDeleteSysMenu(ctx context.Context, in *SysMenuBatchDeleteReq, opts ...http.CallOption) (*SysMenuDeleteReply, error) {
	var out SysMenuDeleteReply
	pattern := "/v1/sys/menu"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/sysmenu.v1.SysMenu/BatchDeleteSysMenu"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *SysMenuHTTPClientImpl) CreateSysMenu(ctx context.Context, in *SysMenuCreateReq, opts ...http.CallOption) (*SysMenuCreateReply, error) {
	var out SysMenuCreateReply
	pattern := "/v1/sys/menu"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/sysmenu.v1.SysMenu/CreateSysMenu"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *SysMenuHTTPClientImpl) DeleteSysMenu(ctx context.Context, in *SysMenuDeleteReq, opts ...http.CallOption) (*SysMenuDeleteReply, error) {
	var out SysMenuDeleteReply
	pattern := "/v1/sys/menu/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/sysmenu.v1.SysMenu/DeleteSysMenu"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *SysMenuHTTPClientImpl) GetSysMenu(ctx context.Context, in *SysMenuReq, opts ...http.CallOption) (*SysMenuReply, error) {
	var out SysMenuReply
	pattern := "/v1/sys/menu/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/sysmenu.v1.SysMenu/GetSysMenu"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *SysMenuHTTPClientImpl) GetSysMenuPage(ctx context.Context, in *SysMenuPageReq, opts ...http.CallOption) (*SysMenuPageReply, error) {
	var out SysMenuPageReply
	pattern := "/v1/sys/menu/page"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/sysmenu.v1.SysMenu/GetSysMenuPage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *SysMenuHTTPClientImpl) UpdateSysMenu(ctx context.Context, in *SysMenuUpdateReq, opts ...http.CallOption) (*SysMenuUpdateReply, error) {
	var out SysMenuUpdateReply
	pattern := "/v1/sys/menu/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/sysmenu.v1.SysMenu/UpdateSysMenu"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
