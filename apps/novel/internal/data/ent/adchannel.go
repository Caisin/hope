// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"hope/apps/novel/internal/data/ent/adchannel"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// AdChannel is the model entity for the AdChannel schema.
type AdChannel struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// ChannelName holds the value of the "channelName" field.
	// 渠道名称
	ChannelName string `json:"channelName,omitempty"`
	// NovelId holds the value of the "novelId" field.
	// 书号
	NovelId int64 `json:"novelId,omitempty"`
	// Reg holds the value of the "reg" field.
	// 充值回传比例
	Reg int64 `json:"reg,omitempty"`
	// Pay holds the value of the "pay" field.
	// 付费回传比例
	Pay int64 `json:"pay,omitempty"`
	// NovelName holds the value of the "novelName" field.
	// 书名
	NovelName string `json:"novelName,omitempty"`
	// ChapterId holds the value of the "chapterId" field.
	// 章节号
	ChapterId int64 `json:"chapterId,omitempty"`
	// ChapterNum holds the value of the "chapterNum" field.
	// 章节数
	ChapterNum int32 `json:"chapterNum,omitempty"`
	// AdType holds the value of the "adType" field.
	// 投放渠道
	AdType string `json:"adType,omitempty"`
	// Img holds the value of the "img" field.
	// 落地页图片uri
	Img string `json:"img,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	// 创建时间
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	// 更新时间
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
	// CreateBy holds the value of the "createBy" field.
	// 创建者
	CreateBy int64 `json:"createBy,omitempty"`
	// UpdateBy holds the value of the "updateBy" field.
	// 更新者
	UpdateBy int64 `json:"updateBy,omitempty"`
	// TenantId holds the value of the "tenantId" field.
	// 租户
	TenantId int64 `json:"tenantId,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the AdChannelQuery when eager-loading is set.
	Edges AdChannelEdges `json:"edges"`
}

// AdChannelEdges holds the relations/edges for other nodes in the graph.
type AdChannelEdges struct {
	// Users holds the value of the users edge.
	Users []*SocialUser `json:"users,omitempty"`
	// Orders holds the value of the orders edge.
	Orders []*PayOrder `json:"orders,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// UsersOrErr returns the Users value or an error if the edge
// was not loaded in eager-loading.
func (e AdChannelEdges) UsersOrErr() ([]*SocialUser, error) {
	if e.loadedTypes[0] {
		return e.Users, nil
	}
	return nil, &NotLoadedError{edge: "users"}
}

// OrdersOrErr returns the Orders value or an error if the edge
// was not loaded in eager-loading.
func (e AdChannelEdges) OrdersOrErr() ([]*PayOrder, error) {
	if e.loadedTypes[1] {
		return e.Orders, nil
	}
	return nil, &NotLoadedError{edge: "orders"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*AdChannel) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case adchannel.FieldID, adchannel.FieldNovelId, adchannel.FieldReg, adchannel.FieldPay, adchannel.FieldChapterId, adchannel.FieldChapterNum, adchannel.FieldCreateBy, adchannel.FieldUpdateBy, adchannel.FieldTenantId:
			values[i] = new(sql.NullInt64)
		case adchannel.FieldChannelName, adchannel.FieldNovelName, adchannel.FieldAdType, adchannel.FieldImg:
			values[i] = new(sql.NullString)
		case adchannel.FieldCreatedAt, adchannel.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type AdChannel", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the AdChannel fields.
func (ac *AdChannel) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case adchannel.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ac.ID = int64(value.Int64)
		case adchannel.FieldChannelName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field channelName", values[i])
			} else if value.Valid {
				ac.ChannelName = value.String
			}
		case adchannel.FieldNovelId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field novelId", values[i])
			} else if value.Valid {
				ac.NovelId = value.Int64
			}
		case adchannel.FieldReg:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field reg", values[i])
			} else if value.Valid {
				ac.Reg = value.Int64
			}
		case adchannel.FieldPay:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field pay", values[i])
			} else if value.Valid {
				ac.Pay = value.Int64
			}
		case adchannel.FieldNovelName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field novelName", values[i])
			} else if value.Valid {
				ac.NovelName = value.String
			}
		case adchannel.FieldChapterId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field chapterId", values[i])
			} else if value.Valid {
				ac.ChapterId = value.Int64
			}
		case adchannel.FieldChapterNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field chapterNum", values[i])
			} else if value.Valid {
				ac.ChapterNum = int32(value.Int64)
			}
		case adchannel.FieldAdType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field adType", values[i])
			} else if value.Valid {
				ac.AdType = value.String
			}
		case adchannel.FieldImg:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field img", values[i])
			} else if value.Valid {
				ac.Img = value.String
			}
		case adchannel.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdAt", values[i])
			} else if value.Valid {
				ac.CreatedAt = value.Time
			}
		case adchannel.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedAt", values[i])
			} else if value.Valid {
				ac.UpdatedAt = value.Time
			}
		case adchannel.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field createBy", values[i])
			} else if value.Valid {
				ac.CreateBy = value.Int64
			}
		case adchannel.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updateBy", values[i])
			} else if value.Valid {
				ac.UpdateBy = value.Int64
			}
		case adchannel.FieldTenantId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenantId", values[i])
			} else if value.Valid {
				ac.TenantId = value.Int64
			}
		}
	}
	return nil
}

// QueryUsers queries the "users" edge of the AdChannel entity.
func (ac *AdChannel) QueryUsers() *SocialUserQuery {
	return (&AdChannelClient{config: ac.config}).QueryUsers(ac)
}

// QueryOrders queries the "orders" edge of the AdChannel entity.
func (ac *AdChannel) QueryOrders() *PayOrderQuery {
	return (&AdChannelClient{config: ac.config}).QueryOrders(ac)
}

// Update returns a builder for updating this AdChannel.
// Note that you need to call AdChannel.Unwrap() before calling this method if this AdChannel
// was returned from a transaction, and the transaction was committed or rolled back.
func (ac *AdChannel) Update() *AdChannelUpdateOne {
	return (&AdChannelClient{config: ac.config}).UpdateOne(ac)
}

// Unwrap unwraps the AdChannel entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ac *AdChannel) Unwrap() *AdChannel {
	tx, ok := ac.config.driver.(*txDriver)
	if !ok {
		panic("ent: AdChannel is not a transactional entity")
	}
	ac.config.driver = tx.drv
	return ac
}

// String implements the fmt.Stringer.
func (ac *AdChannel) String() string {
	var builder strings.Builder
	builder.WriteString("AdChannel(")
	builder.WriteString(fmt.Sprintf("id=%v", ac.ID))
	builder.WriteString(", channelName=")
	builder.WriteString(ac.ChannelName)
	builder.WriteString(", novelId=")
	builder.WriteString(fmt.Sprintf("%v", ac.NovelId))
	builder.WriteString(", reg=")
	builder.WriteString(fmt.Sprintf("%v", ac.Reg))
	builder.WriteString(", pay=")
	builder.WriteString(fmt.Sprintf("%v", ac.Pay))
	builder.WriteString(", novelName=")
	builder.WriteString(ac.NovelName)
	builder.WriteString(", chapterId=")
	builder.WriteString(fmt.Sprintf("%v", ac.ChapterId))
	builder.WriteString(", chapterNum=")
	builder.WriteString(fmt.Sprintf("%v", ac.ChapterNum))
	builder.WriteString(", adType=")
	builder.WriteString(ac.AdType)
	builder.WriteString(", img=")
	builder.WriteString(ac.Img)
	builder.WriteString(", createdAt=")
	builder.WriteString(ac.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updatedAt=")
	builder.WriteString(ac.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", createBy=")
	builder.WriteString(fmt.Sprintf("%v", ac.CreateBy))
	builder.WriteString(", updateBy=")
	builder.WriteString(fmt.Sprintf("%v", ac.UpdateBy))
	builder.WriteString(", tenantId=")
	builder.WriteString(fmt.Sprintf("%v", ac.TenantId))
	builder.WriteByte(')')
	return builder.String()
}

// AdChannels is a parsable slice of AdChannel.
type AdChannels []*AdChannel

func (ac AdChannels) config(cfg config) {
	for _i := range ac {
		ac[_i].config = cfg
	}
}
