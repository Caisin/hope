// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"hope/apps/param/internal/data/ent/novelpayconfig"
	"hope/apps/param/internal/data/ent/noveltag"
	"hope/apps/param/internal/data/ent/pageconfig"
	"hope/apps/param/internal/data/ent/predicate"
	"hope/apps/param/internal/data/ent/qiniuconfig"
	"hope/apps/param/internal/data/ent/resourcegroup"
	"hope/apps/param/internal/data/ent/resourcestorage"
	"hope/apps/param/internal/data/ent/scoreproduct"
	"hope/apps/param/internal/data/ent/task"
	"hope/apps/param/internal/data/ent/useranalysisstatistics"
	"hope/apps/param/internal/data/ent/userconsume"
	"hope/apps/param/internal/data/ent/userresource"
	"hope/apps/param/internal/data/ent/userresourcerecord"
	"hope/apps/param/internal/data/ent/viptype"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeNovelPayConfig         = "NovelPayConfig"
	TypeNovelTag               = "NovelTag"
	TypePageConfig             = "PageConfig"
	TypeQiniuConfig            = "QiniuConfig"
	TypeResourceGroup          = "ResourceGroup"
	TypeResourceStorage        = "ResourceStorage"
	TypeScoreProduct           = "ScoreProduct"
	TypeTask                   = "Task"
	TypeUserAnalysisStatistics = "UserAnalysisStatistics"
	TypeUserConsume            = "UserConsume"
	TypeUserResource           = "UserResource"
	TypeUserResourceRecord     = "UserResourceRecord"
	TypeVipType                = "VipType"
)

// NovelPayConfigMutation represents an operation that mutates the NovelPayConfig nodes in the graph.
type NovelPayConfigMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	productId        *string
	paymentName      *string
	firstPayment     *int64
	addfirstPayment  *int64
	payment          *int64
	addpayment       *int64
	originalPrice    *int64
	addoriginalPrice *int64
	cfgType          *string
	coin             *int64
	addcoin          *int64
	currency         *string
	coupon           *int64
	addcoupon        *int64
	coinItem         *int32
	addcoinItem      *int32
	couponItem       *int32
	addcouponItem    *int32
	sort             *int32
	addsort          *int32
	state            *bool
	isSend           *int32
	addisSend        *int32
	payType          *int32
	addpayType       *int32
	vipType          *int64
	addvipType       *int64
	isHot            *bool
	cycleDay         *int32
	addcycleDay      *int32
	summary          *string
	remark           *string
	effectTime       *time.Time
	expiredTime      *time.Time
	createdAt        *time.Time
	updatedAt        *time.Time
	createBy         *int64
	addcreateBy      *int64
	updateBy         *int64
	addupdateBy      *int64
	tenantId         *int64
	addtenantId      *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*NovelPayConfig, error)
	predicates       []predicate.NovelPayConfig
}

var _ ent.Mutation = (*NovelPayConfigMutation)(nil)

// novelpayconfigOption allows management of the mutation configuration using functional options.
type novelpayconfigOption func(*NovelPayConfigMutation)

// newNovelPayConfigMutation creates new mutation for the NovelPayConfig entity.
func newNovelPayConfigMutation(c config, op Op, opts ...novelpayconfigOption) *NovelPayConfigMutation {
	m := &NovelPayConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelPayConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelPayConfigID sets the ID field of the mutation.
func withNovelPayConfigID(id int64) novelpayconfigOption {
	return func(m *NovelPayConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelPayConfig
		)
		m.oldValue = func(ctx context.Context) (*NovelPayConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelPayConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelPayConfig sets the old NovelPayConfig of the mutation.
func withNovelPayConfig(node *NovelPayConfig) novelpayconfigOption {
	return func(m *NovelPayConfigMutation) {
		m.oldValue = func(context.Context) (*NovelPayConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelPayConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelPayConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelPayConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelPayConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelPayConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductId sets the "productId" field.
func (m *NovelPayConfigMutation) SetProductId(s string) {
	m.productId = &s
}

// ProductId returns the value of the "productId" field in the mutation.
func (m *NovelPayConfigMutation) ProductId() (r string, exists bool) {
	v := m.productId
	if v == nil {
		return
	}
	return *v, true
}

// OldProductId returns the old "productId" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldProductId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductId: %w", err)
	}
	return oldValue.ProductId, nil
}

// ClearProductId clears the value of the "productId" field.
func (m *NovelPayConfigMutation) ClearProductId() {
	m.productId = nil
	m.clearedFields[novelpayconfig.FieldProductId] = struct{}{}
}

// ProductIdCleared returns if the "productId" field was cleared in this mutation.
func (m *NovelPayConfigMutation) ProductIdCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldProductId]
	return ok
}

// ResetProductId resets all changes to the "productId" field.
func (m *NovelPayConfigMutation) ResetProductId() {
	m.productId = nil
	delete(m.clearedFields, novelpayconfig.FieldProductId)
}

// SetPaymentName sets the "paymentName" field.
func (m *NovelPayConfigMutation) SetPaymentName(s string) {
	m.paymentName = &s
}

// PaymentName returns the value of the "paymentName" field in the mutation.
func (m *NovelPayConfigMutation) PaymentName() (r string, exists bool) {
	v := m.paymentName
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentName returns the old "paymentName" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldPaymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentName: %w", err)
	}
	return oldValue.PaymentName, nil
}

// ClearPaymentName clears the value of the "paymentName" field.
func (m *NovelPayConfigMutation) ClearPaymentName() {
	m.paymentName = nil
	m.clearedFields[novelpayconfig.FieldPaymentName] = struct{}{}
}

// PaymentNameCleared returns if the "paymentName" field was cleared in this mutation.
func (m *NovelPayConfigMutation) PaymentNameCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldPaymentName]
	return ok
}

// ResetPaymentName resets all changes to the "paymentName" field.
func (m *NovelPayConfigMutation) ResetPaymentName() {
	m.paymentName = nil
	delete(m.clearedFields, novelpayconfig.FieldPaymentName)
}

// SetFirstPayment sets the "firstPayment" field.
func (m *NovelPayConfigMutation) SetFirstPayment(i int64) {
	m.firstPayment = &i
	m.addfirstPayment = nil
}

// FirstPayment returns the value of the "firstPayment" field in the mutation.
func (m *NovelPayConfigMutation) FirstPayment() (r int64, exists bool) {
	v := m.firstPayment
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstPayment returns the old "firstPayment" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldFirstPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstPayment: %w", err)
	}
	return oldValue.FirstPayment, nil
}

// AddFirstPayment adds i to the "firstPayment" field.
func (m *NovelPayConfigMutation) AddFirstPayment(i int64) {
	if m.addfirstPayment != nil {
		*m.addfirstPayment += i
	} else {
		m.addfirstPayment = &i
	}
}

// AddedFirstPayment returns the value that was added to the "firstPayment" field in this mutation.
func (m *NovelPayConfigMutation) AddedFirstPayment() (r int64, exists bool) {
	v := m.addfirstPayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstPayment clears the value of the "firstPayment" field.
func (m *NovelPayConfigMutation) ClearFirstPayment() {
	m.firstPayment = nil
	m.addfirstPayment = nil
	m.clearedFields[novelpayconfig.FieldFirstPayment] = struct{}{}
}

// FirstPaymentCleared returns if the "firstPayment" field was cleared in this mutation.
func (m *NovelPayConfigMutation) FirstPaymentCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldFirstPayment]
	return ok
}

// ResetFirstPayment resets all changes to the "firstPayment" field.
func (m *NovelPayConfigMutation) ResetFirstPayment() {
	m.firstPayment = nil
	m.addfirstPayment = nil
	delete(m.clearedFields, novelpayconfig.FieldFirstPayment)
}

// SetPayment sets the "payment" field.
func (m *NovelPayConfigMutation) SetPayment(i int64) {
	m.payment = &i
	m.addpayment = nil
}

// Payment returns the value of the "payment" field in the mutation.
func (m *NovelPayConfigMutation) Payment() (r int64, exists bool) {
	v := m.payment
	if v == nil {
		return
	}
	return *v, true
}

// OldPayment returns the old "payment" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayment: %w", err)
	}
	return oldValue.Payment, nil
}

// AddPayment adds i to the "payment" field.
func (m *NovelPayConfigMutation) AddPayment(i int64) {
	if m.addpayment != nil {
		*m.addpayment += i
	} else {
		m.addpayment = &i
	}
}

// AddedPayment returns the value that was added to the "payment" field in this mutation.
func (m *NovelPayConfigMutation) AddedPayment() (r int64, exists bool) {
	v := m.addpayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayment clears the value of the "payment" field.
func (m *NovelPayConfigMutation) ClearPayment() {
	m.payment = nil
	m.addpayment = nil
	m.clearedFields[novelpayconfig.FieldPayment] = struct{}{}
}

// PaymentCleared returns if the "payment" field was cleared in this mutation.
func (m *NovelPayConfigMutation) PaymentCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldPayment]
	return ok
}

// ResetPayment resets all changes to the "payment" field.
func (m *NovelPayConfigMutation) ResetPayment() {
	m.payment = nil
	m.addpayment = nil
	delete(m.clearedFields, novelpayconfig.FieldPayment)
}

// SetOriginalPrice sets the "originalPrice" field.
func (m *NovelPayConfigMutation) SetOriginalPrice(i int64) {
	m.originalPrice = &i
	m.addoriginalPrice = nil
}

// OriginalPrice returns the value of the "originalPrice" field in the mutation.
func (m *NovelPayConfigMutation) OriginalPrice() (r int64, exists bool) {
	v := m.originalPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalPrice returns the old "originalPrice" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldOriginalPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalPrice: %w", err)
	}
	return oldValue.OriginalPrice, nil
}

// AddOriginalPrice adds i to the "originalPrice" field.
func (m *NovelPayConfigMutation) AddOriginalPrice(i int64) {
	if m.addoriginalPrice != nil {
		*m.addoriginalPrice += i
	} else {
		m.addoriginalPrice = &i
	}
}

// AddedOriginalPrice returns the value that was added to the "originalPrice" field in this mutation.
func (m *NovelPayConfigMutation) AddedOriginalPrice() (r int64, exists bool) {
	v := m.addoriginalPrice
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginalPrice clears the value of the "originalPrice" field.
func (m *NovelPayConfigMutation) ClearOriginalPrice() {
	m.originalPrice = nil
	m.addoriginalPrice = nil
	m.clearedFields[novelpayconfig.FieldOriginalPrice] = struct{}{}
}

// OriginalPriceCleared returns if the "originalPrice" field was cleared in this mutation.
func (m *NovelPayConfigMutation) OriginalPriceCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldOriginalPrice]
	return ok
}

// ResetOriginalPrice resets all changes to the "originalPrice" field.
func (m *NovelPayConfigMutation) ResetOriginalPrice() {
	m.originalPrice = nil
	m.addoriginalPrice = nil
	delete(m.clearedFields, novelpayconfig.FieldOriginalPrice)
}

// SetCfgType sets the "cfgType" field.
func (m *NovelPayConfigMutation) SetCfgType(s string) {
	m.cfgType = &s
}

// CfgType returns the value of the "cfgType" field in the mutation.
func (m *NovelPayConfigMutation) CfgType() (r string, exists bool) {
	v := m.cfgType
	if v == nil {
		return
	}
	return *v, true
}

// OldCfgType returns the old "cfgType" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCfgType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfgType: %w", err)
	}
	return oldValue.CfgType, nil
}

// ClearCfgType clears the value of the "cfgType" field.
func (m *NovelPayConfigMutation) ClearCfgType() {
	m.cfgType = nil
	m.clearedFields[novelpayconfig.FieldCfgType] = struct{}{}
}

// CfgTypeCleared returns if the "cfgType" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CfgTypeCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCfgType]
	return ok
}

// ResetCfgType resets all changes to the "cfgType" field.
func (m *NovelPayConfigMutation) ResetCfgType() {
	m.cfgType = nil
	delete(m.clearedFields, novelpayconfig.FieldCfgType)
}

// SetCoin sets the "coin" field.
func (m *NovelPayConfigMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *NovelPayConfigMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *NovelPayConfigMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *NovelPayConfigMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoin clears the value of the "coin" field.
func (m *NovelPayConfigMutation) ClearCoin() {
	m.coin = nil
	m.addcoin = nil
	m.clearedFields[novelpayconfig.FieldCoin] = struct{}{}
}

// CoinCleared returns if the "coin" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CoinCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCoin]
	return ok
}

// ResetCoin resets all changes to the "coin" field.
func (m *NovelPayConfigMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
	delete(m.clearedFields, novelpayconfig.FieldCoin)
}

// SetCurrency sets the "currency" field.
func (m *NovelPayConfigMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *NovelPayConfigMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *NovelPayConfigMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[novelpayconfig.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *NovelPayConfigMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, novelpayconfig.FieldCurrency)
}

// SetCoupon sets the "coupon" field.
func (m *NovelPayConfigMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *NovelPayConfigMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *NovelPayConfigMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *NovelPayConfigMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoupon clears the value of the "coupon" field.
func (m *NovelPayConfigMutation) ClearCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	m.clearedFields[novelpayconfig.FieldCoupon] = struct{}{}
}

// CouponCleared returns if the "coupon" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CouponCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCoupon]
	return ok
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *NovelPayConfigMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	delete(m.clearedFields, novelpayconfig.FieldCoupon)
}

// SetCoinItem sets the "coinItem" field.
func (m *NovelPayConfigMutation) SetCoinItem(i int32) {
	m.coinItem = &i
	m.addcoinItem = nil
}

// CoinItem returns the value of the "coinItem" field in the mutation.
func (m *NovelPayConfigMutation) CoinItem() (r int32, exists bool) {
	v := m.coinItem
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinItem returns the old "coinItem" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCoinItem(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinItem: %w", err)
	}
	return oldValue.CoinItem, nil
}

// AddCoinItem adds i to the "coinItem" field.
func (m *NovelPayConfigMutation) AddCoinItem(i int32) {
	if m.addcoinItem != nil {
		*m.addcoinItem += i
	} else {
		m.addcoinItem = &i
	}
}

// AddedCoinItem returns the value that was added to the "coinItem" field in this mutation.
func (m *NovelPayConfigMutation) AddedCoinItem() (r int32, exists bool) {
	v := m.addcoinItem
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoinItem clears the value of the "coinItem" field.
func (m *NovelPayConfigMutation) ClearCoinItem() {
	m.coinItem = nil
	m.addcoinItem = nil
	m.clearedFields[novelpayconfig.FieldCoinItem] = struct{}{}
}

// CoinItemCleared returns if the "coinItem" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CoinItemCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCoinItem]
	return ok
}

// ResetCoinItem resets all changes to the "coinItem" field.
func (m *NovelPayConfigMutation) ResetCoinItem() {
	m.coinItem = nil
	m.addcoinItem = nil
	delete(m.clearedFields, novelpayconfig.FieldCoinItem)
}

// SetCouponItem sets the "couponItem" field.
func (m *NovelPayConfigMutation) SetCouponItem(i int32) {
	m.couponItem = &i
	m.addcouponItem = nil
}

// CouponItem returns the value of the "couponItem" field in the mutation.
func (m *NovelPayConfigMutation) CouponItem() (r int32, exists bool) {
	v := m.couponItem
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponItem returns the old "couponItem" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCouponItem(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponItem: %w", err)
	}
	return oldValue.CouponItem, nil
}

// AddCouponItem adds i to the "couponItem" field.
func (m *NovelPayConfigMutation) AddCouponItem(i int32) {
	if m.addcouponItem != nil {
		*m.addcouponItem += i
	} else {
		m.addcouponItem = &i
	}
}

// AddedCouponItem returns the value that was added to the "couponItem" field in this mutation.
func (m *NovelPayConfigMutation) AddedCouponItem() (r int32, exists bool) {
	v := m.addcouponItem
	if v == nil {
		return
	}
	return *v, true
}

// ClearCouponItem clears the value of the "couponItem" field.
func (m *NovelPayConfigMutation) ClearCouponItem() {
	m.couponItem = nil
	m.addcouponItem = nil
	m.clearedFields[novelpayconfig.FieldCouponItem] = struct{}{}
}

// CouponItemCleared returns if the "couponItem" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CouponItemCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCouponItem]
	return ok
}

// ResetCouponItem resets all changes to the "couponItem" field.
func (m *NovelPayConfigMutation) ResetCouponItem() {
	m.couponItem = nil
	m.addcouponItem = nil
	delete(m.clearedFields, novelpayconfig.FieldCouponItem)
}

// SetSort sets the "sort" field.
func (m *NovelPayConfigMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *NovelPayConfigMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *NovelPayConfigMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *NovelPayConfigMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *NovelPayConfigMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[novelpayconfig.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *NovelPayConfigMutation) SortCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *NovelPayConfigMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, novelpayconfig.FieldSort)
}

// SetState sets the "state" field.
func (m *NovelPayConfigMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *NovelPayConfigMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *NovelPayConfigMutation) ClearState() {
	m.state = nil
	m.clearedFields[novelpayconfig.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *NovelPayConfigMutation) StateCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *NovelPayConfigMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, novelpayconfig.FieldState)
}

// SetIsSend sets the "isSend" field.
func (m *NovelPayConfigMutation) SetIsSend(i int32) {
	m.isSend = &i
	m.addisSend = nil
}

// IsSend returns the value of the "isSend" field in the mutation.
func (m *NovelPayConfigMutation) IsSend() (r int32, exists bool) {
	v := m.isSend
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSend returns the old "isSend" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldIsSend(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSend: %w", err)
	}
	return oldValue.IsSend, nil
}

// AddIsSend adds i to the "isSend" field.
func (m *NovelPayConfigMutation) AddIsSend(i int32) {
	if m.addisSend != nil {
		*m.addisSend += i
	} else {
		m.addisSend = &i
	}
}

// AddedIsSend returns the value that was added to the "isSend" field in this mutation.
func (m *NovelPayConfigMutation) AddedIsSend() (r int32, exists bool) {
	v := m.addisSend
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsSend clears the value of the "isSend" field.
func (m *NovelPayConfigMutation) ClearIsSend() {
	m.isSend = nil
	m.addisSend = nil
	m.clearedFields[novelpayconfig.FieldIsSend] = struct{}{}
}

// IsSendCleared returns if the "isSend" field was cleared in this mutation.
func (m *NovelPayConfigMutation) IsSendCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldIsSend]
	return ok
}

// ResetIsSend resets all changes to the "isSend" field.
func (m *NovelPayConfigMutation) ResetIsSend() {
	m.isSend = nil
	m.addisSend = nil
	delete(m.clearedFields, novelpayconfig.FieldIsSend)
}

// SetPayType sets the "payType" field.
func (m *NovelPayConfigMutation) SetPayType(i int32) {
	m.payType = &i
	m.addpayType = nil
}

// PayType returns the value of the "payType" field in the mutation.
func (m *NovelPayConfigMutation) PayType() (r int32, exists bool) {
	v := m.payType
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "payType" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldPayType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// AddPayType adds i to the "payType" field.
func (m *NovelPayConfigMutation) AddPayType(i int32) {
	if m.addpayType != nil {
		*m.addpayType += i
	} else {
		m.addpayType = &i
	}
}

// AddedPayType returns the value that was added to the "payType" field in this mutation.
func (m *NovelPayConfigMutation) AddedPayType() (r int32, exists bool) {
	v := m.addpayType
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayType clears the value of the "payType" field.
func (m *NovelPayConfigMutation) ClearPayType() {
	m.payType = nil
	m.addpayType = nil
	m.clearedFields[novelpayconfig.FieldPayType] = struct{}{}
}

// PayTypeCleared returns if the "payType" field was cleared in this mutation.
func (m *NovelPayConfigMutation) PayTypeCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldPayType]
	return ok
}

// ResetPayType resets all changes to the "payType" field.
func (m *NovelPayConfigMutation) ResetPayType() {
	m.payType = nil
	m.addpayType = nil
	delete(m.clearedFields, novelpayconfig.FieldPayType)
}

// SetVipType sets the "vipType" field.
func (m *NovelPayConfigMutation) SetVipType(i int64) {
	m.vipType = &i
	m.addvipType = nil
}

// VipType returns the value of the "vipType" field in the mutation.
func (m *NovelPayConfigMutation) VipType() (r int64, exists bool) {
	v := m.vipType
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vipType" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldVipType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vipType" field.
func (m *NovelPayConfigMutation) AddVipType(i int64) {
	if m.addvipType != nil {
		*m.addvipType += i
	} else {
		m.addvipType = &i
	}
}

// AddedVipType returns the value that was added to the "vipType" field in this mutation.
func (m *NovelPayConfigMutation) AddedVipType() (r int64, exists bool) {
	v := m.addvipType
	if v == nil {
		return
	}
	return *v, true
}

// ClearVipType clears the value of the "vipType" field.
func (m *NovelPayConfigMutation) ClearVipType() {
	m.vipType = nil
	m.addvipType = nil
	m.clearedFields[novelpayconfig.FieldVipType] = struct{}{}
}

// VipTypeCleared returns if the "vipType" field was cleared in this mutation.
func (m *NovelPayConfigMutation) VipTypeCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldVipType]
	return ok
}

// ResetVipType resets all changes to the "vipType" field.
func (m *NovelPayConfigMutation) ResetVipType() {
	m.vipType = nil
	m.addvipType = nil
	delete(m.clearedFields, novelpayconfig.FieldVipType)
}

// SetIsHot sets the "isHot" field.
func (m *NovelPayConfigMutation) SetIsHot(b bool) {
	m.isHot = &b
}

// IsHot returns the value of the "isHot" field in the mutation.
func (m *NovelPayConfigMutation) IsHot() (r bool, exists bool) {
	v := m.isHot
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHot returns the old "isHot" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldIsHot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHot: %w", err)
	}
	return oldValue.IsHot, nil
}

// ClearIsHot clears the value of the "isHot" field.
func (m *NovelPayConfigMutation) ClearIsHot() {
	m.isHot = nil
	m.clearedFields[novelpayconfig.FieldIsHot] = struct{}{}
}

// IsHotCleared returns if the "isHot" field was cleared in this mutation.
func (m *NovelPayConfigMutation) IsHotCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldIsHot]
	return ok
}

// ResetIsHot resets all changes to the "isHot" field.
func (m *NovelPayConfigMutation) ResetIsHot() {
	m.isHot = nil
	delete(m.clearedFields, novelpayconfig.FieldIsHot)
}

// SetCycleDay sets the "cycleDay" field.
func (m *NovelPayConfigMutation) SetCycleDay(i int32) {
	m.cycleDay = &i
	m.addcycleDay = nil
}

// CycleDay returns the value of the "cycleDay" field in the mutation.
func (m *NovelPayConfigMutation) CycleDay() (r int32, exists bool) {
	v := m.cycleDay
	if v == nil {
		return
	}
	return *v, true
}

// OldCycleDay returns the old "cycleDay" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCycleDay(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycleDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycleDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycleDay: %w", err)
	}
	return oldValue.CycleDay, nil
}

// AddCycleDay adds i to the "cycleDay" field.
func (m *NovelPayConfigMutation) AddCycleDay(i int32) {
	if m.addcycleDay != nil {
		*m.addcycleDay += i
	} else {
		m.addcycleDay = &i
	}
}

// AddedCycleDay returns the value that was added to the "cycleDay" field in this mutation.
func (m *NovelPayConfigMutation) AddedCycleDay() (r int32, exists bool) {
	v := m.addcycleDay
	if v == nil {
		return
	}
	return *v, true
}

// ClearCycleDay clears the value of the "cycleDay" field.
func (m *NovelPayConfigMutation) ClearCycleDay() {
	m.cycleDay = nil
	m.addcycleDay = nil
	m.clearedFields[novelpayconfig.FieldCycleDay] = struct{}{}
}

// CycleDayCleared returns if the "cycleDay" field was cleared in this mutation.
func (m *NovelPayConfigMutation) CycleDayCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldCycleDay]
	return ok
}

// ResetCycleDay resets all changes to the "cycleDay" field.
func (m *NovelPayConfigMutation) ResetCycleDay() {
	m.cycleDay = nil
	m.addcycleDay = nil
	delete(m.clearedFields, novelpayconfig.FieldCycleDay)
}

// SetSummary sets the "summary" field.
func (m *NovelPayConfigMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *NovelPayConfigMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *NovelPayConfigMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[novelpayconfig.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *NovelPayConfigMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *NovelPayConfigMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, novelpayconfig.FieldSummary)
}

// SetRemark sets the "remark" field.
func (m *NovelPayConfigMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelPayConfigMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelPayConfigMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelpayconfig.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelPayConfigMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelpayconfig.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelPayConfigMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelpayconfig.FieldRemark)
}

// SetEffectTime sets the "effectTime" field.
func (m *NovelPayConfigMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *NovelPayConfigMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *NovelPayConfigMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *NovelPayConfigMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *NovelPayConfigMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *NovelPayConfigMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelPayConfigMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelPayConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelPayConfigMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelPayConfigMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelPayConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelPayConfigMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelPayConfigMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelPayConfigMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelPayConfigMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelPayConfigMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelPayConfigMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelPayConfigMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelPayConfigMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelPayConfigMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelPayConfigMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelPayConfigMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelPayConfigMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelPayConfigMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelPayConfig entity.
// If the NovelPayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelPayConfigMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelPayConfigMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelPayConfigMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelPayConfigMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the NovelPayConfigMutation builder.
func (m *NovelPayConfigMutation) Where(ps ...predicate.NovelPayConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelPayConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelPayConfig).
func (m *NovelPayConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelPayConfigMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.productId != nil {
		fields = append(fields, novelpayconfig.FieldProductId)
	}
	if m.paymentName != nil {
		fields = append(fields, novelpayconfig.FieldPaymentName)
	}
	if m.firstPayment != nil {
		fields = append(fields, novelpayconfig.FieldFirstPayment)
	}
	if m.payment != nil {
		fields = append(fields, novelpayconfig.FieldPayment)
	}
	if m.originalPrice != nil {
		fields = append(fields, novelpayconfig.FieldOriginalPrice)
	}
	if m.cfgType != nil {
		fields = append(fields, novelpayconfig.FieldCfgType)
	}
	if m.coin != nil {
		fields = append(fields, novelpayconfig.FieldCoin)
	}
	if m.currency != nil {
		fields = append(fields, novelpayconfig.FieldCurrency)
	}
	if m.coupon != nil {
		fields = append(fields, novelpayconfig.FieldCoupon)
	}
	if m.coinItem != nil {
		fields = append(fields, novelpayconfig.FieldCoinItem)
	}
	if m.couponItem != nil {
		fields = append(fields, novelpayconfig.FieldCouponItem)
	}
	if m.sort != nil {
		fields = append(fields, novelpayconfig.FieldSort)
	}
	if m.state != nil {
		fields = append(fields, novelpayconfig.FieldState)
	}
	if m.isSend != nil {
		fields = append(fields, novelpayconfig.FieldIsSend)
	}
	if m.payType != nil {
		fields = append(fields, novelpayconfig.FieldPayType)
	}
	if m.vipType != nil {
		fields = append(fields, novelpayconfig.FieldVipType)
	}
	if m.isHot != nil {
		fields = append(fields, novelpayconfig.FieldIsHot)
	}
	if m.cycleDay != nil {
		fields = append(fields, novelpayconfig.FieldCycleDay)
	}
	if m.summary != nil {
		fields = append(fields, novelpayconfig.FieldSummary)
	}
	if m.remark != nil {
		fields = append(fields, novelpayconfig.FieldRemark)
	}
	if m.effectTime != nil {
		fields = append(fields, novelpayconfig.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, novelpayconfig.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, novelpayconfig.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelpayconfig.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelpayconfig.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelpayconfig.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelpayconfig.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelPayConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelpayconfig.FieldProductId:
		return m.ProductId()
	case novelpayconfig.FieldPaymentName:
		return m.PaymentName()
	case novelpayconfig.FieldFirstPayment:
		return m.FirstPayment()
	case novelpayconfig.FieldPayment:
		return m.Payment()
	case novelpayconfig.FieldOriginalPrice:
		return m.OriginalPrice()
	case novelpayconfig.FieldCfgType:
		return m.CfgType()
	case novelpayconfig.FieldCoin:
		return m.Coin()
	case novelpayconfig.FieldCurrency:
		return m.Currency()
	case novelpayconfig.FieldCoupon:
		return m.Coupon()
	case novelpayconfig.FieldCoinItem:
		return m.CoinItem()
	case novelpayconfig.FieldCouponItem:
		return m.CouponItem()
	case novelpayconfig.FieldSort:
		return m.Sort()
	case novelpayconfig.FieldState:
		return m.State()
	case novelpayconfig.FieldIsSend:
		return m.IsSend()
	case novelpayconfig.FieldPayType:
		return m.PayType()
	case novelpayconfig.FieldVipType:
		return m.VipType()
	case novelpayconfig.FieldIsHot:
		return m.IsHot()
	case novelpayconfig.FieldCycleDay:
		return m.CycleDay()
	case novelpayconfig.FieldSummary:
		return m.Summary()
	case novelpayconfig.FieldRemark:
		return m.Remark()
	case novelpayconfig.FieldEffectTime:
		return m.EffectTime()
	case novelpayconfig.FieldExpiredTime:
		return m.ExpiredTime()
	case novelpayconfig.FieldCreatedAt:
		return m.CreatedAt()
	case novelpayconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelpayconfig.FieldCreateBy:
		return m.CreateBy()
	case novelpayconfig.FieldUpdateBy:
		return m.UpdateBy()
	case novelpayconfig.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelPayConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelpayconfig.FieldProductId:
		return m.OldProductId(ctx)
	case novelpayconfig.FieldPaymentName:
		return m.OldPaymentName(ctx)
	case novelpayconfig.FieldFirstPayment:
		return m.OldFirstPayment(ctx)
	case novelpayconfig.FieldPayment:
		return m.OldPayment(ctx)
	case novelpayconfig.FieldOriginalPrice:
		return m.OldOriginalPrice(ctx)
	case novelpayconfig.FieldCfgType:
		return m.OldCfgType(ctx)
	case novelpayconfig.FieldCoin:
		return m.OldCoin(ctx)
	case novelpayconfig.FieldCurrency:
		return m.OldCurrency(ctx)
	case novelpayconfig.FieldCoupon:
		return m.OldCoupon(ctx)
	case novelpayconfig.FieldCoinItem:
		return m.OldCoinItem(ctx)
	case novelpayconfig.FieldCouponItem:
		return m.OldCouponItem(ctx)
	case novelpayconfig.FieldSort:
		return m.OldSort(ctx)
	case novelpayconfig.FieldState:
		return m.OldState(ctx)
	case novelpayconfig.FieldIsSend:
		return m.OldIsSend(ctx)
	case novelpayconfig.FieldPayType:
		return m.OldPayType(ctx)
	case novelpayconfig.FieldVipType:
		return m.OldVipType(ctx)
	case novelpayconfig.FieldIsHot:
		return m.OldIsHot(ctx)
	case novelpayconfig.FieldCycleDay:
		return m.OldCycleDay(ctx)
	case novelpayconfig.FieldSummary:
		return m.OldSummary(ctx)
	case novelpayconfig.FieldRemark:
		return m.OldRemark(ctx)
	case novelpayconfig.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case novelpayconfig.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case novelpayconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelpayconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelpayconfig.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelpayconfig.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelpayconfig.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelPayConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelPayConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelpayconfig.FieldProductId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductId(v)
		return nil
	case novelpayconfig.FieldPaymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentName(v)
		return nil
	case novelpayconfig.FieldFirstPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstPayment(v)
		return nil
	case novelpayconfig.FieldPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayment(v)
		return nil
	case novelpayconfig.FieldOriginalPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalPrice(v)
		return nil
	case novelpayconfig.FieldCfgType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfgType(v)
		return nil
	case novelpayconfig.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case novelpayconfig.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case novelpayconfig.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case novelpayconfig.FieldCoinItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinItem(v)
		return nil
	case novelpayconfig.FieldCouponItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponItem(v)
		return nil
	case novelpayconfig.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case novelpayconfig.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case novelpayconfig.FieldIsSend:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSend(v)
		return nil
	case novelpayconfig.FieldPayType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case novelpayconfig.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case novelpayconfig.FieldIsHot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHot(v)
		return nil
	case novelpayconfig.FieldCycleDay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycleDay(v)
		return nil
	case novelpayconfig.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case novelpayconfig.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelpayconfig.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case novelpayconfig.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case novelpayconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelpayconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelpayconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelpayconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelpayconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelPayConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelPayConfigMutation) AddedFields() []string {
	var fields []string
	if m.addfirstPayment != nil {
		fields = append(fields, novelpayconfig.FieldFirstPayment)
	}
	if m.addpayment != nil {
		fields = append(fields, novelpayconfig.FieldPayment)
	}
	if m.addoriginalPrice != nil {
		fields = append(fields, novelpayconfig.FieldOriginalPrice)
	}
	if m.addcoin != nil {
		fields = append(fields, novelpayconfig.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, novelpayconfig.FieldCoupon)
	}
	if m.addcoinItem != nil {
		fields = append(fields, novelpayconfig.FieldCoinItem)
	}
	if m.addcouponItem != nil {
		fields = append(fields, novelpayconfig.FieldCouponItem)
	}
	if m.addsort != nil {
		fields = append(fields, novelpayconfig.FieldSort)
	}
	if m.addisSend != nil {
		fields = append(fields, novelpayconfig.FieldIsSend)
	}
	if m.addpayType != nil {
		fields = append(fields, novelpayconfig.FieldPayType)
	}
	if m.addvipType != nil {
		fields = append(fields, novelpayconfig.FieldVipType)
	}
	if m.addcycleDay != nil {
		fields = append(fields, novelpayconfig.FieldCycleDay)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelpayconfig.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelpayconfig.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelpayconfig.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelPayConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelpayconfig.FieldFirstPayment:
		return m.AddedFirstPayment()
	case novelpayconfig.FieldPayment:
		return m.AddedPayment()
	case novelpayconfig.FieldOriginalPrice:
		return m.AddedOriginalPrice()
	case novelpayconfig.FieldCoin:
		return m.AddedCoin()
	case novelpayconfig.FieldCoupon:
		return m.AddedCoupon()
	case novelpayconfig.FieldCoinItem:
		return m.AddedCoinItem()
	case novelpayconfig.FieldCouponItem:
		return m.AddedCouponItem()
	case novelpayconfig.FieldSort:
		return m.AddedSort()
	case novelpayconfig.FieldIsSend:
		return m.AddedIsSend()
	case novelpayconfig.FieldPayType:
		return m.AddedPayType()
	case novelpayconfig.FieldVipType:
		return m.AddedVipType()
	case novelpayconfig.FieldCycleDay:
		return m.AddedCycleDay()
	case novelpayconfig.FieldCreateBy:
		return m.AddedCreateBy()
	case novelpayconfig.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelpayconfig.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelPayConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelpayconfig.FieldFirstPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstPayment(v)
		return nil
	case novelpayconfig.FieldPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayment(v)
		return nil
	case novelpayconfig.FieldOriginalPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalPrice(v)
		return nil
	case novelpayconfig.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case novelpayconfig.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case novelpayconfig.FieldCoinItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinItem(v)
		return nil
	case novelpayconfig.FieldCouponItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponItem(v)
		return nil
	case novelpayconfig.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case novelpayconfig.FieldIsSend:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsSend(v)
		return nil
	case novelpayconfig.FieldPayType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayType(v)
		return nil
	case novelpayconfig.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	case novelpayconfig.FieldCycleDay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCycleDay(v)
		return nil
	case novelpayconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelpayconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelpayconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelPayConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelPayConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelpayconfig.FieldProductId) {
		fields = append(fields, novelpayconfig.FieldProductId)
	}
	if m.FieldCleared(novelpayconfig.FieldPaymentName) {
		fields = append(fields, novelpayconfig.FieldPaymentName)
	}
	if m.FieldCleared(novelpayconfig.FieldFirstPayment) {
		fields = append(fields, novelpayconfig.FieldFirstPayment)
	}
	if m.FieldCleared(novelpayconfig.FieldPayment) {
		fields = append(fields, novelpayconfig.FieldPayment)
	}
	if m.FieldCleared(novelpayconfig.FieldOriginalPrice) {
		fields = append(fields, novelpayconfig.FieldOriginalPrice)
	}
	if m.FieldCleared(novelpayconfig.FieldCfgType) {
		fields = append(fields, novelpayconfig.FieldCfgType)
	}
	if m.FieldCleared(novelpayconfig.FieldCoin) {
		fields = append(fields, novelpayconfig.FieldCoin)
	}
	if m.FieldCleared(novelpayconfig.FieldCurrency) {
		fields = append(fields, novelpayconfig.FieldCurrency)
	}
	if m.FieldCleared(novelpayconfig.FieldCoupon) {
		fields = append(fields, novelpayconfig.FieldCoupon)
	}
	if m.FieldCleared(novelpayconfig.FieldCoinItem) {
		fields = append(fields, novelpayconfig.FieldCoinItem)
	}
	if m.FieldCleared(novelpayconfig.FieldCouponItem) {
		fields = append(fields, novelpayconfig.FieldCouponItem)
	}
	if m.FieldCleared(novelpayconfig.FieldSort) {
		fields = append(fields, novelpayconfig.FieldSort)
	}
	if m.FieldCleared(novelpayconfig.FieldState) {
		fields = append(fields, novelpayconfig.FieldState)
	}
	if m.FieldCleared(novelpayconfig.FieldIsSend) {
		fields = append(fields, novelpayconfig.FieldIsSend)
	}
	if m.FieldCleared(novelpayconfig.FieldPayType) {
		fields = append(fields, novelpayconfig.FieldPayType)
	}
	if m.FieldCleared(novelpayconfig.FieldVipType) {
		fields = append(fields, novelpayconfig.FieldVipType)
	}
	if m.FieldCleared(novelpayconfig.FieldIsHot) {
		fields = append(fields, novelpayconfig.FieldIsHot)
	}
	if m.FieldCleared(novelpayconfig.FieldCycleDay) {
		fields = append(fields, novelpayconfig.FieldCycleDay)
	}
	if m.FieldCleared(novelpayconfig.FieldSummary) {
		fields = append(fields, novelpayconfig.FieldSummary)
	}
	if m.FieldCleared(novelpayconfig.FieldRemark) {
		fields = append(fields, novelpayconfig.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelPayConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelPayConfigMutation) ClearField(name string) error {
	switch name {
	case novelpayconfig.FieldProductId:
		m.ClearProductId()
		return nil
	case novelpayconfig.FieldPaymentName:
		m.ClearPaymentName()
		return nil
	case novelpayconfig.FieldFirstPayment:
		m.ClearFirstPayment()
		return nil
	case novelpayconfig.FieldPayment:
		m.ClearPayment()
		return nil
	case novelpayconfig.FieldOriginalPrice:
		m.ClearOriginalPrice()
		return nil
	case novelpayconfig.FieldCfgType:
		m.ClearCfgType()
		return nil
	case novelpayconfig.FieldCoin:
		m.ClearCoin()
		return nil
	case novelpayconfig.FieldCurrency:
		m.ClearCurrency()
		return nil
	case novelpayconfig.FieldCoupon:
		m.ClearCoupon()
		return nil
	case novelpayconfig.FieldCoinItem:
		m.ClearCoinItem()
		return nil
	case novelpayconfig.FieldCouponItem:
		m.ClearCouponItem()
		return nil
	case novelpayconfig.FieldSort:
		m.ClearSort()
		return nil
	case novelpayconfig.FieldState:
		m.ClearState()
		return nil
	case novelpayconfig.FieldIsSend:
		m.ClearIsSend()
		return nil
	case novelpayconfig.FieldPayType:
		m.ClearPayType()
		return nil
	case novelpayconfig.FieldVipType:
		m.ClearVipType()
		return nil
	case novelpayconfig.FieldIsHot:
		m.ClearIsHot()
		return nil
	case novelpayconfig.FieldCycleDay:
		m.ClearCycleDay()
		return nil
	case novelpayconfig.FieldSummary:
		m.ClearSummary()
		return nil
	case novelpayconfig.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelPayConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelPayConfigMutation) ResetField(name string) error {
	switch name {
	case novelpayconfig.FieldProductId:
		m.ResetProductId()
		return nil
	case novelpayconfig.FieldPaymentName:
		m.ResetPaymentName()
		return nil
	case novelpayconfig.FieldFirstPayment:
		m.ResetFirstPayment()
		return nil
	case novelpayconfig.FieldPayment:
		m.ResetPayment()
		return nil
	case novelpayconfig.FieldOriginalPrice:
		m.ResetOriginalPrice()
		return nil
	case novelpayconfig.FieldCfgType:
		m.ResetCfgType()
		return nil
	case novelpayconfig.FieldCoin:
		m.ResetCoin()
		return nil
	case novelpayconfig.FieldCurrency:
		m.ResetCurrency()
		return nil
	case novelpayconfig.FieldCoupon:
		m.ResetCoupon()
		return nil
	case novelpayconfig.FieldCoinItem:
		m.ResetCoinItem()
		return nil
	case novelpayconfig.FieldCouponItem:
		m.ResetCouponItem()
		return nil
	case novelpayconfig.FieldSort:
		m.ResetSort()
		return nil
	case novelpayconfig.FieldState:
		m.ResetState()
		return nil
	case novelpayconfig.FieldIsSend:
		m.ResetIsSend()
		return nil
	case novelpayconfig.FieldPayType:
		m.ResetPayType()
		return nil
	case novelpayconfig.FieldVipType:
		m.ResetVipType()
		return nil
	case novelpayconfig.FieldIsHot:
		m.ResetIsHot()
		return nil
	case novelpayconfig.FieldCycleDay:
		m.ResetCycleDay()
		return nil
	case novelpayconfig.FieldSummary:
		m.ResetSummary()
		return nil
	case novelpayconfig.FieldRemark:
		m.ResetRemark()
		return nil
	case novelpayconfig.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case novelpayconfig.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case novelpayconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelpayconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelpayconfig.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelpayconfig.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelpayconfig.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelPayConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelPayConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelPayConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelPayConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelPayConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelPayConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelPayConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelPayConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NovelPayConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelPayConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NovelPayConfig edge %s", name)
}

// NovelTagMutation represents an operation that mutates the NovelTag nodes in the graph.
type NovelTagMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	tagId         *int64
	addtagId      *int64
	tagName       *string
	remark        *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NovelTag, error)
	predicates    []predicate.NovelTag
}

var _ ent.Mutation = (*NovelTagMutation)(nil)

// noveltagOption allows management of the mutation configuration using functional options.
type noveltagOption func(*NovelTagMutation)

// newNovelTagMutation creates new mutation for the NovelTag entity.
func newNovelTagMutation(c config, op Op, opts ...noveltagOption) *NovelTagMutation {
	m := &NovelTagMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelTagID sets the ID field of the mutation.
func withNovelTagID(id int64) noveltagOption {
	return func(m *NovelTagMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelTag
		)
		m.oldValue = func(ctx context.Context) (*NovelTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelTag sets the old NovelTag of the mutation.
func withNovelTag(node *NovelTag) noveltagOption {
	return func(m *NovelTagMutation) {
		m.oldValue = func(context.Context) (*NovelTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelTagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelTagMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagId sets the "tagId" field.
func (m *NovelTagMutation) SetTagId(i int64) {
	m.tagId = &i
	m.addtagId = nil
}

// TagId returns the value of the "tagId" field in the mutation.
func (m *NovelTagMutation) TagId() (r int64, exists bool) {
	v := m.tagId
	if v == nil {
		return
	}
	return *v, true
}

// OldTagId returns the old "tagId" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldTagId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagId: %w", err)
	}
	return oldValue.TagId, nil
}

// AddTagId adds i to the "tagId" field.
func (m *NovelTagMutation) AddTagId(i int64) {
	if m.addtagId != nil {
		*m.addtagId += i
	} else {
		m.addtagId = &i
	}
}

// AddedTagId returns the value that was added to the "tagId" field in this mutation.
func (m *NovelTagMutation) AddedTagId() (r int64, exists bool) {
	v := m.addtagId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagId resets all changes to the "tagId" field.
func (m *NovelTagMutation) ResetTagId() {
	m.tagId = nil
	m.addtagId = nil
}

// SetTagName sets the "tagName" field.
func (m *NovelTagMutation) SetTagName(s string) {
	m.tagName = &s
}

// TagName returns the value of the "tagName" field in the mutation.
func (m *NovelTagMutation) TagName() (r string, exists bool) {
	v := m.tagName
	if v == nil {
		return
	}
	return *v, true
}

// OldTagName returns the old "tagName" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldTagName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagName: %w", err)
	}
	return oldValue.TagName, nil
}

// ClearTagName clears the value of the "tagName" field.
func (m *NovelTagMutation) ClearTagName() {
	m.tagName = nil
	m.clearedFields[noveltag.FieldTagName] = struct{}{}
}

// TagNameCleared returns if the "tagName" field was cleared in this mutation.
func (m *NovelTagMutation) TagNameCleared() bool {
	_, ok := m.clearedFields[noveltag.FieldTagName]
	return ok
}

// ResetTagName resets all changes to the "tagName" field.
func (m *NovelTagMutation) ResetTagName() {
	m.tagName = nil
	delete(m.clearedFields, noveltag.FieldTagName)
}

// SetRemark sets the "remark" field.
func (m *NovelTagMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelTagMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelTagMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[noveltag.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelTagMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[noveltag.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelTagMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, noveltag.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelTagMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelTagMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelTagMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelTagMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelTagMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelTagMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelTagMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelTagMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelTagMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelTagMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelTagMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelTagMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelTagMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelTagMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelTagMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelTagMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelTag entity.
// If the NovelTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelTagMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelTagMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelTagMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelTagMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the NovelTagMutation builder.
func (m *NovelTagMutation) Where(ps ...predicate.NovelTag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelTagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelTag).
func (m *NovelTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelTagMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tagId != nil {
		fields = append(fields, noveltag.FieldTagId)
	}
	if m.tagName != nil {
		fields = append(fields, noveltag.FieldTagName)
	}
	if m.remark != nil {
		fields = append(fields, noveltag.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, noveltag.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, noveltag.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, noveltag.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, noveltag.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, noveltag.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case noveltag.FieldTagId:
		return m.TagId()
	case noveltag.FieldTagName:
		return m.TagName()
	case noveltag.FieldRemark:
		return m.Remark()
	case noveltag.FieldCreatedAt:
		return m.CreatedAt()
	case noveltag.FieldUpdatedAt:
		return m.UpdatedAt()
	case noveltag.FieldCreateBy:
		return m.CreateBy()
	case noveltag.FieldUpdateBy:
		return m.UpdateBy()
	case noveltag.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case noveltag.FieldTagId:
		return m.OldTagId(ctx)
	case noveltag.FieldTagName:
		return m.OldTagName(ctx)
	case noveltag.FieldRemark:
		return m.OldRemark(ctx)
	case noveltag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case noveltag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case noveltag.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case noveltag.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case noveltag.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case noveltag.FieldTagId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagId(v)
		return nil
	case noveltag.FieldTagName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagName(v)
		return nil
	case noveltag.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case noveltag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case noveltag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case noveltag.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case noveltag.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case noveltag.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelTagMutation) AddedFields() []string {
	var fields []string
	if m.addtagId != nil {
		fields = append(fields, noveltag.FieldTagId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, noveltag.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, noveltag.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, noveltag.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case noveltag.FieldTagId:
		return m.AddedTagId()
	case noveltag.FieldCreateBy:
		return m.AddedCreateBy()
	case noveltag.FieldUpdateBy:
		return m.AddedUpdateBy()
	case noveltag.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case noveltag.FieldTagId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTagId(v)
		return nil
	case noveltag.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case noveltag.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case noveltag.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(noveltag.FieldTagName) {
		fields = append(fields, noveltag.FieldTagName)
	}
	if m.FieldCleared(noveltag.FieldRemark) {
		fields = append(fields, noveltag.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelTagMutation) ClearField(name string) error {
	switch name {
	case noveltag.FieldTagName:
		m.ClearTagName()
		return nil
	case noveltag.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelTagMutation) ResetField(name string) error {
	switch name {
	case noveltag.FieldTagId:
		m.ResetTagId()
		return nil
	case noveltag.FieldTagName:
		m.ResetTagName()
		return nil
	case noveltag.FieldRemark:
		m.ResetRemark()
		return nil
	case noveltag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case noveltag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case noveltag.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case noveltag.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case noveltag.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelTagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelTagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelTagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NovelTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelTagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NovelTag edge %s", name)
}

// PageConfigMutation represents an operation that mutates the PageConfig nodes in the graph.
type PageConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	pageCode      *string
	pageName      *string
	groupCodes    *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PageConfig, error)
	predicates    []predicate.PageConfig
}

var _ ent.Mutation = (*PageConfigMutation)(nil)

// pageconfigOption allows management of the mutation configuration using functional options.
type pageconfigOption func(*PageConfigMutation)

// newPageConfigMutation creates new mutation for the PageConfig entity.
func newPageConfigMutation(c config, op Op, opts ...pageconfigOption) *PageConfigMutation {
	m := &PageConfigMutation{
		config:        c,
		op:            op,
		typ:           TypePageConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageConfigID sets the ID field of the mutation.
func withPageConfigID(id int64) pageconfigOption {
	return func(m *PageConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *PageConfig
		)
		m.oldValue = func(ctx context.Context) (*PageConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PageConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPageConfig sets the old PageConfig of the mutation.
func withPageConfig(node *PageConfig) pageconfigOption {
	return func(m *PageConfigMutation) {
		m.oldValue = func(context.Context) (*PageConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PageConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPageCode sets the "pageCode" field.
func (m *PageConfigMutation) SetPageCode(s string) {
	m.pageCode = &s
}

// PageCode returns the value of the "pageCode" field in the mutation.
func (m *PageConfigMutation) PageCode() (r string, exists bool) {
	v := m.pageCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPageCode returns the old "pageCode" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldPageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageCode: %w", err)
	}
	return oldValue.PageCode, nil
}

// ClearPageCode clears the value of the "pageCode" field.
func (m *PageConfigMutation) ClearPageCode() {
	m.pageCode = nil
	m.clearedFields[pageconfig.FieldPageCode] = struct{}{}
}

// PageCodeCleared returns if the "pageCode" field was cleared in this mutation.
func (m *PageConfigMutation) PageCodeCleared() bool {
	_, ok := m.clearedFields[pageconfig.FieldPageCode]
	return ok
}

// ResetPageCode resets all changes to the "pageCode" field.
func (m *PageConfigMutation) ResetPageCode() {
	m.pageCode = nil
	delete(m.clearedFields, pageconfig.FieldPageCode)
}

// SetPageName sets the "pageName" field.
func (m *PageConfigMutation) SetPageName(s string) {
	m.pageName = &s
}

// PageName returns the value of the "pageName" field in the mutation.
func (m *PageConfigMutation) PageName() (r string, exists bool) {
	v := m.pageName
	if v == nil {
		return
	}
	return *v, true
}

// OldPageName returns the old "pageName" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldPageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageName: %w", err)
	}
	return oldValue.PageName, nil
}

// ClearPageName clears the value of the "pageName" field.
func (m *PageConfigMutation) ClearPageName() {
	m.pageName = nil
	m.clearedFields[pageconfig.FieldPageName] = struct{}{}
}

// PageNameCleared returns if the "pageName" field was cleared in this mutation.
func (m *PageConfigMutation) PageNameCleared() bool {
	_, ok := m.clearedFields[pageconfig.FieldPageName]
	return ok
}

// ResetPageName resets all changes to the "pageName" field.
func (m *PageConfigMutation) ResetPageName() {
	m.pageName = nil
	delete(m.clearedFields, pageconfig.FieldPageName)
}

// SetGroupCodes sets the "groupCodes" field.
func (m *PageConfigMutation) SetGroupCodes(s string) {
	m.groupCodes = &s
}

// GroupCodes returns the value of the "groupCodes" field in the mutation.
func (m *PageConfigMutation) GroupCodes() (r string, exists bool) {
	v := m.groupCodes
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupCodes returns the old "groupCodes" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldGroupCodes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupCodes: %w", err)
	}
	return oldValue.GroupCodes, nil
}

// ClearGroupCodes clears the value of the "groupCodes" field.
func (m *PageConfigMutation) ClearGroupCodes() {
	m.groupCodes = nil
	m.clearedFields[pageconfig.FieldGroupCodes] = struct{}{}
}

// GroupCodesCleared returns if the "groupCodes" field was cleared in this mutation.
func (m *PageConfigMutation) GroupCodesCleared() bool {
	_, ok := m.clearedFields[pageconfig.FieldGroupCodes]
	return ok
}

// ResetGroupCodes resets all changes to the "groupCodes" field.
func (m *PageConfigMutation) ResetGroupCodes() {
	m.groupCodes = nil
	delete(m.clearedFields, pageconfig.FieldGroupCodes)
}

// SetCreatedAt sets the "createdAt" field.
func (m *PageConfigMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *PageConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *PageConfigMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *PageConfigMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *PageConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *PageConfigMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *PageConfigMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *PageConfigMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *PageConfigMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *PageConfigMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *PageConfigMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *PageConfigMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *PageConfigMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *PageConfigMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *PageConfigMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *PageConfigMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *PageConfigMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *PageConfigMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the PageConfig entity.
// If the PageConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageConfigMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *PageConfigMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *PageConfigMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *PageConfigMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the PageConfigMutation builder.
func (m *PageConfigMutation) Where(ps ...predicate.PageConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PageConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PageConfig).
func (m *PageConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageConfigMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.pageCode != nil {
		fields = append(fields, pageconfig.FieldPageCode)
	}
	if m.pageName != nil {
		fields = append(fields, pageconfig.FieldPageName)
	}
	if m.groupCodes != nil {
		fields = append(fields, pageconfig.FieldGroupCodes)
	}
	if m.createdAt != nil {
		fields = append(fields, pageconfig.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, pageconfig.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, pageconfig.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, pageconfig.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, pageconfig.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pageconfig.FieldPageCode:
		return m.PageCode()
	case pageconfig.FieldPageName:
		return m.PageName()
	case pageconfig.FieldGroupCodes:
		return m.GroupCodes()
	case pageconfig.FieldCreatedAt:
		return m.CreatedAt()
	case pageconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case pageconfig.FieldCreateBy:
		return m.CreateBy()
	case pageconfig.FieldUpdateBy:
		return m.UpdateBy()
	case pageconfig.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pageconfig.FieldPageCode:
		return m.OldPageCode(ctx)
	case pageconfig.FieldPageName:
		return m.OldPageName(ctx)
	case pageconfig.FieldGroupCodes:
		return m.OldGroupCodes(ctx)
	case pageconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pageconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pageconfig.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case pageconfig.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case pageconfig.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown PageConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pageconfig.FieldPageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageCode(v)
		return nil
	case pageconfig.FieldPageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageName(v)
		return nil
	case pageconfig.FieldGroupCodes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupCodes(v)
		return nil
	case pageconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pageconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pageconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case pageconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case pageconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown PageConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreateBy != nil {
		fields = append(fields, pageconfig.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, pageconfig.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, pageconfig.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pageconfig.FieldCreateBy:
		return m.AddedCreateBy()
	case pageconfig.FieldUpdateBy:
		return m.AddedUpdateBy()
	case pageconfig.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pageconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case pageconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case pageconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown PageConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pageconfig.FieldPageCode) {
		fields = append(fields, pageconfig.FieldPageCode)
	}
	if m.FieldCleared(pageconfig.FieldPageName) {
		fields = append(fields, pageconfig.FieldPageName)
	}
	if m.FieldCleared(pageconfig.FieldGroupCodes) {
		fields = append(fields, pageconfig.FieldGroupCodes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageConfigMutation) ClearField(name string) error {
	switch name {
	case pageconfig.FieldPageCode:
		m.ClearPageCode()
		return nil
	case pageconfig.FieldPageName:
		m.ClearPageName()
		return nil
	case pageconfig.FieldGroupCodes:
		m.ClearGroupCodes()
		return nil
	}
	return fmt.Errorf("unknown PageConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageConfigMutation) ResetField(name string) error {
	switch name {
	case pageconfig.FieldPageCode:
		m.ResetPageCode()
		return nil
	case pageconfig.FieldPageName:
		m.ResetPageName()
		return nil
	case pageconfig.FieldGroupCodes:
		m.ResetGroupCodes()
		return nil
	case pageconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pageconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pageconfig.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case pageconfig.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case pageconfig.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown PageConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PageConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PageConfig edge %s", name)
}

// QiniuConfigMutation represents an operation that mutates the QiniuConfig nodes in the graph.
type QiniuConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	accessKey     *string
	bucket        *string
	host          *string
	secretKey     *string
	_type         *string
	zone          *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*QiniuConfig, error)
	predicates    []predicate.QiniuConfig
}

var _ ent.Mutation = (*QiniuConfigMutation)(nil)

// qiniuconfigOption allows management of the mutation configuration using functional options.
type qiniuconfigOption func(*QiniuConfigMutation)

// newQiniuConfigMutation creates new mutation for the QiniuConfig entity.
func newQiniuConfigMutation(c config, op Op, opts ...qiniuconfigOption) *QiniuConfigMutation {
	m := &QiniuConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeQiniuConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQiniuConfigID sets the ID field of the mutation.
func withQiniuConfigID(id int64) qiniuconfigOption {
	return func(m *QiniuConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *QiniuConfig
		)
		m.oldValue = func(ctx context.Context) (*QiniuConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QiniuConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQiniuConfig sets the old QiniuConfig of the mutation.
func withQiniuConfig(node *QiniuConfig) qiniuconfigOption {
	return func(m *QiniuConfigMutation) {
		m.oldValue = func(context.Context) (*QiniuConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QiniuConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QiniuConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QiniuConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QiniuConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QiniuConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccessKey sets the "accessKey" field.
func (m *QiniuConfigMutation) SetAccessKey(s string) {
	m.accessKey = &s
}

// AccessKey returns the value of the "accessKey" field in the mutation.
func (m *QiniuConfigMutation) AccessKey() (r string, exists bool) {
	v := m.accessKey
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "accessKey" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldAccessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ClearAccessKey clears the value of the "accessKey" field.
func (m *QiniuConfigMutation) ClearAccessKey() {
	m.accessKey = nil
	m.clearedFields[qiniuconfig.FieldAccessKey] = struct{}{}
}

// AccessKeyCleared returns if the "accessKey" field was cleared in this mutation.
func (m *QiniuConfigMutation) AccessKeyCleared() bool {
	_, ok := m.clearedFields[qiniuconfig.FieldAccessKey]
	return ok
}

// ResetAccessKey resets all changes to the "accessKey" field.
func (m *QiniuConfigMutation) ResetAccessKey() {
	m.accessKey = nil
	delete(m.clearedFields, qiniuconfig.FieldAccessKey)
}

// SetBucket sets the "bucket" field.
func (m *QiniuConfigMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *QiniuConfigMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ClearBucket clears the value of the "bucket" field.
func (m *QiniuConfigMutation) ClearBucket() {
	m.bucket = nil
	m.clearedFields[qiniuconfig.FieldBucket] = struct{}{}
}

// BucketCleared returns if the "bucket" field was cleared in this mutation.
func (m *QiniuConfigMutation) BucketCleared() bool {
	_, ok := m.clearedFields[qiniuconfig.FieldBucket]
	return ok
}

// ResetBucket resets all changes to the "bucket" field.
func (m *QiniuConfigMutation) ResetBucket() {
	m.bucket = nil
	delete(m.clearedFields, qiniuconfig.FieldBucket)
}

// SetHost sets the "host" field.
func (m *QiniuConfigMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *QiniuConfigMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *QiniuConfigMutation) ClearHost() {
	m.host = nil
	m.clearedFields[qiniuconfig.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *QiniuConfigMutation) HostCleared() bool {
	_, ok := m.clearedFields[qiniuconfig.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *QiniuConfigMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, qiniuconfig.FieldHost)
}

// SetSecretKey sets the "secretKey" field.
func (m *QiniuConfigMutation) SetSecretKey(s string) {
	m.secretKey = &s
}

// SecretKey returns the value of the "secretKey" field in the mutation.
func (m *QiniuConfigMutation) SecretKey() (r string, exists bool) {
	v := m.secretKey
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secretKey" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "secretKey" field.
func (m *QiniuConfigMutation) ClearSecretKey() {
	m.secretKey = nil
	m.clearedFields[qiniuconfig.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "secretKey" field was cleared in this mutation.
func (m *QiniuConfigMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[qiniuconfig.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "secretKey" field.
func (m *QiniuConfigMutation) ResetSecretKey() {
	m.secretKey = nil
	delete(m.clearedFields, qiniuconfig.FieldSecretKey)
}

// SetType sets the "type" field.
func (m *QiniuConfigMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *QiniuConfigMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *QiniuConfigMutation) ClearType() {
	m._type = nil
	m.clearedFields[qiniuconfig.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *QiniuConfigMutation) TypeCleared() bool {
	_, ok := m.clearedFields[qiniuconfig.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *QiniuConfigMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, qiniuconfig.FieldType)
}

// SetZone sets the "zone" field.
func (m *QiniuConfigMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the value of the "zone" field in the mutation.
func (m *QiniuConfigMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old "zone" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ClearZone clears the value of the "zone" field.
func (m *QiniuConfigMutation) ClearZone() {
	m.zone = nil
	m.clearedFields[qiniuconfig.FieldZone] = struct{}{}
}

// ZoneCleared returns if the "zone" field was cleared in this mutation.
func (m *QiniuConfigMutation) ZoneCleared() bool {
	_, ok := m.clearedFields[qiniuconfig.FieldZone]
	return ok
}

// ResetZone resets all changes to the "zone" field.
func (m *QiniuConfigMutation) ResetZone() {
	m.zone = nil
	delete(m.clearedFields, qiniuconfig.FieldZone)
}

// SetCreatedAt sets the "createdAt" field.
func (m *QiniuConfigMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *QiniuConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *QiniuConfigMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *QiniuConfigMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *QiniuConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *QiniuConfigMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *QiniuConfigMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *QiniuConfigMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *QiniuConfigMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *QiniuConfigMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *QiniuConfigMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *QiniuConfigMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *QiniuConfigMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *QiniuConfigMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *QiniuConfigMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *QiniuConfigMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *QiniuConfigMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *QiniuConfigMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the QiniuConfig entity.
// If the QiniuConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QiniuConfigMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *QiniuConfigMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *QiniuConfigMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *QiniuConfigMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the QiniuConfigMutation builder.
func (m *QiniuConfigMutation) Where(ps ...predicate.QiniuConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *QiniuConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (QiniuConfig).
func (m *QiniuConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QiniuConfigMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.accessKey != nil {
		fields = append(fields, qiniuconfig.FieldAccessKey)
	}
	if m.bucket != nil {
		fields = append(fields, qiniuconfig.FieldBucket)
	}
	if m.host != nil {
		fields = append(fields, qiniuconfig.FieldHost)
	}
	if m.secretKey != nil {
		fields = append(fields, qiniuconfig.FieldSecretKey)
	}
	if m._type != nil {
		fields = append(fields, qiniuconfig.FieldType)
	}
	if m.zone != nil {
		fields = append(fields, qiniuconfig.FieldZone)
	}
	if m.createdAt != nil {
		fields = append(fields, qiniuconfig.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, qiniuconfig.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, qiniuconfig.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, qiniuconfig.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, qiniuconfig.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QiniuConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case qiniuconfig.FieldAccessKey:
		return m.AccessKey()
	case qiniuconfig.FieldBucket:
		return m.Bucket()
	case qiniuconfig.FieldHost:
		return m.Host()
	case qiniuconfig.FieldSecretKey:
		return m.SecretKey()
	case qiniuconfig.FieldType:
		return m.GetType()
	case qiniuconfig.FieldZone:
		return m.Zone()
	case qiniuconfig.FieldCreatedAt:
		return m.CreatedAt()
	case qiniuconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case qiniuconfig.FieldCreateBy:
		return m.CreateBy()
	case qiniuconfig.FieldUpdateBy:
		return m.UpdateBy()
	case qiniuconfig.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QiniuConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case qiniuconfig.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case qiniuconfig.FieldBucket:
		return m.OldBucket(ctx)
	case qiniuconfig.FieldHost:
		return m.OldHost(ctx)
	case qiniuconfig.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case qiniuconfig.FieldType:
		return m.OldType(ctx)
	case qiniuconfig.FieldZone:
		return m.OldZone(ctx)
	case qiniuconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case qiniuconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case qiniuconfig.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case qiniuconfig.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case qiniuconfig.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown QiniuConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QiniuConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case qiniuconfig.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case qiniuconfig.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	case qiniuconfig.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case qiniuconfig.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case qiniuconfig.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case qiniuconfig.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	case qiniuconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case qiniuconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case qiniuconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case qiniuconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case qiniuconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown QiniuConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QiniuConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcreateBy != nil {
		fields = append(fields, qiniuconfig.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, qiniuconfig.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, qiniuconfig.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QiniuConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case qiniuconfig.FieldCreateBy:
		return m.AddedCreateBy()
	case qiniuconfig.FieldUpdateBy:
		return m.AddedUpdateBy()
	case qiniuconfig.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QiniuConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case qiniuconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case qiniuconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case qiniuconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown QiniuConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QiniuConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(qiniuconfig.FieldAccessKey) {
		fields = append(fields, qiniuconfig.FieldAccessKey)
	}
	if m.FieldCleared(qiniuconfig.FieldBucket) {
		fields = append(fields, qiniuconfig.FieldBucket)
	}
	if m.FieldCleared(qiniuconfig.FieldHost) {
		fields = append(fields, qiniuconfig.FieldHost)
	}
	if m.FieldCleared(qiniuconfig.FieldSecretKey) {
		fields = append(fields, qiniuconfig.FieldSecretKey)
	}
	if m.FieldCleared(qiniuconfig.FieldType) {
		fields = append(fields, qiniuconfig.FieldType)
	}
	if m.FieldCleared(qiniuconfig.FieldZone) {
		fields = append(fields, qiniuconfig.FieldZone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QiniuConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QiniuConfigMutation) ClearField(name string) error {
	switch name {
	case qiniuconfig.FieldAccessKey:
		m.ClearAccessKey()
		return nil
	case qiniuconfig.FieldBucket:
		m.ClearBucket()
		return nil
	case qiniuconfig.FieldHost:
		m.ClearHost()
		return nil
	case qiniuconfig.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	case qiniuconfig.FieldType:
		m.ClearType()
		return nil
	case qiniuconfig.FieldZone:
		m.ClearZone()
		return nil
	}
	return fmt.Errorf("unknown QiniuConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QiniuConfigMutation) ResetField(name string) error {
	switch name {
	case qiniuconfig.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case qiniuconfig.FieldBucket:
		m.ResetBucket()
		return nil
	case qiniuconfig.FieldHost:
		m.ResetHost()
		return nil
	case qiniuconfig.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case qiniuconfig.FieldType:
		m.ResetType()
		return nil
	case qiniuconfig.FieldZone:
		m.ResetZone()
		return nil
	case qiniuconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case qiniuconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case qiniuconfig.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case qiniuconfig.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case qiniuconfig.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown QiniuConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QiniuConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QiniuConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QiniuConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QiniuConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QiniuConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QiniuConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QiniuConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown QiniuConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QiniuConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown QiniuConfig edge %s", name)
}

// ResourceGroupMutation represents an operation that mutates the ResourceGroup nodes in the graph.
type ResourceGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ResourceGroup, error)
	predicates    []predicate.ResourceGroup
}

var _ ent.Mutation = (*ResourceGroupMutation)(nil)

// resourcegroupOption allows management of the mutation configuration using functional options.
type resourcegroupOption func(*ResourceGroupMutation)

// newResourceGroupMutation creates new mutation for the ResourceGroup entity.
func newResourceGroupMutation(c config, op Op, opts ...resourcegroupOption) *ResourceGroupMutation {
	m := &ResourceGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceGroupID sets the ID field of the mutation.
func withResourceGroupID(id int64) resourcegroupOption {
	return func(m *ResourceGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceGroup
		)
		m.oldValue = func(ctx context.Context) (*ResourceGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceGroup sets the old ResourceGroup of the mutation.
func withResourceGroup(node *ResourceGroup) resourcegroupOption {
	return func(m *ResourceGroupMutation) {
		m.oldValue = func(context.Context) (*ResourceGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceGroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceGroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ResourceGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResourceGroup entity.
// If the ResourceGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ResourceGroupMutation) ClearName() {
	m.name = nil
	m.clearedFields[resourcegroup.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ResourceGroupMutation) NameCleared() bool {
	_, ok := m.clearedFields[resourcegroup.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ResourceGroupMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, resourcegroup.FieldName)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ResourceGroupMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ResourceGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ResourceGroup entity.
// If the ResourceGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ResourceGroupMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ResourceGroupMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ResourceGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ResourceGroup entity.
// If the ResourceGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ResourceGroupMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ResourceGroupMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ResourceGroupMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the ResourceGroup entity.
// If the ResourceGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceGroupMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ResourceGroupMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ResourceGroupMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ResourceGroupMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ResourceGroupMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ResourceGroupMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the ResourceGroup entity.
// If the ResourceGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceGroupMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ResourceGroupMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ResourceGroupMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ResourceGroupMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ResourceGroupMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ResourceGroupMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the ResourceGroup entity.
// If the ResourceGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceGroupMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ResourceGroupMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ResourceGroupMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ResourceGroupMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the ResourceGroupMutation builder.
func (m *ResourceGroupMutation) Where(ps ...predicate.ResourceGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ResourceGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResourceGroup).
func (m *ResourceGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceGroupMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, resourcegroup.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, resourcegroup.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, resourcegroup.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, resourcegroup.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, resourcegroup.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, resourcegroup.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcegroup.FieldName:
		return m.Name()
	case resourcegroup.FieldCreatedAt:
		return m.CreatedAt()
	case resourcegroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case resourcegroup.FieldCreateBy:
		return m.CreateBy()
	case resourcegroup.FieldUpdateBy:
		return m.UpdateBy()
	case resourcegroup.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcegroup.FieldName:
		return m.OldName(ctx)
	case resourcegroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resourcegroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resourcegroup.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case resourcegroup.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case resourcegroup.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcegroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resourcegroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resourcegroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resourcegroup.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case resourcegroup.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case resourcegroup.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcreateBy != nil {
		fields = append(fields, resourcegroup.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, resourcegroup.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, resourcegroup.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourcegroup.FieldCreateBy:
		return m.AddedCreateBy()
	case resourcegroup.FieldUpdateBy:
		return m.AddedUpdateBy()
	case resourcegroup.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourcegroup.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case resourcegroup.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case resourcegroup.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcegroup.FieldName) {
		fields = append(fields, resourcegroup.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceGroupMutation) ClearField(name string) error {
	switch name {
	case resourcegroup.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown ResourceGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceGroupMutation) ResetField(name string) error {
	switch name {
	case resourcegroup.FieldName:
		m.ResetName()
		return nil
	case resourcegroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resourcegroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resourcegroup.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case resourcegroup.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case resourcegroup.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown ResourceGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResourceGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResourceGroup edge %s", name)
}

// ResourceStorageMutation represents an operation that mutates the ResourceStorage nodes in the graph.
type ResourceStorageMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	groupId        *int32
	addgroupId     *int32
	storageType    *int32
	addstorageType *int32
	realName       *string
	bucket         *string
	name           *string
	suffix         *string
	_path          *string
	_type          *string
	size           *string
	deleteUrl      *string
	filename       *string
	key            *string
	height         *string
	url            *string
	username       *string
	width          *string
	md5code        *string
	remark         *string
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ResourceStorage, error)
	predicates     []predicate.ResourceStorage
}

var _ ent.Mutation = (*ResourceStorageMutation)(nil)

// resourcestorageOption allows management of the mutation configuration using functional options.
type resourcestorageOption func(*ResourceStorageMutation)

// newResourceStorageMutation creates new mutation for the ResourceStorage entity.
func newResourceStorageMutation(c config, op Op, opts ...resourcestorageOption) *ResourceStorageMutation {
	m := &ResourceStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceStorageID sets the ID field of the mutation.
func withResourceStorageID(id int64) resourcestorageOption {
	return func(m *ResourceStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceStorage
		)
		m.oldValue = func(ctx context.Context) (*ResourceStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceStorage sets the old ResourceStorage of the mutation.
func withResourceStorage(node *ResourceStorage) resourcestorageOption {
	return func(m *ResourceStorageMutation) {
		m.oldValue = func(context.Context) (*ResourceStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceStorageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceStorageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupId sets the "groupId" field.
func (m *ResourceStorageMutation) SetGroupId(i int32) {
	m.groupId = &i
	m.addgroupId = nil
}

// GroupId returns the value of the "groupId" field in the mutation.
func (m *ResourceStorageMutation) GroupId() (r int32, exists bool) {
	v := m.groupId
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupId returns the old "groupId" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldGroupId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupId: %w", err)
	}
	return oldValue.GroupId, nil
}

// AddGroupId adds i to the "groupId" field.
func (m *ResourceStorageMutation) AddGroupId(i int32) {
	if m.addgroupId != nil {
		*m.addgroupId += i
	} else {
		m.addgroupId = &i
	}
}

// AddedGroupId returns the value that was added to the "groupId" field in this mutation.
func (m *ResourceStorageMutation) AddedGroupId() (r int32, exists bool) {
	v := m.addgroupId
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupId clears the value of the "groupId" field.
func (m *ResourceStorageMutation) ClearGroupId() {
	m.groupId = nil
	m.addgroupId = nil
	m.clearedFields[resourcestorage.FieldGroupId] = struct{}{}
}

// GroupIdCleared returns if the "groupId" field was cleared in this mutation.
func (m *ResourceStorageMutation) GroupIdCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldGroupId]
	return ok
}

// ResetGroupId resets all changes to the "groupId" field.
func (m *ResourceStorageMutation) ResetGroupId() {
	m.groupId = nil
	m.addgroupId = nil
	delete(m.clearedFields, resourcestorage.FieldGroupId)
}

// SetStorageType sets the "storageType" field.
func (m *ResourceStorageMutation) SetStorageType(i int32) {
	m.storageType = &i
	m.addstorageType = nil
}

// StorageType returns the value of the "storageType" field in the mutation.
func (m *ResourceStorageMutation) StorageType() (r int32, exists bool) {
	v := m.storageType
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storageType" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldStorageType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// AddStorageType adds i to the "storageType" field.
func (m *ResourceStorageMutation) AddStorageType(i int32) {
	if m.addstorageType != nil {
		*m.addstorageType += i
	} else {
		m.addstorageType = &i
	}
}

// AddedStorageType returns the value that was added to the "storageType" field in this mutation.
func (m *ResourceStorageMutation) AddedStorageType() (r int32, exists bool) {
	v := m.addstorageType
	if v == nil {
		return
	}
	return *v, true
}

// ClearStorageType clears the value of the "storageType" field.
func (m *ResourceStorageMutation) ClearStorageType() {
	m.storageType = nil
	m.addstorageType = nil
	m.clearedFields[resourcestorage.FieldStorageType] = struct{}{}
}

// StorageTypeCleared returns if the "storageType" field was cleared in this mutation.
func (m *ResourceStorageMutation) StorageTypeCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldStorageType]
	return ok
}

// ResetStorageType resets all changes to the "storageType" field.
func (m *ResourceStorageMutation) ResetStorageType() {
	m.storageType = nil
	m.addstorageType = nil
	delete(m.clearedFields, resourcestorage.FieldStorageType)
}

// SetRealName sets the "realName" field.
func (m *ResourceStorageMutation) SetRealName(s string) {
	m.realName = &s
}

// RealName returns the value of the "realName" field in the mutation.
func (m *ResourceStorageMutation) RealName() (r string, exists bool) {
	v := m.realName
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "realName" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ClearRealName clears the value of the "realName" field.
func (m *ResourceStorageMutation) ClearRealName() {
	m.realName = nil
	m.clearedFields[resourcestorage.FieldRealName] = struct{}{}
}

// RealNameCleared returns if the "realName" field was cleared in this mutation.
func (m *ResourceStorageMutation) RealNameCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldRealName]
	return ok
}

// ResetRealName resets all changes to the "realName" field.
func (m *ResourceStorageMutation) ResetRealName() {
	m.realName = nil
	delete(m.clearedFields, resourcestorage.FieldRealName)
}

// SetBucket sets the "bucket" field.
func (m *ResourceStorageMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *ResourceStorageMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ClearBucket clears the value of the "bucket" field.
func (m *ResourceStorageMutation) ClearBucket() {
	m.bucket = nil
	m.clearedFields[resourcestorage.FieldBucket] = struct{}{}
}

// BucketCleared returns if the "bucket" field was cleared in this mutation.
func (m *ResourceStorageMutation) BucketCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldBucket]
	return ok
}

// ResetBucket resets all changes to the "bucket" field.
func (m *ResourceStorageMutation) ResetBucket() {
	m.bucket = nil
	delete(m.clearedFields, resourcestorage.FieldBucket)
}

// SetName sets the "name" field.
func (m *ResourceStorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceStorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ResourceStorageMutation) ClearName() {
	m.name = nil
	m.clearedFields[resourcestorage.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ResourceStorageMutation) NameCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ResourceStorageMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, resourcestorage.FieldName)
}

// SetSuffix sets the "suffix" field.
func (m *ResourceStorageMutation) SetSuffix(s string) {
	m.suffix = &s
}

// Suffix returns the value of the "suffix" field in the mutation.
func (m *ResourceStorageMutation) Suffix() (r string, exists bool) {
	v := m.suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldSuffix returns the old "suffix" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuffix: %w", err)
	}
	return oldValue.Suffix, nil
}

// ClearSuffix clears the value of the "suffix" field.
func (m *ResourceStorageMutation) ClearSuffix() {
	m.suffix = nil
	m.clearedFields[resourcestorage.FieldSuffix] = struct{}{}
}

// SuffixCleared returns if the "suffix" field was cleared in this mutation.
func (m *ResourceStorageMutation) SuffixCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldSuffix]
	return ok
}

// ResetSuffix resets all changes to the "suffix" field.
func (m *ResourceStorageMutation) ResetSuffix() {
	m.suffix = nil
	delete(m.clearedFields, resourcestorage.FieldSuffix)
}

// SetPath sets the "path" field.
func (m *ResourceStorageMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ResourceStorageMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ResourceStorageMutation) ClearPath() {
	m._path = nil
	m.clearedFields[resourcestorage.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ResourceStorageMutation) PathCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ResourceStorageMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, resourcestorage.FieldPath)
}

// SetType sets the "type" field.
func (m *ResourceStorageMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceStorageMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ResourceStorageMutation) ClearType() {
	m._type = nil
	m.clearedFields[resourcestorage.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ResourceStorageMutation) TypeCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ResourceStorageMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, resourcestorage.FieldType)
}

// SetSize sets the "size" field.
func (m *ResourceStorageMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *ResourceStorageMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *ResourceStorageMutation) ClearSize() {
	m.size = nil
	m.clearedFields[resourcestorage.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *ResourceStorageMutation) SizeCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *ResourceStorageMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, resourcestorage.FieldSize)
}

// SetDeleteUrl sets the "deleteUrl" field.
func (m *ResourceStorageMutation) SetDeleteUrl(s string) {
	m.deleteUrl = &s
}

// DeleteUrl returns the value of the "deleteUrl" field in the mutation.
func (m *ResourceStorageMutation) DeleteUrl() (r string, exists bool) {
	v := m.deleteUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteUrl returns the old "deleteUrl" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldDeleteUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteUrl: %w", err)
	}
	return oldValue.DeleteUrl, nil
}

// ClearDeleteUrl clears the value of the "deleteUrl" field.
func (m *ResourceStorageMutation) ClearDeleteUrl() {
	m.deleteUrl = nil
	m.clearedFields[resourcestorage.FieldDeleteUrl] = struct{}{}
}

// DeleteUrlCleared returns if the "deleteUrl" field was cleared in this mutation.
func (m *ResourceStorageMutation) DeleteUrlCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldDeleteUrl]
	return ok
}

// ResetDeleteUrl resets all changes to the "deleteUrl" field.
func (m *ResourceStorageMutation) ResetDeleteUrl() {
	m.deleteUrl = nil
	delete(m.clearedFields, resourcestorage.FieldDeleteUrl)
}

// SetFilename sets the "filename" field.
func (m *ResourceStorageMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *ResourceStorageMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ClearFilename clears the value of the "filename" field.
func (m *ResourceStorageMutation) ClearFilename() {
	m.filename = nil
	m.clearedFields[resourcestorage.FieldFilename] = struct{}{}
}

// FilenameCleared returns if the "filename" field was cleared in this mutation.
func (m *ResourceStorageMutation) FilenameCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldFilename]
	return ok
}

// ResetFilename resets all changes to the "filename" field.
func (m *ResourceStorageMutation) ResetFilename() {
	m.filename = nil
	delete(m.clearedFields, resourcestorage.FieldFilename)
}

// SetKey sets the "key" field.
func (m *ResourceStorageMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ResourceStorageMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *ResourceStorageMutation) ClearKey() {
	m.key = nil
	m.clearedFields[resourcestorage.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *ResourceStorageMutation) KeyCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *ResourceStorageMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, resourcestorage.FieldKey)
}

// SetHeight sets the "height" field.
func (m *ResourceStorageMutation) SetHeight(s string) {
	m.height = &s
}

// Height returns the value of the "height" field in the mutation.
func (m *ResourceStorageMutation) Height() (r string, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// ClearHeight clears the value of the "height" field.
func (m *ResourceStorageMutation) ClearHeight() {
	m.height = nil
	m.clearedFields[resourcestorage.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *ResourceStorageMutation) HeightCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *ResourceStorageMutation) ResetHeight() {
	m.height = nil
	delete(m.clearedFields, resourcestorage.FieldHeight)
}

// SetURL sets the "url" field.
func (m *ResourceStorageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ResourceStorageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ResourceStorageMutation) ClearURL() {
	m.url = nil
	m.clearedFields[resourcestorage.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ResourceStorageMutation) URLCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ResourceStorageMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, resourcestorage.FieldURL)
}

// SetUsername sets the "username" field.
func (m *ResourceStorageMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ResourceStorageMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ResourceStorageMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[resourcestorage.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ResourceStorageMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ResourceStorageMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, resourcestorage.FieldUsername)
}

// SetWidth sets the "width" field.
func (m *ResourceStorageMutation) SetWidth(s string) {
	m.width = &s
}

// Width returns the value of the "width" field in the mutation.
func (m *ResourceStorageMutation) Width() (r string, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldWidth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// ClearWidth clears the value of the "width" field.
func (m *ResourceStorageMutation) ClearWidth() {
	m.width = nil
	m.clearedFields[resourcestorage.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *ResourceStorageMutation) WidthCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *ResourceStorageMutation) ResetWidth() {
	m.width = nil
	delete(m.clearedFields, resourcestorage.FieldWidth)
}

// SetMd5code sets the "md5code" field.
func (m *ResourceStorageMutation) SetMd5code(s string) {
	m.md5code = &s
}

// Md5code returns the value of the "md5code" field in the mutation.
func (m *ResourceStorageMutation) Md5code() (r string, exists bool) {
	v := m.md5code
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5code returns the old "md5code" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldMd5code(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5code is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5code requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5code: %w", err)
	}
	return oldValue.Md5code, nil
}

// ClearMd5code clears the value of the "md5code" field.
func (m *ResourceStorageMutation) ClearMd5code() {
	m.md5code = nil
	m.clearedFields[resourcestorage.FieldMd5code] = struct{}{}
}

// Md5codeCleared returns if the "md5code" field was cleared in this mutation.
func (m *ResourceStorageMutation) Md5codeCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldMd5code]
	return ok
}

// ResetMd5code resets all changes to the "md5code" field.
func (m *ResourceStorageMutation) ResetMd5code() {
	m.md5code = nil
	delete(m.clearedFields, resourcestorage.FieldMd5code)
}

// SetRemark sets the "remark" field.
func (m *ResourceStorageMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ResourceStorageMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ResourceStorageMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[resourcestorage.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ResourceStorageMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[resourcestorage.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ResourceStorageMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, resourcestorage.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ResourceStorageMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ResourceStorageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ResourceStorageMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ResourceStorageMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ResourceStorageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ResourceStorageMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ResourceStorageMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ResourceStorageMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ResourceStorageMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ResourceStorageMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ResourceStorageMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ResourceStorageMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ResourceStorageMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ResourceStorageMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ResourceStorageMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ResourceStorageMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ResourceStorageMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ResourceStorageMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the ResourceStorage entity.
// If the ResourceStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceStorageMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ResourceStorageMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ResourceStorageMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ResourceStorageMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the ResourceStorageMutation builder.
func (m *ResourceStorageMutation) Where(ps ...predicate.ResourceStorage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ResourceStorageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResourceStorage).
func (m *ResourceStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceStorageMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.groupId != nil {
		fields = append(fields, resourcestorage.FieldGroupId)
	}
	if m.storageType != nil {
		fields = append(fields, resourcestorage.FieldStorageType)
	}
	if m.realName != nil {
		fields = append(fields, resourcestorage.FieldRealName)
	}
	if m.bucket != nil {
		fields = append(fields, resourcestorage.FieldBucket)
	}
	if m.name != nil {
		fields = append(fields, resourcestorage.FieldName)
	}
	if m.suffix != nil {
		fields = append(fields, resourcestorage.FieldSuffix)
	}
	if m._path != nil {
		fields = append(fields, resourcestorage.FieldPath)
	}
	if m._type != nil {
		fields = append(fields, resourcestorage.FieldType)
	}
	if m.size != nil {
		fields = append(fields, resourcestorage.FieldSize)
	}
	if m.deleteUrl != nil {
		fields = append(fields, resourcestorage.FieldDeleteUrl)
	}
	if m.filename != nil {
		fields = append(fields, resourcestorage.FieldFilename)
	}
	if m.key != nil {
		fields = append(fields, resourcestorage.FieldKey)
	}
	if m.height != nil {
		fields = append(fields, resourcestorage.FieldHeight)
	}
	if m.url != nil {
		fields = append(fields, resourcestorage.FieldURL)
	}
	if m.username != nil {
		fields = append(fields, resourcestorage.FieldUsername)
	}
	if m.width != nil {
		fields = append(fields, resourcestorage.FieldWidth)
	}
	if m.md5code != nil {
		fields = append(fields, resourcestorage.FieldMd5code)
	}
	if m.remark != nil {
		fields = append(fields, resourcestorage.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, resourcestorage.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, resourcestorage.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, resourcestorage.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, resourcestorage.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, resourcestorage.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcestorage.FieldGroupId:
		return m.GroupId()
	case resourcestorage.FieldStorageType:
		return m.StorageType()
	case resourcestorage.FieldRealName:
		return m.RealName()
	case resourcestorage.FieldBucket:
		return m.Bucket()
	case resourcestorage.FieldName:
		return m.Name()
	case resourcestorage.FieldSuffix:
		return m.Suffix()
	case resourcestorage.FieldPath:
		return m.Path()
	case resourcestorage.FieldType:
		return m.GetType()
	case resourcestorage.FieldSize:
		return m.Size()
	case resourcestorage.FieldDeleteUrl:
		return m.DeleteUrl()
	case resourcestorage.FieldFilename:
		return m.Filename()
	case resourcestorage.FieldKey:
		return m.Key()
	case resourcestorage.FieldHeight:
		return m.Height()
	case resourcestorage.FieldURL:
		return m.URL()
	case resourcestorage.FieldUsername:
		return m.Username()
	case resourcestorage.FieldWidth:
		return m.Width()
	case resourcestorage.FieldMd5code:
		return m.Md5code()
	case resourcestorage.FieldRemark:
		return m.Remark()
	case resourcestorage.FieldCreatedAt:
		return m.CreatedAt()
	case resourcestorage.FieldUpdatedAt:
		return m.UpdatedAt()
	case resourcestorage.FieldCreateBy:
		return m.CreateBy()
	case resourcestorage.FieldUpdateBy:
		return m.UpdateBy()
	case resourcestorage.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcestorage.FieldGroupId:
		return m.OldGroupId(ctx)
	case resourcestorage.FieldStorageType:
		return m.OldStorageType(ctx)
	case resourcestorage.FieldRealName:
		return m.OldRealName(ctx)
	case resourcestorage.FieldBucket:
		return m.OldBucket(ctx)
	case resourcestorage.FieldName:
		return m.OldName(ctx)
	case resourcestorage.FieldSuffix:
		return m.OldSuffix(ctx)
	case resourcestorage.FieldPath:
		return m.OldPath(ctx)
	case resourcestorage.FieldType:
		return m.OldType(ctx)
	case resourcestorage.FieldSize:
		return m.OldSize(ctx)
	case resourcestorage.FieldDeleteUrl:
		return m.OldDeleteUrl(ctx)
	case resourcestorage.FieldFilename:
		return m.OldFilename(ctx)
	case resourcestorage.FieldKey:
		return m.OldKey(ctx)
	case resourcestorage.FieldHeight:
		return m.OldHeight(ctx)
	case resourcestorage.FieldURL:
		return m.OldURL(ctx)
	case resourcestorage.FieldUsername:
		return m.OldUsername(ctx)
	case resourcestorage.FieldWidth:
		return m.OldWidth(ctx)
	case resourcestorage.FieldMd5code:
		return m.OldMd5code(ctx)
	case resourcestorage.FieldRemark:
		return m.OldRemark(ctx)
	case resourcestorage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resourcestorage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resourcestorage.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case resourcestorage.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case resourcestorage.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcestorage.FieldGroupId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupId(v)
		return nil
	case resourcestorage.FieldStorageType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case resourcestorage.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case resourcestorage.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	case resourcestorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resourcestorage.FieldSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuffix(v)
		return nil
	case resourcestorage.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case resourcestorage.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resourcestorage.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case resourcestorage.FieldDeleteUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteUrl(v)
		return nil
	case resourcestorage.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case resourcestorage.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case resourcestorage.FieldHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case resourcestorage.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case resourcestorage.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case resourcestorage.FieldWidth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case resourcestorage.FieldMd5code:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5code(v)
		return nil
	case resourcestorage.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case resourcestorage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resourcestorage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resourcestorage.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case resourcestorage.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case resourcestorage.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceStorageMutation) AddedFields() []string {
	var fields []string
	if m.addgroupId != nil {
		fields = append(fields, resourcestorage.FieldGroupId)
	}
	if m.addstorageType != nil {
		fields = append(fields, resourcestorage.FieldStorageType)
	}
	if m.addcreateBy != nil {
		fields = append(fields, resourcestorage.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, resourcestorage.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, resourcestorage.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourcestorage.FieldGroupId:
		return m.AddedGroupId()
	case resourcestorage.FieldStorageType:
		return m.AddedStorageType()
	case resourcestorage.FieldCreateBy:
		return m.AddedCreateBy()
	case resourcestorage.FieldUpdateBy:
		return m.AddedUpdateBy()
	case resourcestorage.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourcestorage.FieldGroupId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupId(v)
		return nil
	case resourcestorage.FieldStorageType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageType(v)
		return nil
	case resourcestorage.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case resourcestorage.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case resourcestorage.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceStorageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcestorage.FieldGroupId) {
		fields = append(fields, resourcestorage.FieldGroupId)
	}
	if m.FieldCleared(resourcestorage.FieldStorageType) {
		fields = append(fields, resourcestorage.FieldStorageType)
	}
	if m.FieldCleared(resourcestorage.FieldRealName) {
		fields = append(fields, resourcestorage.FieldRealName)
	}
	if m.FieldCleared(resourcestorage.FieldBucket) {
		fields = append(fields, resourcestorage.FieldBucket)
	}
	if m.FieldCleared(resourcestorage.FieldName) {
		fields = append(fields, resourcestorage.FieldName)
	}
	if m.FieldCleared(resourcestorage.FieldSuffix) {
		fields = append(fields, resourcestorage.FieldSuffix)
	}
	if m.FieldCleared(resourcestorage.FieldPath) {
		fields = append(fields, resourcestorage.FieldPath)
	}
	if m.FieldCleared(resourcestorage.FieldType) {
		fields = append(fields, resourcestorage.FieldType)
	}
	if m.FieldCleared(resourcestorage.FieldSize) {
		fields = append(fields, resourcestorage.FieldSize)
	}
	if m.FieldCleared(resourcestorage.FieldDeleteUrl) {
		fields = append(fields, resourcestorage.FieldDeleteUrl)
	}
	if m.FieldCleared(resourcestorage.FieldFilename) {
		fields = append(fields, resourcestorage.FieldFilename)
	}
	if m.FieldCleared(resourcestorage.FieldKey) {
		fields = append(fields, resourcestorage.FieldKey)
	}
	if m.FieldCleared(resourcestorage.FieldHeight) {
		fields = append(fields, resourcestorage.FieldHeight)
	}
	if m.FieldCleared(resourcestorage.FieldURL) {
		fields = append(fields, resourcestorage.FieldURL)
	}
	if m.FieldCleared(resourcestorage.FieldUsername) {
		fields = append(fields, resourcestorage.FieldUsername)
	}
	if m.FieldCleared(resourcestorage.FieldWidth) {
		fields = append(fields, resourcestorage.FieldWidth)
	}
	if m.FieldCleared(resourcestorage.FieldMd5code) {
		fields = append(fields, resourcestorage.FieldMd5code)
	}
	if m.FieldCleared(resourcestorage.FieldRemark) {
		fields = append(fields, resourcestorage.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceStorageMutation) ClearField(name string) error {
	switch name {
	case resourcestorage.FieldGroupId:
		m.ClearGroupId()
		return nil
	case resourcestorage.FieldStorageType:
		m.ClearStorageType()
		return nil
	case resourcestorage.FieldRealName:
		m.ClearRealName()
		return nil
	case resourcestorage.FieldBucket:
		m.ClearBucket()
		return nil
	case resourcestorage.FieldName:
		m.ClearName()
		return nil
	case resourcestorage.FieldSuffix:
		m.ClearSuffix()
		return nil
	case resourcestorage.FieldPath:
		m.ClearPath()
		return nil
	case resourcestorage.FieldType:
		m.ClearType()
		return nil
	case resourcestorage.FieldSize:
		m.ClearSize()
		return nil
	case resourcestorage.FieldDeleteUrl:
		m.ClearDeleteUrl()
		return nil
	case resourcestorage.FieldFilename:
		m.ClearFilename()
		return nil
	case resourcestorage.FieldKey:
		m.ClearKey()
		return nil
	case resourcestorage.FieldHeight:
		m.ClearHeight()
		return nil
	case resourcestorage.FieldURL:
		m.ClearURL()
		return nil
	case resourcestorage.FieldUsername:
		m.ClearUsername()
		return nil
	case resourcestorage.FieldWidth:
		m.ClearWidth()
		return nil
	case resourcestorage.FieldMd5code:
		m.ClearMd5code()
		return nil
	case resourcestorage.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown ResourceStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceStorageMutation) ResetField(name string) error {
	switch name {
	case resourcestorage.FieldGroupId:
		m.ResetGroupId()
		return nil
	case resourcestorage.FieldStorageType:
		m.ResetStorageType()
		return nil
	case resourcestorage.FieldRealName:
		m.ResetRealName()
		return nil
	case resourcestorage.FieldBucket:
		m.ResetBucket()
		return nil
	case resourcestorage.FieldName:
		m.ResetName()
		return nil
	case resourcestorage.FieldSuffix:
		m.ResetSuffix()
		return nil
	case resourcestorage.FieldPath:
		m.ResetPath()
		return nil
	case resourcestorage.FieldType:
		m.ResetType()
		return nil
	case resourcestorage.FieldSize:
		m.ResetSize()
		return nil
	case resourcestorage.FieldDeleteUrl:
		m.ResetDeleteUrl()
		return nil
	case resourcestorage.FieldFilename:
		m.ResetFilename()
		return nil
	case resourcestorage.FieldKey:
		m.ResetKey()
		return nil
	case resourcestorage.FieldHeight:
		m.ResetHeight()
		return nil
	case resourcestorage.FieldURL:
		m.ResetURL()
		return nil
	case resourcestorage.FieldUsername:
		m.ResetUsername()
		return nil
	case resourcestorage.FieldWidth:
		m.ResetWidth()
		return nil
	case resourcestorage.FieldMd5code:
		m.ResetMd5code()
		return nil
	case resourcestorage.FieldRemark:
		m.ResetRemark()
		return nil
	case resourcestorage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resourcestorage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resourcestorage.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case resourcestorage.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case resourcestorage.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown ResourceStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceStorageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceStorageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceStorageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResourceStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceStorageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResourceStorage edge %s", name)
}

// ScoreProductMutation represents an operation that mutates the ScoreProduct nodes in the graph.
type ScoreProductMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	productName   *string
	summary       *string
	cardUrl       *string
	score         *int64
	addscore      *int64
	vipType       *int64
	addvipType    *int64
	effectTime    *time.Time
	expiredTime   *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ScoreProduct, error)
	predicates    []predicate.ScoreProduct
}

var _ ent.Mutation = (*ScoreProductMutation)(nil)

// scoreproductOption allows management of the mutation configuration using functional options.
type scoreproductOption func(*ScoreProductMutation)

// newScoreProductMutation creates new mutation for the ScoreProduct entity.
func newScoreProductMutation(c config, op Op, opts ...scoreproductOption) *ScoreProductMutation {
	m := &ScoreProductMutation{
		config:        c,
		op:            op,
		typ:           TypeScoreProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScoreProductID sets the ID field of the mutation.
func withScoreProductID(id int64) scoreproductOption {
	return func(m *ScoreProductMutation) {
		var (
			err   error
			once  sync.Once
			value *ScoreProduct
		)
		m.oldValue = func(ctx context.Context) (*ScoreProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScoreProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScoreProduct sets the old ScoreProduct of the mutation.
func withScoreProduct(node *ScoreProduct) scoreproductOption {
	return func(m *ScoreProductMutation) {
		m.oldValue = func(context.Context) (*ScoreProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScoreProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScoreProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScoreProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScoreProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScoreProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductName sets the "productName" field.
func (m *ScoreProductMutation) SetProductName(s string) {
	m.productName = &s
}

// ProductName returns the value of the "productName" field in the mutation.
func (m *ScoreProductMutation) ProductName() (r string, exists bool) {
	v := m.productName
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "productName" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "productName" field.
func (m *ScoreProductMutation) ClearProductName() {
	m.productName = nil
	m.clearedFields[scoreproduct.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "productName" field was cleared in this mutation.
func (m *ScoreProductMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[scoreproduct.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "productName" field.
func (m *ScoreProductMutation) ResetProductName() {
	m.productName = nil
	delete(m.clearedFields, scoreproduct.FieldProductName)
}

// SetSummary sets the "summary" field.
func (m *ScoreProductMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ScoreProductMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ScoreProductMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[scoreproduct.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ScoreProductMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[scoreproduct.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ScoreProductMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, scoreproduct.FieldSummary)
}

// SetCardUrl sets the "cardUrl" field.
func (m *ScoreProductMutation) SetCardUrl(s string) {
	m.cardUrl = &s
}

// CardUrl returns the value of the "cardUrl" field in the mutation.
func (m *ScoreProductMutation) CardUrl() (r string, exists bool) {
	v := m.cardUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldCardUrl returns the old "cardUrl" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldCardUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardUrl: %w", err)
	}
	return oldValue.CardUrl, nil
}

// ClearCardUrl clears the value of the "cardUrl" field.
func (m *ScoreProductMutation) ClearCardUrl() {
	m.cardUrl = nil
	m.clearedFields[scoreproduct.FieldCardUrl] = struct{}{}
}

// CardUrlCleared returns if the "cardUrl" field was cleared in this mutation.
func (m *ScoreProductMutation) CardUrlCleared() bool {
	_, ok := m.clearedFields[scoreproduct.FieldCardUrl]
	return ok
}

// ResetCardUrl resets all changes to the "cardUrl" field.
func (m *ScoreProductMutation) ResetCardUrl() {
	m.cardUrl = nil
	delete(m.clearedFields, scoreproduct.FieldCardUrl)
}

// SetScore sets the "score" field.
func (m *ScoreProductMutation) SetScore(i int64) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ScoreProductMutation) Score() (r int64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldScore(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *ScoreProductMutation) AddScore(i int64) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ScoreProductMutation) AddedScore() (r int64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ScoreProductMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[scoreproduct.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ScoreProductMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[scoreproduct.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ScoreProductMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, scoreproduct.FieldScore)
}

// SetVipType sets the "vipType" field.
func (m *ScoreProductMutation) SetVipType(i int64) {
	m.vipType = &i
	m.addvipType = nil
}

// VipType returns the value of the "vipType" field in the mutation.
func (m *ScoreProductMutation) VipType() (r int64, exists bool) {
	v := m.vipType
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vipType" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldVipType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vipType" field.
func (m *ScoreProductMutation) AddVipType(i int64) {
	if m.addvipType != nil {
		*m.addvipType += i
	} else {
		m.addvipType = &i
	}
}

// AddedVipType returns the value that was added to the "vipType" field in this mutation.
func (m *ScoreProductMutation) AddedVipType() (r int64, exists bool) {
	v := m.addvipType
	if v == nil {
		return
	}
	return *v, true
}

// ClearVipType clears the value of the "vipType" field.
func (m *ScoreProductMutation) ClearVipType() {
	m.vipType = nil
	m.addvipType = nil
	m.clearedFields[scoreproduct.FieldVipType] = struct{}{}
}

// VipTypeCleared returns if the "vipType" field was cleared in this mutation.
func (m *ScoreProductMutation) VipTypeCleared() bool {
	_, ok := m.clearedFields[scoreproduct.FieldVipType]
	return ok
}

// ResetVipType resets all changes to the "vipType" field.
func (m *ScoreProductMutation) ResetVipType() {
	m.vipType = nil
	m.addvipType = nil
	delete(m.clearedFields, scoreproduct.FieldVipType)
}

// SetEffectTime sets the "effectTime" field.
func (m *ScoreProductMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *ScoreProductMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *ScoreProductMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *ScoreProductMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *ScoreProductMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *ScoreProductMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ScoreProductMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ScoreProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ScoreProductMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ScoreProductMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ScoreProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ScoreProductMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ScoreProductMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ScoreProductMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ScoreProductMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ScoreProductMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ScoreProductMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ScoreProductMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ScoreProductMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ScoreProductMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ScoreProductMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ScoreProductMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ScoreProductMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ScoreProductMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the ScoreProduct entity.
// If the ScoreProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreProductMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ScoreProductMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ScoreProductMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ScoreProductMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the ScoreProductMutation builder.
func (m *ScoreProductMutation) Where(ps ...predicate.ScoreProduct) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScoreProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ScoreProduct).
func (m *ScoreProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScoreProductMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.productName != nil {
		fields = append(fields, scoreproduct.FieldProductName)
	}
	if m.summary != nil {
		fields = append(fields, scoreproduct.FieldSummary)
	}
	if m.cardUrl != nil {
		fields = append(fields, scoreproduct.FieldCardUrl)
	}
	if m.score != nil {
		fields = append(fields, scoreproduct.FieldScore)
	}
	if m.vipType != nil {
		fields = append(fields, scoreproduct.FieldVipType)
	}
	if m.effectTime != nil {
		fields = append(fields, scoreproduct.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, scoreproduct.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, scoreproduct.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, scoreproduct.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, scoreproduct.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, scoreproduct.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, scoreproduct.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScoreProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scoreproduct.FieldProductName:
		return m.ProductName()
	case scoreproduct.FieldSummary:
		return m.Summary()
	case scoreproduct.FieldCardUrl:
		return m.CardUrl()
	case scoreproduct.FieldScore:
		return m.Score()
	case scoreproduct.FieldVipType:
		return m.VipType()
	case scoreproduct.FieldEffectTime:
		return m.EffectTime()
	case scoreproduct.FieldExpiredTime:
		return m.ExpiredTime()
	case scoreproduct.FieldCreatedAt:
		return m.CreatedAt()
	case scoreproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case scoreproduct.FieldCreateBy:
		return m.CreateBy()
	case scoreproduct.FieldUpdateBy:
		return m.UpdateBy()
	case scoreproduct.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScoreProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scoreproduct.FieldProductName:
		return m.OldProductName(ctx)
	case scoreproduct.FieldSummary:
		return m.OldSummary(ctx)
	case scoreproduct.FieldCardUrl:
		return m.OldCardUrl(ctx)
	case scoreproduct.FieldScore:
		return m.OldScore(ctx)
	case scoreproduct.FieldVipType:
		return m.OldVipType(ctx)
	case scoreproduct.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case scoreproduct.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case scoreproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scoreproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case scoreproduct.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case scoreproduct.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case scoreproduct.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown ScoreProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scoreproduct.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case scoreproduct.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case scoreproduct.FieldCardUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardUrl(v)
		return nil
	case scoreproduct.FieldScore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case scoreproduct.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case scoreproduct.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case scoreproduct.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case scoreproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scoreproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case scoreproduct.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case scoreproduct.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case scoreproduct.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ScoreProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScoreProductMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, scoreproduct.FieldScore)
	}
	if m.addvipType != nil {
		fields = append(fields, scoreproduct.FieldVipType)
	}
	if m.addcreateBy != nil {
		fields = append(fields, scoreproduct.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, scoreproduct.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, scoreproduct.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScoreProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scoreproduct.FieldScore:
		return m.AddedScore()
	case scoreproduct.FieldVipType:
		return m.AddedVipType()
	case scoreproduct.FieldCreateBy:
		return m.AddedCreateBy()
	case scoreproduct.FieldUpdateBy:
		return m.AddedUpdateBy()
	case scoreproduct.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scoreproduct.FieldScore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case scoreproduct.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	case scoreproduct.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case scoreproduct.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case scoreproduct.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ScoreProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScoreProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scoreproduct.FieldProductName) {
		fields = append(fields, scoreproduct.FieldProductName)
	}
	if m.FieldCleared(scoreproduct.FieldSummary) {
		fields = append(fields, scoreproduct.FieldSummary)
	}
	if m.FieldCleared(scoreproduct.FieldCardUrl) {
		fields = append(fields, scoreproduct.FieldCardUrl)
	}
	if m.FieldCleared(scoreproduct.FieldScore) {
		fields = append(fields, scoreproduct.FieldScore)
	}
	if m.FieldCleared(scoreproduct.FieldVipType) {
		fields = append(fields, scoreproduct.FieldVipType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScoreProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScoreProductMutation) ClearField(name string) error {
	switch name {
	case scoreproduct.FieldProductName:
		m.ClearProductName()
		return nil
	case scoreproduct.FieldSummary:
		m.ClearSummary()
		return nil
	case scoreproduct.FieldCardUrl:
		m.ClearCardUrl()
		return nil
	case scoreproduct.FieldScore:
		m.ClearScore()
		return nil
	case scoreproduct.FieldVipType:
		m.ClearVipType()
		return nil
	}
	return fmt.Errorf("unknown ScoreProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScoreProductMutation) ResetField(name string) error {
	switch name {
	case scoreproduct.FieldProductName:
		m.ResetProductName()
		return nil
	case scoreproduct.FieldSummary:
		m.ResetSummary()
		return nil
	case scoreproduct.FieldCardUrl:
		m.ResetCardUrl()
		return nil
	case scoreproduct.FieldScore:
		m.ResetScore()
		return nil
	case scoreproduct.FieldVipType:
		m.ResetVipType()
		return nil
	case scoreproduct.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case scoreproduct.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case scoreproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scoreproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case scoreproduct.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case scoreproduct.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case scoreproduct.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown ScoreProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScoreProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScoreProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScoreProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScoreProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScoreProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScoreProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScoreProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ScoreProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScoreProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ScoreProduct edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	taskName      *string
	taskGroup     *string
	unit          *string
	topic         *string
	function      *string
	taskCode      *string
	preTask       *int64
	addpreTask    *int64
	novelId       *int64
	addnovelId    *int64
	cycleType     *string
	remark        *string
	amount        *int64
	addamount     *int64
	reward        *int64
	addreward     *int64
	amountItem    *int32
	addamountItem *int32
	rewardItem    *int32
	addrewardItem *int32
	targetNames   *string
	targetAmounts *string
	status        *bool
	sortNum       *int64
	addsortNum    *int64
	actionType    *string
	effectTime    *time.Time
	expiredTime   *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Task, error)
	predicates    []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskName sets the "taskName" field.
func (m *TaskMutation) SetTaskName(s string) {
	m.taskName = &s
}

// TaskName returns the value of the "taskName" field in the mutation.
func (m *TaskMutation) TaskName() (r string, exists bool) {
	v := m.taskName
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "taskName" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ClearTaskName clears the value of the "taskName" field.
func (m *TaskMutation) ClearTaskName() {
	m.taskName = nil
	m.clearedFields[task.FieldTaskName] = struct{}{}
}

// TaskNameCleared returns if the "taskName" field was cleared in this mutation.
func (m *TaskMutation) TaskNameCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskName]
	return ok
}

// ResetTaskName resets all changes to the "taskName" field.
func (m *TaskMutation) ResetTaskName() {
	m.taskName = nil
	delete(m.clearedFields, task.FieldTaskName)
}

// SetTaskGroup sets the "taskGroup" field.
func (m *TaskMutation) SetTaskGroup(s string) {
	m.taskGroup = &s
}

// TaskGroup returns the value of the "taskGroup" field in the mutation.
func (m *TaskMutation) TaskGroup() (r string, exists bool) {
	v := m.taskGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskGroup returns the old "taskGroup" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskGroup: %w", err)
	}
	return oldValue.TaskGroup, nil
}

// ClearTaskGroup clears the value of the "taskGroup" field.
func (m *TaskMutation) ClearTaskGroup() {
	m.taskGroup = nil
	m.clearedFields[task.FieldTaskGroup] = struct{}{}
}

// TaskGroupCleared returns if the "taskGroup" field was cleared in this mutation.
func (m *TaskMutation) TaskGroupCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskGroup]
	return ok
}

// ResetTaskGroup resets all changes to the "taskGroup" field.
func (m *TaskMutation) ResetTaskGroup() {
	m.taskGroup = nil
	delete(m.clearedFields, task.FieldTaskGroup)
}

// SetUnit sets the "unit" field.
func (m *TaskMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *TaskMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *TaskMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[task.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *TaskMutation) UnitCleared() bool {
	_, ok := m.clearedFields[task.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *TaskMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, task.FieldUnit)
}

// SetTopic sets the "topic" field.
func (m *TaskMutation) SetTopic(s string) {
	m.topic = &s
}

// Topic returns the value of the "topic" field in the mutation.
func (m *TaskMutation) Topic() (r string, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "topic" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTopic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ClearTopic clears the value of the "topic" field.
func (m *TaskMutation) ClearTopic() {
	m.topic = nil
	m.clearedFields[task.FieldTopic] = struct{}{}
}

// TopicCleared returns if the "topic" field was cleared in this mutation.
func (m *TaskMutation) TopicCleared() bool {
	_, ok := m.clearedFields[task.FieldTopic]
	return ok
}

// ResetTopic resets all changes to the "topic" field.
func (m *TaskMutation) ResetTopic() {
	m.topic = nil
	delete(m.clearedFields, task.FieldTopic)
}

// SetFunction sets the "function" field.
func (m *TaskMutation) SetFunction(s string) {
	m.function = &s
}

// Function returns the value of the "function" field in the mutation.
func (m *TaskMutation) Function() (r string, exists bool) {
	v := m.function
	if v == nil {
		return
	}
	return *v, true
}

// OldFunction returns the old "function" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldFunction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunction: %w", err)
	}
	return oldValue.Function, nil
}

// ClearFunction clears the value of the "function" field.
func (m *TaskMutation) ClearFunction() {
	m.function = nil
	m.clearedFields[task.FieldFunction] = struct{}{}
}

// FunctionCleared returns if the "function" field was cleared in this mutation.
func (m *TaskMutation) FunctionCleared() bool {
	_, ok := m.clearedFields[task.FieldFunction]
	return ok
}

// ResetFunction resets all changes to the "function" field.
func (m *TaskMutation) ResetFunction() {
	m.function = nil
	delete(m.clearedFields, task.FieldFunction)
}

// SetTaskCode sets the "taskCode" field.
func (m *TaskMutation) SetTaskCode(s string) {
	m.taskCode = &s
}

// TaskCode returns the value of the "taskCode" field in the mutation.
func (m *TaskMutation) TaskCode() (r string, exists bool) {
	v := m.taskCode
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskCode returns the old "taskCode" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskCode: %w", err)
	}
	return oldValue.TaskCode, nil
}

// ClearTaskCode clears the value of the "taskCode" field.
func (m *TaskMutation) ClearTaskCode() {
	m.taskCode = nil
	m.clearedFields[task.FieldTaskCode] = struct{}{}
}

// TaskCodeCleared returns if the "taskCode" field was cleared in this mutation.
func (m *TaskMutation) TaskCodeCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskCode]
	return ok
}

// ResetTaskCode resets all changes to the "taskCode" field.
func (m *TaskMutation) ResetTaskCode() {
	m.taskCode = nil
	delete(m.clearedFields, task.FieldTaskCode)
}

// SetPreTask sets the "preTask" field.
func (m *TaskMutation) SetPreTask(i int64) {
	m.preTask = &i
	m.addpreTask = nil
}

// PreTask returns the value of the "preTask" field in the mutation.
func (m *TaskMutation) PreTask() (r int64, exists bool) {
	v := m.preTask
	if v == nil {
		return
	}
	return *v, true
}

// OldPreTask returns the old "preTask" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPreTask(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreTask: %w", err)
	}
	return oldValue.PreTask, nil
}

// AddPreTask adds i to the "preTask" field.
func (m *TaskMutation) AddPreTask(i int64) {
	if m.addpreTask != nil {
		*m.addpreTask += i
	} else {
		m.addpreTask = &i
	}
}

// AddedPreTask returns the value that was added to the "preTask" field in this mutation.
func (m *TaskMutation) AddedPreTask() (r int64, exists bool) {
	v := m.addpreTask
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreTask clears the value of the "preTask" field.
func (m *TaskMutation) ClearPreTask() {
	m.preTask = nil
	m.addpreTask = nil
	m.clearedFields[task.FieldPreTask] = struct{}{}
}

// PreTaskCleared returns if the "preTask" field was cleared in this mutation.
func (m *TaskMutation) PreTaskCleared() bool {
	_, ok := m.clearedFields[task.FieldPreTask]
	return ok
}

// ResetPreTask resets all changes to the "preTask" field.
func (m *TaskMutation) ResetPreTask() {
	m.preTask = nil
	m.addpreTask = nil
	delete(m.clearedFields, task.FieldPreTask)
}

// SetNovelId sets the "novelId" field.
func (m *TaskMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *TaskMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *TaskMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *TaskMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *TaskMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[task.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *TaskMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[task.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *TaskMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, task.FieldNovelId)
}

// SetCycleType sets the "cycleType" field.
func (m *TaskMutation) SetCycleType(s string) {
	m.cycleType = &s
}

// CycleType returns the value of the "cycleType" field in the mutation.
func (m *TaskMutation) CycleType() (r string, exists bool) {
	v := m.cycleType
	if v == nil {
		return
	}
	return *v, true
}

// OldCycleType returns the old "cycleType" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCycleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycleType: %w", err)
	}
	return oldValue.CycleType, nil
}

// ClearCycleType clears the value of the "cycleType" field.
func (m *TaskMutation) ClearCycleType() {
	m.cycleType = nil
	m.clearedFields[task.FieldCycleType] = struct{}{}
}

// CycleTypeCleared returns if the "cycleType" field was cleared in this mutation.
func (m *TaskMutation) CycleTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldCycleType]
	return ok
}

// ResetCycleType resets all changes to the "cycleType" field.
func (m *TaskMutation) ResetCycleType() {
	m.cycleType = nil
	delete(m.clearedFields, task.FieldCycleType)
}

// SetRemark sets the "remark" field.
func (m *TaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TaskMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[task.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TaskMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[task.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TaskMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, task.FieldRemark)
}

// SetAmount sets the "amount" field.
func (m *TaskMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TaskMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TaskMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TaskMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *TaskMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[task.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *TaskMutation) AmountCleared() bool {
	_, ok := m.clearedFields[task.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *TaskMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, task.FieldAmount)
}

// SetReward sets the "reward" field.
func (m *TaskMutation) SetReward(i int64) {
	m.reward = &i
	m.addreward = nil
}

// Reward returns the value of the "reward" field in the mutation.
func (m *TaskMutation) Reward() (r int64, exists bool) {
	v := m.reward
	if v == nil {
		return
	}
	return *v, true
}

// OldReward returns the old "reward" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldReward(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReward: %w", err)
	}
	return oldValue.Reward, nil
}

// AddReward adds i to the "reward" field.
func (m *TaskMutation) AddReward(i int64) {
	if m.addreward != nil {
		*m.addreward += i
	} else {
		m.addreward = &i
	}
}

// AddedReward returns the value that was added to the "reward" field in this mutation.
func (m *TaskMutation) AddedReward() (r int64, exists bool) {
	v := m.addreward
	if v == nil {
		return
	}
	return *v, true
}

// ClearReward clears the value of the "reward" field.
func (m *TaskMutation) ClearReward() {
	m.reward = nil
	m.addreward = nil
	m.clearedFields[task.FieldReward] = struct{}{}
}

// RewardCleared returns if the "reward" field was cleared in this mutation.
func (m *TaskMutation) RewardCleared() bool {
	_, ok := m.clearedFields[task.FieldReward]
	return ok
}

// ResetReward resets all changes to the "reward" field.
func (m *TaskMutation) ResetReward() {
	m.reward = nil
	m.addreward = nil
	delete(m.clearedFields, task.FieldReward)
}

// SetAmountItem sets the "amountItem" field.
func (m *TaskMutation) SetAmountItem(i int32) {
	m.amountItem = &i
	m.addamountItem = nil
}

// AmountItem returns the value of the "amountItem" field in the mutation.
func (m *TaskMutation) AmountItem() (r int32, exists bool) {
	v := m.amountItem
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountItem returns the old "amountItem" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAmountItem(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountItem: %w", err)
	}
	return oldValue.AmountItem, nil
}

// AddAmountItem adds i to the "amountItem" field.
func (m *TaskMutation) AddAmountItem(i int32) {
	if m.addamountItem != nil {
		*m.addamountItem += i
	} else {
		m.addamountItem = &i
	}
}

// AddedAmountItem returns the value that was added to the "amountItem" field in this mutation.
func (m *TaskMutation) AddedAmountItem() (r int32, exists bool) {
	v := m.addamountItem
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmountItem clears the value of the "amountItem" field.
func (m *TaskMutation) ClearAmountItem() {
	m.amountItem = nil
	m.addamountItem = nil
	m.clearedFields[task.FieldAmountItem] = struct{}{}
}

// AmountItemCleared returns if the "amountItem" field was cleared in this mutation.
func (m *TaskMutation) AmountItemCleared() bool {
	_, ok := m.clearedFields[task.FieldAmountItem]
	return ok
}

// ResetAmountItem resets all changes to the "amountItem" field.
func (m *TaskMutation) ResetAmountItem() {
	m.amountItem = nil
	m.addamountItem = nil
	delete(m.clearedFields, task.FieldAmountItem)
}

// SetRewardItem sets the "rewardItem" field.
func (m *TaskMutation) SetRewardItem(i int32) {
	m.rewardItem = &i
	m.addrewardItem = nil
}

// RewardItem returns the value of the "rewardItem" field in the mutation.
func (m *TaskMutation) RewardItem() (r int32, exists bool) {
	v := m.rewardItem
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardItem returns the old "rewardItem" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRewardItem(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardItem: %w", err)
	}
	return oldValue.RewardItem, nil
}

// AddRewardItem adds i to the "rewardItem" field.
func (m *TaskMutation) AddRewardItem(i int32) {
	if m.addrewardItem != nil {
		*m.addrewardItem += i
	} else {
		m.addrewardItem = &i
	}
}

// AddedRewardItem returns the value that was added to the "rewardItem" field in this mutation.
func (m *TaskMutation) AddedRewardItem() (r int32, exists bool) {
	v := m.addrewardItem
	if v == nil {
		return
	}
	return *v, true
}

// ClearRewardItem clears the value of the "rewardItem" field.
func (m *TaskMutation) ClearRewardItem() {
	m.rewardItem = nil
	m.addrewardItem = nil
	m.clearedFields[task.FieldRewardItem] = struct{}{}
}

// RewardItemCleared returns if the "rewardItem" field was cleared in this mutation.
func (m *TaskMutation) RewardItemCleared() bool {
	_, ok := m.clearedFields[task.FieldRewardItem]
	return ok
}

// ResetRewardItem resets all changes to the "rewardItem" field.
func (m *TaskMutation) ResetRewardItem() {
	m.rewardItem = nil
	m.addrewardItem = nil
	delete(m.clearedFields, task.FieldRewardItem)
}

// SetTargetNames sets the "targetNames" field.
func (m *TaskMutation) SetTargetNames(s string) {
	m.targetNames = &s
}

// TargetNames returns the value of the "targetNames" field in the mutation.
func (m *TaskMutation) TargetNames() (r string, exists bool) {
	v := m.targetNames
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetNames returns the old "targetNames" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTargetNames(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetNames: %w", err)
	}
	return oldValue.TargetNames, nil
}

// ClearTargetNames clears the value of the "targetNames" field.
func (m *TaskMutation) ClearTargetNames() {
	m.targetNames = nil
	m.clearedFields[task.FieldTargetNames] = struct{}{}
}

// TargetNamesCleared returns if the "targetNames" field was cleared in this mutation.
func (m *TaskMutation) TargetNamesCleared() bool {
	_, ok := m.clearedFields[task.FieldTargetNames]
	return ok
}

// ResetTargetNames resets all changes to the "targetNames" field.
func (m *TaskMutation) ResetTargetNames() {
	m.targetNames = nil
	delete(m.clearedFields, task.FieldTargetNames)
}

// SetTargetAmounts sets the "targetAmounts" field.
func (m *TaskMutation) SetTargetAmounts(s string) {
	m.targetAmounts = &s
}

// TargetAmounts returns the value of the "targetAmounts" field in the mutation.
func (m *TaskMutation) TargetAmounts() (r string, exists bool) {
	v := m.targetAmounts
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAmounts returns the old "targetAmounts" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTargetAmounts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAmounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAmounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAmounts: %w", err)
	}
	return oldValue.TargetAmounts, nil
}

// ClearTargetAmounts clears the value of the "targetAmounts" field.
func (m *TaskMutation) ClearTargetAmounts() {
	m.targetAmounts = nil
	m.clearedFields[task.FieldTargetAmounts] = struct{}{}
}

// TargetAmountsCleared returns if the "targetAmounts" field was cleared in this mutation.
func (m *TaskMutation) TargetAmountsCleared() bool {
	_, ok := m.clearedFields[task.FieldTargetAmounts]
	return ok
}

// ResetTargetAmounts resets all changes to the "targetAmounts" field.
func (m *TaskMutation) ResetTargetAmounts() {
	m.targetAmounts = nil
	delete(m.clearedFields, task.FieldTargetAmounts)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TaskMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[task.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TaskMutation) StatusCleared() bool {
	_, ok := m.clearedFields[task.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, task.FieldStatus)
}

// SetSortNum sets the "sortNum" field.
func (m *TaskMutation) SetSortNum(i int64) {
	m.sortNum = &i
	m.addsortNum = nil
}

// SortNum returns the value of the "sortNum" field in the mutation.
func (m *TaskMutation) SortNum() (r int64, exists bool) {
	v := m.sortNum
	if v == nil {
		return
	}
	return *v, true
}

// OldSortNum returns the old "sortNum" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSortNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortNum: %w", err)
	}
	return oldValue.SortNum, nil
}

// AddSortNum adds i to the "sortNum" field.
func (m *TaskMutation) AddSortNum(i int64) {
	if m.addsortNum != nil {
		*m.addsortNum += i
	} else {
		m.addsortNum = &i
	}
}

// AddedSortNum returns the value that was added to the "sortNum" field in this mutation.
func (m *TaskMutation) AddedSortNum() (r int64, exists bool) {
	v := m.addsortNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortNum clears the value of the "sortNum" field.
func (m *TaskMutation) ClearSortNum() {
	m.sortNum = nil
	m.addsortNum = nil
	m.clearedFields[task.FieldSortNum] = struct{}{}
}

// SortNumCleared returns if the "sortNum" field was cleared in this mutation.
func (m *TaskMutation) SortNumCleared() bool {
	_, ok := m.clearedFields[task.FieldSortNum]
	return ok
}

// ResetSortNum resets all changes to the "sortNum" field.
func (m *TaskMutation) ResetSortNum() {
	m.sortNum = nil
	m.addsortNum = nil
	delete(m.clearedFields, task.FieldSortNum)
}

// SetActionType sets the "actionType" field.
func (m *TaskMutation) SetActionType(s string) {
	m.actionType = &s
}

// ActionType returns the value of the "actionType" field in the mutation.
func (m *TaskMutation) ActionType() (r string, exists bool) {
	v := m.actionType
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "actionType" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldActionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ClearActionType clears the value of the "actionType" field.
func (m *TaskMutation) ClearActionType() {
	m.actionType = nil
	m.clearedFields[task.FieldActionType] = struct{}{}
}

// ActionTypeCleared returns if the "actionType" field was cleared in this mutation.
func (m *TaskMutation) ActionTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldActionType]
	return ok
}

// ResetActionType resets all changes to the "actionType" field.
func (m *TaskMutation) ResetActionType() {
	m.actionType = nil
	delete(m.clearedFields, task.FieldActionType)
}

// SetEffectTime sets the "effectTime" field.
func (m *TaskMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *TaskMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *TaskMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *TaskMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *TaskMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *TaskMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *TaskMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *TaskMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *TaskMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *TaskMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *TaskMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *TaskMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *TaskMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *TaskMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *TaskMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *TaskMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *TaskMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *TaskMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *TaskMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *TaskMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *TaskMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.taskName != nil {
		fields = append(fields, task.FieldTaskName)
	}
	if m.taskGroup != nil {
		fields = append(fields, task.FieldTaskGroup)
	}
	if m.unit != nil {
		fields = append(fields, task.FieldUnit)
	}
	if m.topic != nil {
		fields = append(fields, task.FieldTopic)
	}
	if m.function != nil {
		fields = append(fields, task.FieldFunction)
	}
	if m.taskCode != nil {
		fields = append(fields, task.FieldTaskCode)
	}
	if m.preTask != nil {
		fields = append(fields, task.FieldPreTask)
	}
	if m.novelId != nil {
		fields = append(fields, task.FieldNovelId)
	}
	if m.cycleType != nil {
		fields = append(fields, task.FieldCycleType)
	}
	if m.remark != nil {
		fields = append(fields, task.FieldRemark)
	}
	if m.amount != nil {
		fields = append(fields, task.FieldAmount)
	}
	if m.reward != nil {
		fields = append(fields, task.FieldReward)
	}
	if m.amountItem != nil {
		fields = append(fields, task.FieldAmountItem)
	}
	if m.rewardItem != nil {
		fields = append(fields, task.FieldRewardItem)
	}
	if m.targetNames != nil {
		fields = append(fields, task.FieldTargetNames)
	}
	if m.targetAmounts != nil {
		fields = append(fields, task.FieldTargetAmounts)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.sortNum != nil {
		fields = append(fields, task.FieldSortNum)
	}
	if m.actionType != nil {
		fields = append(fields, task.FieldActionType)
	}
	if m.effectTime != nil {
		fields = append(fields, task.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, task.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, task.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, task.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, task.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTaskName:
		return m.TaskName()
	case task.FieldTaskGroup:
		return m.TaskGroup()
	case task.FieldUnit:
		return m.Unit()
	case task.FieldTopic:
		return m.Topic()
	case task.FieldFunction:
		return m.Function()
	case task.FieldTaskCode:
		return m.TaskCode()
	case task.FieldPreTask:
		return m.PreTask()
	case task.FieldNovelId:
		return m.NovelId()
	case task.FieldCycleType:
		return m.CycleType()
	case task.FieldRemark:
		return m.Remark()
	case task.FieldAmount:
		return m.Amount()
	case task.FieldReward:
		return m.Reward()
	case task.FieldAmountItem:
		return m.AmountItem()
	case task.FieldRewardItem:
		return m.RewardItem()
	case task.FieldTargetNames:
		return m.TargetNames()
	case task.FieldTargetAmounts:
		return m.TargetAmounts()
	case task.FieldStatus:
		return m.Status()
	case task.FieldSortNum:
		return m.SortNum()
	case task.FieldActionType:
		return m.ActionType()
	case task.FieldEffectTime:
		return m.EffectTime()
	case task.FieldExpiredTime:
		return m.ExpiredTime()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldCreateBy:
		return m.CreateBy()
	case task.FieldUpdateBy:
		return m.UpdateBy()
	case task.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldTaskName:
		return m.OldTaskName(ctx)
	case task.FieldTaskGroup:
		return m.OldTaskGroup(ctx)
	case task.FieldUnit:
		return m.OldUnit(ctx)
	case task.FieldTopic:
		return m.OldTopic(ctx)
	case task.FieldFunction:
		return m.OldFunction(ctx)
	case task.FieldTaskCode:
		return m.OldTaskCode(ctx)
	case task.FieldPreTask:
		return m.OldPreTask(ctx)
	case task.FieldNovelId:
		return m.OldNovelId(ctx)
	case task.FieldCycleType:
		return m.OldCycleType(ctx)
	case task.FieldRemark:
		return m.OldRemark(ctx)
	case task.FieldAmount:
		return m.OldAmount(ctx)
	case task.FieldReward:
		return m.OldReward(ctx)
	case task.FieldAmountItem:
		return m.OldAmountItem(ctx)
	case task.FieldRewardItem:
		return m.OldRewardItem(ctx)
	case task.FieldTargetNames:
		return m.OldTargetNames(ctx)
	case task.FieldTargetAmounts:
		return m.OldTargetAmounts(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldSortNum:
		return m.OldSortNum(ctx)
	case task.FieldActionType:
		return m.OldActionType(ctx)
	case task.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case task.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case task.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case task.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case task.FieldTaskGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskGroup(v)
		return nil
	case task.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case task.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case task.FieldFunction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunction(v)
		return nil
	case task.FieldTaskCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskCode(v)
		return nil
	case task.FieldPreTask:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreTask(v)
		return nil
	case task.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case task.FieldCycleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycleType(v)
		return nil
	case task.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case task.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case task.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReward(v)
		return nil
	case task.FieldAmountItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountItem(v)
		return nil
	case task.FieldRewardItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardItem(v)
		return nil
	case task.FieldTargetNames:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetNames(v)
		return nil
	case task.FieldTargetAmounts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAmounts(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldSortNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortNum(v)
		return nil
	case task.FieldActionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case task.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case task.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case task.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case task.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addpreTask != nil {
		fields = append(fields, task.FieldPreTask)
	}
	if m.addnovelId != nil {
		fields = append(fields, task.FieldNovelId)
	}
	if m.addamount != nil {
		fields = append(fields, task.FieldAmount)
	}
	if m.addreward != nil {
		fields = append(fields, task.FieldReward)
	}
	if m.addamountItem != nil {
		fields = append(fields, task.FieldAmountItem)
	}
	if m.addrewardItem != nil {
		fields = append(fields, task.FieldRewardItem)
	}
	if m.addsortNum != nil {
		fields = append(fields, task.FieldSortNum)
	}
	if m.addcreateBy != nil {
		fields = append(fields, task.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, task.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, task.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldPreTask:
		return m.AddedPreTask()
	case task.FieldNovelId:
		return m.AddedNovelId()
	case task.FieldAmount:
		return m.AddedAmount()
	case task.FieldReward:
		return m.AddedReward()
	case task.FieldAmountItem:
		return m.AddedAmountItem()
	case task.FieldRewardItem:
		return m.AddedRewardItem()
	case task.FieldSortNum:
		return m.AddedSortNum()
	case task.FieldCreateBy:
		return m.AddedCreateBy()
	case task.FieldUpdateBy:
		return m.AddedUpdateBy()
	case task.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldPreTask:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreTask(v)
		return nil
	case task.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case task.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case task.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReward(v)
		return nil
	case task.FieldAmountItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountItem(v)
		return nil
	case task.FieldRewardItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardItem(v)
		return nil
	case task.FieldSortNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortNum(v)
		return nil
	case task.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case task.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case task.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldTaskName) {
		fields = append(fields, task.FieldTaskName)
	}
	if m.FieldCleared(task.FieldTaskGroup) {
		fields = append(fields, task.FieldTaskGroup)
	}
	if m.FieldCleared(task.FieldUnit) {
		fields = append(fields, task.FieldUnit)
	}
	if m.FieldCleared(task.FieldTopic) {
		fields = append(fields, task.FieldTopic)
	}
	if m.FieldCleared(task.FieldFunction) {
		fields = append(fields, task.FieldFunction)
	}
	if m.FieldCleared(task.FieldTaskCode) {
		fields = append(fields, task.FieldTaskCode)
	}
	if m.FieldCleared(task.FieldPreTask) {
		fields = append(fields, task.FieldPreTask)
	}
	if m.FieldCleared(task.FieldNovelId) {
		fields = append(fields, task.FieldNovelId)
	}
	if m.FieldCleared(task.FieldCycleType) {
		fields = append(fields, task.FieldCycleType)
	}
	if m.FieldCleared(task.FieldRemark) {
		fields = append(fields, task.FieldRemark)
	}
	if m.FieldCleared(task.FieldAmount) {
		fields = append(fields, task.FieldAmount)
	}
	if m.FieldCleared(task.FieldReward) {
		fields = append(fields, task.FieldReward)
	}
	if m.FieldCleared(task.FieldAmountItem) {
		fields = append(fields, task.FieldAmountItem)
	}
	if m.FieldCleared(task.FieldRewardItem) {
		fields = append(fields, task.FieldRewardItem)
	}
	if m.FieldCleared(task.FieldTargetNames) {
		fields = append(fields, task.FieldTargetNames)
	}
	if m.FieldCleared(task.FieldTargetAmounts) {
		fields = append(fields, task.FieldTargetAmounts)
	}
	if m.FieldCleared(task.FieldStatus) {
		fields = append(fields, task.FieldStatus)
	}
	if m.FieldCleared(task.FieldSortNum) {
		fields = append(fields, task.FieldSortNum)
	}
	if m.FieldCleared(task.FieldActionType) {
		fields = append(fields, task.FieldActionType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldTaskName:
		m.ClearTaskName()
		return nil
	case task.FieldTaskGroup:
		m.ClearTaskGroup()
		return nil
	case task.FieldUnit:
		m.ClearUnit()
		return nil
	case task.FieldTopic:
		m.ClearTopic()
		return nil
	case task.FieldFunction:
		m.ClearFunction()
		return nil
	case task.FieldTaskCode:
		m.ClearTaskCode()
		return nil
	case task.FieldPreTask:
		m.ClearPreTask()
		return nil
	case task.FieldNovelId:
		m.ClearNovelId()
		return nil
	case task.FieldCycleType:
		m.ClearCycleType()
		return nil
	case task.FieldRemark:
		m.ClearRemark()
		return nil
	case task.FieldAmount:
		m.ClearAmount()
		return nil
	case task.FieldReward:
		m.ClearReward()
		return nil
	case task.FieldAmountItem:
		m.ClearAmountItem()
		return nil
	case task.FieldRewardItem:
		m.ClearRewardItem()
		return nil
	case task.FieldTargetNames:
		m.ClearTargetNames()
		return nil
	case task.FieldTargetAmounts:
		m.ClearTargetAmounts()
		return nil
	case task.FieldStatus:
		m.ClearStatus()
		return nil
	case task.FieldSortNum:
		m.ClearSortNum()
		return nil
	case task.FieldActionType:
		m.ClearActionType()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldTaskName:
		m.ResetTaskName()
		return nil
	case task.FieldTaskGroup:
		m.ResetTaskGroup()
		return nil
	case task.FieldUnit:
		m.ResetUnit()
		return nil
	case task.FieldTopic:
		m.ResetTopic()
		return nil
	case task.FieldFunction:
		m.ResetFunction()
		return nil
	case task.FieldTaskCode:
		m.ResetTaskCode()
		return nil
	case task.FieldPreTask:
		m.ResetPreTask()
		return nil
	case task.FieldNovelId:
		m.ResetNovelId()
		return nil
	case task.FieldCycleType:
		m.ResetCycleType()
		return nil
	case task.FieldRemark:
		m.ResetRemark()
		return nil
	case task.FieldAmount:
		m.ResetAmount()
		return nil
	case task.FieldReward:
		m.ResetReward()
		return nil
	case task.FieldAmountItem:
		m.ResetAmountItem()
		return nil
	case task.FieldRewardItem:
		m.ResetRewardItem()
		return nil
	case task.FieldTargetNames:
		m.ResetTargetNames()
		return nil
	case task.FieldTargetAmounts:
		m.ResetTargetAmounts()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldSortNum:
		m.ResetSortNum()
		return nil
	case task.FieldActionType:
		m.ResetActionType()
		return nil
	case task.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case task.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case task.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case task.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserAnalysisStatisticsMutation represents an operation that mutates the UserAnalysisStatistics nodes in the graph.
type UserAnalysisStatisticsMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	statisticsDate    *string
	allUserNum        *int64
	addallUserNum     *int64
	allPayment        *int64
	addallPayment     *int64
	allPayUser        *int64
	addallPayUser     *int64
	allOrderNum       *int64
	addallOrderNum    *int64
	dayUserNum        *int64
	adddayUserNum     *int64
	dayPayment        *int64
	adddayPayment     *int64
	dayOrderNum       *int64
	adddayOrderNum    *int64
	dayPayUser        *int64
	adddayPayUser     *int64
	dayRegPayment     *int64
	adddayRegPayment  *int64
	dayRegUserNum     *int64
	adddayRegUserNum  *int64
	dayRegOrderNum    *int64
	adddayRegOrderNum *int64
	oldRegPayment     *int64
	addoldRegPayment  *int64
	oldRegUserNum     *int64
	addoldRegUserNum  *int64
	oldRegOrderNum    *int64
	addoldRegOrderNum *int64
	payRate           *int64
	addpayRate        *int64
	arpu              *int64
	addarpu           *int64
	dayRegArpu        *int64
	adddayRegArpu     *int64
	dayArpu           *int64
	adddayArpu        *int64
	dayOldArpu        *int64
	adddayOldArpu     *int64
	createdAt         *time.Time
	updatedAt         *time.Time
	createBy          *int64
	addcreateBy       *int64
	updateBy          *int64
	addupdateBy       *int64
	tenantId          *int64
	addtenantId       *int64
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*UserAnalysisStatistics, error)
	predicates        []predicate.UserAnalysisStatistics
}

var _ ent.Mutation = (*UserAnalysisStatisticsMutation)(nil)

// useranalysisstatisticsOption allows management of the mutation configuration using functional options.
type useranalysisstatisticsOption func(*UserAnalysisStatisticsMutation)

// newUserAnalysisStatisticsMutation creates new mutation for the UserAnalysisStatistics entity.
func newUserAnalysisStatisticsMutation(c config, op Op, opts ...useranalysisstatisticsOption) *UserAnalysisStatisticsMutation {
	m := &UserAnalysisStatisticsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAnalysisStatistics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAnalysisStatisticsID sets the ID field of the mutation.
func withUserAnalysisStatisticsID(id int64) useranalysisstatisticsOption {
	return func(m *UserAnalysisStatisticsMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAnalysisStatistics
		)
		m.oldValue = func(ctx context.Context) (*UserAnalysisStatistics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAnalysisStatistics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAnalysisStatistics sets the old UserAnalysisStatistics of the mutation.
func withUserAnalysisStatistics(node *UserAnalysisStatistics) useranalysisstatisticsOption {
	return func(m *UserAnalysisStatisticsMutation) {
		m.oldValue = func(context.Context) (*UserAnalysisStatistics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAnalysisStatisticsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAnalysisStatisticsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAnalysisStatisticsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAnalysisStatisticsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAnalysisStatistics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatisticsDate sets the "statisticsDate" field.
func (m *UserAnalysisStatisticsMutation) SetStatisticsDate(s string) {
	m.statisticsDate = &s
}

// StatisticsDate returns the value of the "statisticsDate" field in the mutation.
func (m *UserAnalysisStatisticsMutation) StatisticsDate() (r string, exists bool) {
	v := m.statisticsDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStatisticsDate returns the old "statisticsDate" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldStatisticsDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatisticsDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatisticsDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatisticsDate: %w", err)
	}
	return oldValue.StatisticsDate, nil
}

// ResetStatisticsDate resets all changes to the "statisticsDate" field.
func (m *UserAnalysisStatisticsMutation) ResetStatisticsDate() {
	m.statisticsDate = nil
}

// SetAllUserNum sets the "allUserNum" field.
func (m *UserAnalysisStatisticsMutation) SetAllUserNum(i int64) {
	m.allUserNum = &i
	m.addallUserNum = nil
}

// AllUserNum returns the value of the "allUserNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) AllUserNum() (r int64, exists bool) {
	v := m.allUserNum
	if v == nil {
		return
	}
	return *v, true
}

// OldAllUserNum returns the old "allUserNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldAllUserNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllUserNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllUserNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllUserNum: %w", err)
	}
	return oldValue.AllUserNum, nil
}

// AddAllUserNum adds i to the "allUserNum" field.
func (m *UserAnalysisStatisticsMutation) AddAllUserNum(i int64) {
	if m.addallUserNum != nil {
		*m.addallUserNum += i
	} else {
		m.addallUserNum = &i
	}
}

// AddedAllUserNum returns the value that was added to the "allUserNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedAllUserNum() (r int64, exists bool) {
	v := m.addallUserNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllUserNum clears the value of the "allUserNum" field.
func (m *UserAnalysisStatisticsMutation) ClearAllUserNum() {
	m.allUserNum = nil
	m.addallUserNum = nil
	m.clearedFields[useranalysisstatistics.FieldAllUserNum] = struct{}{}
}

// AllUserNumCleared returns if the "allUserNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) AllUserNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldAllUserNum]
	return ok
}

// ResetAllUserNum resets all changes to the "allUserNum" field.
func (m *UserAnalysisStatisticsMutation) ResetAllUserNum() {
	m.allUserNum = nil
	m.addallUserNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldAllUserNum)
}

// SetAllPayment sets the "allPayment" field.
func (m *UserAnalysisStatisticsMutation) SetAllPayment(i int64) {
	m.allPayment = &i
	m.addallPayment = nil
}

// AllPayment returns the value of the "allPayment" field in the mutation.
func (m *UserAnalysisStatisticsMutation) AllPayment() (r int64, exists bool) {
	v := m.allPayment
	if v == nil {
		return
	}
	return *v, true
}

// OldAllPayment returns the old "allPayment" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldAllPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllPayment: %w", err)
	}
	return oldValue.AllPayment, nil
}

// AddAllPayment adds i to the "allPayment" field.
func (m *UserAnalysisStatisticsMutation) AddAllPayment(i int64) {
	if m.addallPayment != nil {
		*m.addallPayment += i
	} else {
		m.addallPayment = &i
	}
}

// AddedAllPayment returns the value that was added to the "allPayment" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedAllPayment() (r int64, exists bool) {
	v := m.addallPayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllPayment clears the value of the "allPayment" field.
func (m *UserAnalysisStatisticsMutation) ClearAllPayment() {
	m.allPayment = nil
	m.addallPayment = nil
	m.clearedFields[useranalysisstatistics.FieldAllPayment] = struct{}{}
}

// AllPaymentCleared returns if the "allPayment" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) AllPaymentCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldAllPayment]
	return ok
}

// ResetAllPayment resets all changes to the "allPayment" field.
func (m *UserAnalysisStatisticsMutation) ResetAllPayment() {
	m.allPayment = nil
	m.addallPayment = nil
	delete(m.clearedFields, useranalysisstatistics.FieldAllPayment)
}

// SetAllPayUser sets the "allPayUser" field.
func (m *UserAnalysisStatisticsMutation) SetAllPayUser(i int64) {
	m.allPayUser = &i
	m.addallPayUser = nil
}

// AllPayUser returns the value of the "allPayUser" field in the mutation.
func (m *UserAnalysisStatisticsMutation) AllPayUser() (r int64, exists bool) {
	v := m.allPayUser
	if v == nil {
		return
	}
	return *v, true
}

// OldAllPayUser returns the old "allPayUser" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldAllPayUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllPayUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllPayUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllPayUser: %w", err)
	}
	return oldValue.AllPayUser, nil
}

// AddAllPayUser adds i to the "allPayUser" field.
func (m *UserAnalysisStatisticsMutation) AddAllPayUser(i int64) {
	if m.addallPayUser != nil {
		*m.addallPayUser += i
	} else {
		m.addallPayUser = &i
	}
}

// AddedAllPayUser returns the value that was added to the "allPayUser" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedAllPayUser() (r int64, exists bool) {
	v := m.addallPayUser
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllPayUser clears the value of the "allPayUser" field.
func (m *UserAnalysisStatisticsMutation) ClearAllPayUser() {
	m.allPayUser = nil
	m.addallPayUser = nil
	m.clearedFields[useranalysisstatistics.FieldAllPayUser] = struct{}{}
}

// AllPayUserCleared returns if the "allPayUser" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) AllPayUserCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldAllPayUser]
	return ok
}

// ResetAllPayUser resets all changes to the "allPayUser" field.
func (m *UserAnalysisStatisticsMutation) ResetAllPayUser() {
	m.allPayUser = nil
	m.addallPayUser = nil
	delete(m.clearedFields, useranalysisstatistics.FieldAllPayUser)
}

// SetAllOrderNum sets the "allOrderNum" field.
func (m *UserAnalysisStatisticsMutation) SetAllOrderNum(i int64) {
	m.allOrderNum = &i
	m.addallOrderNum = nil
}

// AllOrderNum returns the value of the "allOrderNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) AllOrderNum() (r int64, exists bool) {
	v := m.allOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldAllOrderNum returns the old "allOrderNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldAllOrderNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllOrderNum: %w", err)
	}
	return oldValue.AllOrderNum, nil
}

// AddAllOrderNum adds i to the "allOrderNum" field.
func (m *UserAnalysisStatisticsMutation) AddAllOrderNum(i int64) {
	if m.addallOrderNum != nil {
		*m.addallOrderNum += i
	} else {
		m.addallOrderNum = &i
	}
}

// AddedAllOrderNum returns the value that was added to the "allOrderNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedAllOrderNum() (r int64, exists bool) {
	v := m.addallOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllOrderNum clears the value of the "allOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ClearAllOrderNum() {
	m.allOrderNum = nil
	m.addallOrderNum = nil
	m.clearedFields[useranalysisstatistics.FieldAllOrderNum] = struct{}{}
}

// AllOrderNumCleared returns if the "allOrderNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) AllOrderNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldAllOrderNum]
	return ok
}

// ResetAllOrderNum resets all changes to the "allOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ResetAllOrderNum() {
	m.allOrderNum = nil
	m.addallOrderNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldAllOrderNum)
}

// SetDayUserNum sets the "dayUserNum" field.
func (m *UserAnalysisStatisticsMutation) SetDayUserNum(i int64) {
	m.dayUserNum = &i
	m.adddayUserNum = nil
}

// DayUserNum returns the value of the "dayUserNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayUserNum() (r int64, exists bool) {
	v := m.dayUserNum
	if v == nil {
		return
	}
	return *v, true
}

// OldDayUserNum returns the old "dayUserNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayUserNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayUserNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayUserNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayUserNum: %w", err)
	}
	return oldValue.DayUserNum, nil
}

// AddDayUserNum adds i to the "dayUserNum" field.
func (m *UserAnalysisStatisticsMutation) AddDayUserNum(i int64) {
	if m.adddayUserNum != nil {
		*m.adddayUserNum += i
	} else {
		m.adddayUserNum = &i
	}
}

// AddedDayUserNum returns the value that was added to the "dayUserNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayUserNum() (r int64, exists bool) {
	v := m.adddayUserNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayUserNum clears the value of the "dayUserNum" field.
func (m *UserAnalysisStatisticsMutation) ClearDayUserNum() {
	m.dayUserNum = nil
	m.adddayUserNum = nil
	m.clearedFields[useranalysisstatistics.FieldDayUserNum] = struct{}{}
}

// DayUserNumCleared returns if the "dayUserNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayUserNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayUserNum]
	return ok
}

// ResetDayUserNum resets all changes to the "dayUserNum" field.
func (m *UserAnalysisStatisticsMutation) ResetDayUserNum() {
	m.dayUserNum = nil
	m.adddayUserNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayUserNum)
}

// SetDayPayment sets the "dayPayment" field.
func (m *UserAnalysisStatisticsMutation) SetDayPayment(i int64) {
	m.dayPayment = &i
	m.adddayPayment = nil
}

// DayPayment returns the value of the "dayPayment" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayPayment() (r int64, exists bool) {
	v := m.dayPayment
	if v == nil {
		return
	}
	return *v, true
}

// OldDayPayment returns the old "dayPayment" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayPayment: %w", err)
	}
	return oldValue.DayPayment, nil
}

// AddDayPayment adds i to the "dayPayment" field.
func (m *UserAnalysisStatisticsMutation) AddDayPayment(i int64) {
	if m.adddayPayment != nil {
		*m.adddayPayment += i
	} else {
		m.adddayPayment = &i
	}
}

// AddedDayPayment returns the value that was added to the "dayPayment" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayPayment() (r int64, exists bool) {
	v := m.adddayPayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayPayment clears the value of the "dayPayment" field.
func (m *UserAnalysisStatisticsMutation) ClearDayPayment() {
	m.dayPayment = nil
	m.adddayPayment = nil
	m.clearedFields[useranalysisstatistics.FieldDayPayment] = struct{}{}
}

// DayPaymentCleared returns if the "dayPayment" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayPaymentCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayPayment]
	return ok
}

// ResetDayPayment resets all changes to the "dayPayment" field.
func (m *UserAnalysisStatisticsMutation) ResetDayPayment() {
	m.dayPayment = nil
	m.adddayPayment = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayPayment)
}

// SetDayOrderNum sets the "dayOrderNum" field.
func (m *UserAnalysisStatisticsMutation) SetDayOrderNum(i int64) {
	m.dayOrderNum = &i
	m.adddayOrderNum = nil
}

// DayOrderNum returns the value of the "dayOrderNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayOrderNum() (r int64, exists bool) {
	v := m.dayOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOrderNum returns the old "dayOrderNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayOrderNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOrderNum: %w", err)
	}
	return oldValue.DayOrderNum, nil
}

// AddDayOrderNum adds i to the "dayOrderNum" field.
func (m *UserAnalysisStatisticsMutation) AddDayOrderNum(i int64) {
	if m.adddayOrderNum != nil {
		*m.adddayOrderNum += i
	} else {
		m.adddayOrderNum = &i
	}
}

// AddedDayOrderNum returns the value that was added to the "dayOrderNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayOrderNum() (r int64, exists bool) {
	v := m.adddayOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayOrderNum clears the value of the "dayOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ClearDayOrderNum() {
	m.dayOrderNum = nil
	m.adddayOrderNum = nil
	m.clearedFields[useranalysisstatistics.FieldDayOrderNum] = struct{}{}
}

// DayOrderNumCleared returns if the "dayOrderNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayOrderNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayOrderNum]
	return ok
}

// ResetDayOrderNum resets all changes to the "dayOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ResetDayOrderNum() {
	m.dayOrderNum = nil
	m.adddayOrderNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayOrderNum)
}

// SetDayPayUser sets the "dayPayUser" field.
func (m *UserAnalysisStatisticsMutation) SetDayPayUser(i int64) {
	m.dayPayUser = &i
	m.adddayPayUser = nil
}

// DayPayUser returns the value of the "dayPayUser" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayPayUser() (r int64, exists bool) {
	v := m.dayPayUser
	if v == nil {
		return
	}
	return *v, true
}

// OldDayPayUser returns the old "dayPayUser" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayPayUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayPayUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayPayUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayPayUser: %w", err)
	}
	return oldValue.DayPayUser, nil
}

// AddDayPayUser adds i to the "dayPayUser" field.
func (m *UserAnalysisStatisticsMutation) AddDayPayUser(i int64) {
	if m.adddayPayUser != nil {
		*m.adddayPayUser += i
	} else {
		m.adddayPayUser = &i
	}
}

// AddedDayPayUser returns the value that was added to the "dayPayUser" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayPayUser() (r int64, exists bool) {
	v := m.adddayPayUser
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayPayUser clears the value of the "dayPayUser" field.
func (m *UserAnalysisStatisticsMutation) ClearDayPayUser() {
	m.dayPayUser = nil
	m.adddayPayUser = nil
	m.clearedFields[useranalysisstatistics.FieldDayPayUser] = struct{}{}
}

// DayPayUserCleared returns if the "dayPayUser" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayPayUserCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayPayUser]
	return ok
}

// ResetDayPayUser resets all changes to the "dayPayUser" field.
func (m *UserAnalysisStatisticsMutation) ResetDayPayUser() {
	m.dayPayUser = nil
	m.adddayPayUser = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayPayUser)
}

// SetDayRegPayment sets the "dayRegPayment" field.
func (m *UserAnalysisStatisticsMutation) SetDayRegPayment(i int64) {
	m.dayRegPayment = &i
	m.adddayRegPayment = nil
}

// DayRegPayment returns the value of the "dayRegPayment" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayRegPayment() (r int64, exists bool) {
	v := m.dayRegPayment
	if v == nil {
		return
	}
	return *v, true
}

// OldDayRegPayment returns the old "dayRegPayment" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayRegPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayRegPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayRegPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayRegPayment: %w", err)
	}
	return oldValue.DayRegPayment, nil
}

// AddDayRegPayment adds i to the "dayRegPayment" field.
func (m *UserAnalysisStatisticsMutation) AddDayRegPayment(i int64) {
	if m.adddayRegPayment != nil {
		*m.adddayRegPayment += i
	} else {
		m.adddayRegPayment = &i
	}
}

// AddedDayRegPayment returns the value that was added to the "dayRegPayment" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayRegPayment() (r int64, exists bool) {
	v := m.adddayRegPayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayRegPayment clears the value of the "dayRegPayment" field.
func (m *UserAnalysisStatisticsMutation) ClearDayRegPayment() {
	m.dayRegPayment = nil
	m.adddayRegPayment = nil
	m.clearedFields[useranalysisstatistics.FieldDayRegPayment] = struct{}{}
}

// DayRegPaymentCleared returns if the "dayRegPayment" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayRegPaymentCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayRegPayment]
	return ok
}

// ResetDayRegPayment resets all changes to the "dayRegPayment" field.
func (m *UserAnalysisStatisticsMutation) ResetDayRegPayment() {
	m.dayRegPayment = nil
	m.adddayRegPayment = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayRegPayment)
}

// SetDayRegUserNum sets the "dayRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) SetDayRegUserNum(i int64) {
	m.dayRegUserNum = &i
	m.adddayRegUserNum = nil
}

// DayRegUserNum returns the value of the "dayRegUserNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayRegUserNum() (r int64, exists bool) {
	v := m.dayRegUserNum
	if v == nil {
		return
	}
	return *v, true
}

// OldDayRegUserNum returns the old "dayRegUserNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayRegUserNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayRegUserNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayRegUserNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayRegUserNum: %w", err)
	}
	return oldValue.DayRegUserNum, nil
}

// AddDayRegUserNum adds i to the "dayRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) AddDayRegUserNum(i int64) {
	if m.adddayRegUserNum != nil {
		*m.adddayRegUserNum += i
	} else {
		m.adddayRegUserNum = &i
	}
}

// AddedDayRegUserNum returns the value that was added to the "dayRegUserNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayRegUserNum() (r int64, exists bool) {
	v := m.adddayRegUserNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayRegUserNum clears the value of the "dayRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) ClearDayRegUserNum() {
	m.dayRegUserNum = nil
	m.adddayRegUserNum = nil
	m.clearedFields[useranalysisstatistics.FieldDayRegUserNum] = struct{}{}
}

// DayRegUserNumCleared returns if the "dayRegUserNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayRegUserNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayRegUserNum]
	return ok
}

// ResetDayRegUserNum resets all changes to the "dayRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) ResetDayRegUserNum() {
	m.dayRegUserNum = nil
	m.adddayRegUserNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayRegUserNum)
}

// SetDayRegOrderNum sets the "dayRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) SetDayRegOrderNum(i int64) {
	m.dayRegOrderNum = &i
	m.adddayRegOrderNum = nil
}

// DayRegOrderNum returns the value of the "dayRegOrderNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayRegOrderNum() (r int64, exists bool) {
	v := m.dayRegOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldDayRegOrderNum returns the old "dayRegOrderNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayRegOrderNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayRegOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayRegOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayRegOrderNum: %w", err)
	}
	return oldValue.DayRegOrderNum, nil
}

// AddDayRegOrderNum adds i to the "dayRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) AddDayRegOrderNum(i int64) {
	if m.adddayRegOrderNum != nil {
		*m.adddayRegOrderNum += i
	} else {
		m.adddayRegOrderNum = &i
	}
}

// AddedDayRegOrderNum returns the value that was added to the "dayRegOrderNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayRegOrderNum() (r int64, exists bool) {
	v := m.adddayRegOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayRegOrderNum clears the value of the "dayRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ClearDayRegOrderNum() {
	m.dayRegOrderNum = nil
	m.adddayRegOrderNum = nil
	m.clearedFields[useranalysisstatistics.FieldDayRegOrderNum] = struct{}{}
}

// DayRegOrderNumCleared returns if the "dayRegOrderNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayRegOrderNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayRegOrderNum]
	return ok
}

// ResetDayRegOrderNum resets all changes to the "dayRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ResetDayRegOrderNum() {
	m.dayRegOrderNum = nil
	m.adddayRegOrderNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayRegOrderNum)
}

// SetOldRegPayment sets the "oldRegPayment" field.
func (m *UserAnalysisStatisticsMutation) SetOldRegPayment(i int64) {
	m.oldRegPayment = &i
	m.addoldRegPayment = nil
}

// OldRegPayment returns the value of the "oldRegPayment" field in the mutation.
func (m *UserAnalysisStatisticsMutation) OldRegPayment() (r int64, exists bool) {
	v := m.oldRegPayment
	if v == nil {
		return
	}
	return *v, true
}

// OldOldRegPayment returns the old "oldRegPayment" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldOldRegPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldRegPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldRegPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldRegPayment: %w", err)
	}
	return oldValue.OldRegPayment, nil
}

// AddOldRegPayment adds i to the "oldRegPayment" field.
func (m *UserAnalysisStatisticsMutation) AddOldRegPayment(i int64) {
	if m.addoldRegPayment != nil {
		*m.addoldRegPayment += i
	} else {
		m.addoldRegPayment = &i
	}
}

// AddedOldRegPayment returns the value that was added to the "oldRegPayment" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedOldRegPayment() (r int64, exists bool) {
	v := m.addoldRegPayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearOldRegPayment clears the value of the "oldRegPayment" field.
func (m *UserAnalysisStatisticsMutation) ClearOldRegPayment() {
	m.oldRegPayment = nil
	m.addoldRegPayment = nil
	m.clearedFields[useranalysisstatistics.FieldOldRegPayment] = struct{}{}
}

// OldRegPaymentCleared returns if the "oldRegPayment" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) OldRegPaymentCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldOldRegPayment]
	return ok
}

// ResetOldRegPayment resets all changes to the "oldRegPayment" field.
func (m *UserAnalysisStatisticsMutation) ResetOldRegPayment() {
	m.oldRegPayment = nil
	m.addoldRegPayment = nil
	delete(m.clearedFields, useranalysisstatistics.FieldOldRegPayment)
}

// SetOldRegUserNum sets the "oldRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) SetOldRegUserNum(i int64) {
	m.oldRegUserNum = &i
	m.addoldRegUserNum = nil
}

// OldRegUserNum returns the value of the "oldRegUserNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) OldRegUserNum() (r int64, exists bool) {
	v := m.oldRegUserNum
	if v == nil {
		return
	}
	return *v, true
}

// OldOldRegUserNum returns the old "oldRegUserNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldOldRegUserNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldRegUserNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldRegUserNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldRegUserNum: %w", err)
	}
	return oldValue.OldRegUserNum, nil
}

// AddOldRegUserNum adds i to the "oldRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) AddOldRegUserNum(i int64) {
	if m.addoldRegUserNum != nil {
		*m.addoldRegUserNum += i
	} else {
		m.addoldRegUserNum = &i
	}
}

// AddedOldRegUserNum returns the value that was added to the "oldRegUserNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedOldRegUserNum() (r int64, exists bool) {
	v := m.addoldRegUserNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearOldRegUserNum clears the value of the "oldRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) ClearOldRegUserNum() {
	m.oldRegUserNum = nil
	m.addoldRegUserNum = nil
	m.clearedFields[useranalysisstatistics.FieldOldRegUserNum] = struct{}{}
}

// OldRegUserNumCleared returns if the "oldRegUserNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) OldRegUserNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldOldRegUserNum]
	return ok
}

// ResetOldRegUserNum resets all changes to the "oldRegUserNum" field.
func (m *UserAnalysisStatisticsMutation) ResetOldRegUserNum() {
	m.oldRegUserNum = nil
	m.addoldRegUserNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldOldRegUserNum)
}

// SetOldRegOrderNum sets the "oldRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) SetOldRegOrderNum(i int64) {
	m.oldRegOrderNum = &i
	m.addoldRegOrderNum = nil
}

// OldRegOrderNum returns the value of the "oldRegOrderNum" field in the mutation.
func (m *UserAnalysisStatisticsMutation) OldRegOrderNum() (r int64, exists bool) {
	v := m.oldRegOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldOldRegOrderNum returns the old "oldRegOrderNum" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldOldRegOrderNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldRegOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldRegOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldRegOrderNum: %w", err)
	}
	return oldValue.OldRegOrderNum, nil
}

// AddOldRegOrderNum adds i to the "oldRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) AddOldRegOrderNum(i int64) {
	if m.addoldRegOrderNum != nil {
		*m.addoldRegOrderNum += i
	} else {
		m.addoldRegOrderNum = &i
	}
}

// AddedOldRegOrderNum returns the value that was added to the "oldRegOrderNum" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedOldRegOrderNum() (r int64, exists bool) {
	v := m.addoldRegOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearOldRegOrderNum clears the value of the "oldRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ClearOldRegOrderNum() {
	m.oldRegOrderNum = nil
	m.addoldRegOrderNum = nil
	m.clearedFields[useranalysisstatistics.FieldOldRegOrderNum] = struct{}{}
}

// OldRegOrderNumCleared returns if the "oldRegOrderNum" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) OldRegOrderNumCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldOldRegOrderNum]
	return ok
}

// ResetOldRegOrderNum resets all changes to the "oldRegOrderNum" field.
func (m *UserAnalysisStatisticsMutation) ResetOldRegOrderNum() {
	m.oldRegOrderNum = nil
	m.addoldRegOrderNum = nil
	delete(m.clearedFields, useranalysisstatistics.FieldOldRegOrderNum)
}

// SetPayRate sets the "payRate" field.
func (m *UserAnalysisStatisticsMutation) SetPayRate(i int64) {
	m.payRate = &i
	m.addpayRate = nil
}

// PayRate returns the value of the "payRate" field in the mutation.
func (m *UserAnalysisStatisticsMutation) PayRate() (r int64, exists bool) {
	v := m.payRate
	if v == nil {
		return
	}
	return *v, true
}

// OldPayRate returns the old "payRate" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldPayRate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayRate: %w", err)
	}
	return oldValue.PayRate, nil
}

// AddPayRate adds i to the "payRate" field.
func (m *UserAnalysisStatisticsMutation) AddPayRate(i int64) {
	if m.addpayRate != nil {
		*m.addpayRate += i
	} else {
		m.addpayRate = &i
	}
}

// AddedPayRate returns the value that was added to the "payRate" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedPayRate() (r int64, exists bool) {
	v := m.addpayRate
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayRate clears the value of the "payRate" field.
func (m *UserAnalysisStatisticsMutation) ClearPayRate() {
	m.payRate = nil
	m.addpayRate = nil
	m.clearedFields[useranalysisstatistics.FieldPayRate] = struct{}{}
}

// PayRateCleared returns if the "payRate" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) PayRateCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldPayRate]
	return ok
}

// ResetPayRate resets all changes to the "payRate" field.
func (m *UserAnalysisStatisticsMutation) ResetPayRate() {
	m.payRate = nil
	m.addpayRate = nil
	delete(m.clearedFields, useranalysisstatistics.FieldPayRate)
}

// SetArpu sets the "arpu" field.
func (m *UserAnalysisStatisticsMutation) SetArpu(i int64) {
	m.arpu = &i
	m.addarpu = nil
}

// Arpu returns the value of the "arpu" field in the mutation.
func (m *UserAnalysisStatisticsMutation) Arpu() (r int64, exists bool) {
	v := m.arpu
	if v == nil {
		return
	}
	return *v, true
}

// OldArpu returns the old "arpu" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldArpu(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArpu: %w", err)
	}
	return oldValue.Arpu, nil
}

// AddArpu adds i to the "arpu" field.
func (m *UserAnalysisStatisticsMutation) AddArpu(i int64) {
	if m.addarpu != nil {
		*m.addarpu += i
	} else {
		m.addarpu = &i
	}
}

// AddedArpu returns the value that was added to the "arpu" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedArpu() (r int64, exists bool) {
	v := m.addarpu
	if v == nil {
		return
	}
	return *v, true
}

// ClearArpu clears the value of the "arpu" field.
func (m *UserAnalysisStatisticsMutation) ClearArpu() {
	m.arpu = nil
	m.addarpu = nil
	m.clearedFields[useranalysisstatistics.FieldArpu] = struct{}{}
}

// ArpuCleared returns if the "arpu" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) ArpuCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldArpu]
	return ok
}

// ResetArpu resets all changes to the "arpu" field.
func (m *UserAnalysisStatisticsMutation) ResetArpu() {
	m.arpu = nil
	m.addarpu = nil
	delete(m.clearedFields, useranalysisstatistics.FieldArpu)
}

// SetDayRegArpu sets the "dayRegArpu" field.
func (m *UserAnalysisStatisticsMutation) SetDayRegArpu(i int64) {
	m.dayRegArpu = &i
	m.adddayRegArpu = nil
}

// DayRegArpu returns the value of the "dayRegArpu" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayRegArpu() (r int64, exists bool) {
	v := m.dayRegArpu
	if v == nil {
		return
	}
	return *v, true
}

// OldDayRegArpu returns the old "dayRegArpu" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayRegArpu(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayRegArpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayRegArpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayRegArpu: %w", err)
	}
	return oldValue.DayRegArpu, nil
}

// AddDayRegArpu adds i to the "dayRegArpu" field.
func (m *UserAnalysisStatisticsMutation) AddDayRegArpu(i int64) {
	if m.adddayRegArpu != nil {
		*m.adddayRegArpu += i
	} else {
		m.adddayRegArpu = &i
	}
}

// AddedDayRegArpu returns the value that was added to the "dayRegArpu" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayRegArpu() (r int64, exists bool) {
	v := m.adddayRegArpu
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayRegArpu clears the value of the "dayRegArpu" field.
func (m *UserAnalysisStatisticsMutation) ClearDayRegArpu() {
	m.dayRegArpu = nil
	m.adddayRegArpu = nil
	m.clearedFields[useranalysisstatistics.FieldDayRegArpu] = struct{}{}
}

// DayRegArpuCleared returns if the "dayRegArpu" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayRegArpuCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayRegArpu]
	return ok
}

// ResetDayRegArpu resets all changes to the "dayRegArpu" field.
func (m *UserAnalysisStatisticsMutation) ResetDayRegArpu() {
	m.dayRegArpu = nil
	m.adddayRegArpu = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayRegArpu)
}

// SetDayArpu sets the "dayArpu" field.
func (m *UserAnalysisStatisticsMutation) SetDayArpu(i int64) {
	m.dayArpu = &i
	m.adddayArpu = nil
}

// DayArpu returns the value of the "dayArpu" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayArpu() (r int64, exists bool) {
	v := m.dayArpu
	if v == nil {
		return
	}
	return *v, true
}

// OldDayArpu returns the old "dayArpu" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayArpu(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayArpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayArpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayArpu: %w", err)
	}
	return oldValue.DayArpu, nil
}

// AddDayArpu adds i to the "dayArpu" field.
func (m *UserAnalysisStatisticsMutation) AddDayArpu(i int64) {
	if m.adddayArpu != nil {
		*m.adddayArpu += i
	} else {
		m.adddayArpu = &i
	}
}

// AddedDayArpu returns the value that was added to the "dayArpu" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayArpu() (r int64, exists bool) {
	v := m.adddayArpu
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayArpu clears the value of the "dayArpu" field.
func (m *UserAnalysisStatisticsMutation) ClearDayArpu() {
	m.dayArpu = nil
	m.adddayArpu = nil
	m.clearedFields[useranalysisstatistics.FieldDayArpu] = struct{}{}
}

// DayArpuCleared returns if the "dayArpu" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayArpuCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayArpu]
	return ok
}

// ResetDayArpu resets all changes to the "dayArpu" field.
func (m *UserAnalysisStatisticsMutation) ResetDayArpu() {
	m.dayArpu = nil
	m.adddayArpu = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayArpu)
}

// SetDayOldArpu sets the "dayOldArpu" field.
func (m *UserAnalysisStatisticsMutation) SetDayOldArpu(i int64) {
	m.dayOldArpu = &i
	m.adddayOldArpu = nil
}

// DayOldArpu returns the value of the "dayOldArpu" field in the mutation.
func (m *UserAnalysisStatisticsMutation) DayOldArpu() (r int64, exists bool) {
	v := m.dayOldArpu
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOldArpu returns the old "dayOldArpu" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldDayOldArpu(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOldArpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOldArpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOldArpu: %w", err)
	}
	return oldValue.DayOldArpu, nil
}

// AddDayOldArpu adds i to the "dayOldArpu" field.
func (m *UserAnalysisStatisticsMutation) AddDayOldArpu(i int64) {
	if m.adddayOldArpu != nil {
		*m.adddayOldArpu += i
	} else {
		m.adddayOldArpu = &i
	}
}

// AddedDayOldArpu returns the value that was added to the "dayOldArpu" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedDayOldArpu() (r int64, exists bool) {
	v := m.adddayOldArpu
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayOldArpu clears the value of the "dayOldArpu" field.
func (m *UserAnalysisStatisticsMutation) ClearDayOldArpu() {
	m.dayOldArpu = nil
	m.adddayOldArpu = nil
	m.clearedFields[useranalysisstatistics.FieldDayOldArpu] = struct{}{}
}

// DayOldArpuCleared returns if the "dayOldArpu" field was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) DayOldArpuCleared() bool {
	_, ok := m.clearedFields[useranalysisstatistics.FieldDayOldArpu]
	return ok
}

// ResetDayOldArpu resets all changes to the "dayOldArpu" field.
func (m *UserAnalysisStatisticsMutation) ResetDayOldArpu() {
	m.dayOldArpu = nil
	m.adddayOldArpu = nil
	delete(m.clearedFields, useranalysisstatistics.FieldDayOldArpu)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserAnalysisStatisticsMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserAnalysisStatisticsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserAnalysisStatisticsMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserAnalysisStatisticsMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserAnalysisStatisticsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserAnalysisStatisticsMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserAnalysisStatisticsMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserAnalysisStatisticsMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *UserAnalysisStatisticsMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserAnalysisStatisticsMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserAnalysisStatisticsMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserAnalysisStatisticsMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *UserAnalysisStatisticsMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserAnalysisStatisticsMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *UserAnalysisStatisticsMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *UserAnalysisStatisticsMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the UserAnalysisStatistics entity.
// If the UserAnalysisStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAnalysisStatisticsMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *UserAnalysisStatisticsMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *UserAnalysisStatisticsMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the UserAnalysisStatisticsMutation builder.
func (m *UserAnalysisStatisticsMutation) Where(ps ...predicate.UserAnalysisStatistics) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserAnalysisStatisticsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserAnalysisStatistics).
func (m *UserAnalysisStatisticsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAnalysisStatisticsMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.statisticsDate != nil {
		fields = append(fields, useranalysisstatistics.FieldStatisticsDate)
	}
	if m.allUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldAllUserNum)
	}
	if m.allPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldAllPayment)
	}
	if m.allPayUser != nil {
		fields = append(fields, useranalysisstatistics.FieldAllPayUser)
	}
	if m.allOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldAllOrderNum)
	}
	if m.dayUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayUserNum)
	}
	if m.dayPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldDayPayment)
	}
	if m.dayOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayOrderNum)
	}
	if m.dayPayUser != nil {
		fields = append(fields, useranalysisstatistics.FieldDayPayUser)
	}
	if m.dayRegPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegPayment)
	}
	if m.dayRegUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegUserNum)
	}
	if m.dayRegOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegOrderNum)
	}
	if m.oldRegPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldOldRegPayment)
	}
	if m.oldRegUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldOldRegUserNum)
	}
	if m.oldRegOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldOldRegOrderNum)
	}
	if m.payRate != nil {
		fields = append(fields, useranalysisstatistics.FieldPayRate)
	}
	if m.arpu != nil {
		fields = append(fields, useranalysisstatistics.FieldArpu)
	}
	if m.dayRegArpu != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegArpu)
	}
	if m.dayArpu != nil {
		fields = append(fields, useranalysisstatistics.FieldDayArpu)
	}
	if m.dayOldArpu != nil {
		fields = append(fields, useranalysisstatistics.FieldDayOldArpu)
	}
	if m.createdAt != nil {
		fields = append(fields, useranalysisstatistics.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, useranalysisstatistics.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, useranalysisstatistics.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, useranalysisstatistics.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, useranalysisstatistics.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAnalysisStatisticsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useranalysisstatistics.FieldStatisticsDate:
		return m.StatisticsDate()
	case useranalysisstatistics.FieldAllUserNum:
		return m.AllUserNum()
	case useranalysisstatistics.FieldAllPayment:
		return m.AllPayment()
	case useranalysisstatistics.FieldAllPayUser:
		return m.AllPayUser()
	case useranalysisstatistics.FieldAllOrderNum:
		return m.AllOrderNum()
	case useranalysisstatistics.FieldDayUserNum:
		return m.DayUserNum()
	case useranalysisstatistics.FieldDayPayment:
		return m.DayPayment()
	case useranalysisstatistics.FieldDayOrderNum:
		return m.DayOrderNum()
	case useranalysisstatistics.FieldDayPayUser:
		return m.DayPayUser()
	case useranalysisstatistics.FieldDayRegPayment:
		return m.DayRegPayment()
	case useranalysisstatistics.FieldDayRegUserNum:
		return m.DayRegUserNum()
	case useranalysisstatistics.FieldDayRegOrderNum:
		return m.DayRegOrderNum()
	case useranalysisstatistics.FieldOldRegPayment:
		return m.OldRegPayment()
	case useranalysisstatistics.FieldOldRegUserNum:
		return m.OldRegUserNum()
	case useranalysisstatistics.FieldOldRegOrderNum:
		return m.OldRegOrderNum()
	case useranalysisstatistics.FieldPayRate:
		return m.PayRate()
	case useranalysisstatistics.FieldArpu:
		return m.Arpu()
	case useranalysisstatistics.FieldDayRegArpu:
		return m.DayRegArpu()
	case useranalysisstatistics.FieldDayArpu:
		return m.DayArpu()
	case useranalysisstatistics.FieldDayOldArpu:
		return m.DayOldArpu()
	case useranalysisstatistics.FieldCreatedAt:
		return m.CreatedAt()
	case useranalysisstatistics.FieldUpdatedAt:
		return m.UpdatedAt()
	case useranalysisstatistics.FieldCreateBy:
		return m.CreateBy()
	case useranalysisstatistics.FieldUpdateBy:
		return m.UpdateBy()
	case useranalysisstatistics.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAnalysisStatisticsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useranalysisstatistics.FieldStatisticsDate:
		return m.OldStatisticsDate(ctx)
	case useranalysisstatistics.FieldAllUserNum:
		return m.OldAllUserNum(ctx)
	case useranalysisstatistics.FieldAllPayment:
		return m.OldAllPayment(ctx)
	case useranalysisstatistics.FieldAllPayUser:
		return m.OldAllPayUser(ctx)
	case useranalysisstatistics.FieldAllOrderNum:
		return m.OldAllOrderNum(ctx)
	case useranalysisstatistics.FieldDayUserNum:
		return m.OldDayUserNum(ctx)
	case useranalysisstatistics.FieldDayPayment:
		return m.OldDayPayment(ctx)
	case useranalysisstatistics.FieldDayOrderNum:
		return m.OldDayOrderNum(ctx)
	case useranalysisstatistics.FieldDayPayUser:
		return m.OldDayPayUser(ctx)
	case useranalysisstatistics.FieldDayRegPayment:
		return m.OldDayRegPayment(ctx)
	case useranalysisstatistics.FieldDayRegUserNum:
		return m.OldDayRegUserNum(ctx)
	case useranalysisstatistics.FieldDayRegOrderNum:
		return m.OldDayRegOrderNum(ctx)
	case useranalysisstatistics.FieldOldRegPayment:
		return m.OldOldRegPayment(ctx)
	case useranalysisstatistics.FieldOldRegUserNum:
		return m.OldOldRegUserNum(ctx)
	case useranalysisstatistics.FieldOldRegOrderNum:
		return m.OldOldRegOrderNum(ctx)
	case useranalysisstatistics.FieldPayRate:
		return m.OldPayRate(ctx)
	case useranalysisstatistics.FieldArpu:
		return m.OldArpu(ctx)
	case useranalysisstatistics.FieldDayRegArpu:
		return m.OldDayRegArpu(ctx)
	case useranalysisstatistics.FieldDayArpu:
		return m.OldDayArpu(ctx)
	case useranalysisstatistics.FieldDayOldArpu:
		return m.OldDayOldArpu(ctx)
	case useranalysisstatistics.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useranalysisstatistics.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useranalysisstatistics.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case useranalysisstatistics.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case useranalysisstatistics.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown UserAnalysisStatistics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAnalysisStatisticsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useranalysisstatistics.FieldStatisticsDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatisticsDate(v)
		return nil
	case useranalysisstatistics.FieldAllUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllUserNum(v)
		return nil
	case useranalysisstatistics.FieldAllPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllPayment(v)
		return nil
	case useranalysisstatistics.FieldAllPayUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllPayUser(v)
		return nil
	case useranalysisstatistics.FieldAllOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllOrderNum(v)
		return nil
	case useranalysisstatistics.FieldDayUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayUserNum(v)
		return nil
	case useranalysisstatistics.FieldDayPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayPayment(v)
		return nil
	case useranalysisstatistics.FieldDayOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOrderNum(v)
		return nil
	case useranalysisstatistics.FieldDayPayUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayPayUser(v)
		return nil
	case useranalysisstatistics.FieldDayRegPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayRegPayment(v)
		return nil
	case useranalysisstatistics.FieldDayRegUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayRegUserNum(v)
		return nil
	case useranalysisstatistics.FieldDayRegOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayRegOrderNum(v)
		return nil
	case useranalysisstatistics.FieldOldRegPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldRegPayment(v)
		return nil
	case useranalysisstatistics.FieldOldRegUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldRegUserNum(v)
		return nil
	case useranalysisstatistics.FieldOldRegOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldRegOrderNum(v)
		return nil
	case useranalysisstatistics.FieldPayRate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayRate(v)
		return nil
	case useranalysisstatistics.FieldArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArpu(v)
		return nil
	case useranalysisstatistics.FieldDayRegArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayRegArpu(v)
		return nil
	case useranalysisstatistics.FieldDayArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayArpu(v)
		return nil
	case useranalysisstatistics.FieldDayOldArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOldArpu(v)
		return nil
	case useranalysisstatistics.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useranalysisstatistics.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useranalysisstatistics.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case useranalysisstatistics.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case useranalysisstatistics.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserAnalysisStatistics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAnalysisStatisticsMutation) AddedFields() []string {
	var fields []string
	if m.addallUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldAllUserNum)
	}
	if m.addallPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldAllPayment)
	}
	if m.addallPayUser != nil {
		fields = append(fields, useranalysisstatistics.FieldAllPayUser)
	}
	if m.addallOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldAllOrderNum)
	}
	if m.adddayUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayUserNum)
	}
	if m.adddayPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldDayPayment)
	}
	if m.adddayOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayOrderNum)
	}
	if m.adddayPayUser != nil {
		fields = append(fields, useranalysisstatistics.FieldDayPayUser)
	}
	if m.adddayRegPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegPayment)
	}
	if m.adddayRegUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegUserNum)
	}
	if m.adddayRegOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegOrderNum)
	}
	if m.addoldRegPayment != nil {
		fields = append(fields, useranalysisstatistics.FieldOldRegPayment)
	}
	if m.addoldRegUserNum != nil {
		fields = append(fields, useranalysisstatistics.FieldOldRegUserNum)
	}
	if m.addoldRegOrderNum != nil {
		fields = append(fields, useranalysisstatistics.FieldOldRegOrderNum)
	}
	if m.addpayRate != nil {
		fields = append(fields, useranalysisstatistics.FieldPayRate)
	}
	if m.addarpu != nil {
		fields = append(fields, useranalysisstatistics.FieldArpu)
	}
	if m.adddayRegArpu != nil {
		fields = append(fields, useranalysisstatistics.FieldDayRegArpu)
	}
	if m.adddayArpu != nil {
		fields = append(fields, useranalysisstatistics.FieldDayArpu)
	}
	if m.adddayOldArpu != nil {
		fields = append(fields, useranalysisstatistics.FieldDayOldArpu)
	}
	if m.addcreateBy != nil {
		fields = append(fields, useranalysisstatistics.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, useranalysisstatistics.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, useranalysisstatistics.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAnalysisStatisticsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useranalysisstatistics.FieldAllUserNum:
		return m.AddedAllUserNum()
	case useranalysisstatistics.FieldAllPayment:
		return m.AddedAllPayment()
	case useranalysisstatistics.FieldAllPayUser:
		return m.AddedAllPayUser()
	case useranalysisstatistics.FieldAllOrderNum:
		return m.AddedAllOrderNum()
	case useranalysisstatistics.FieldDayUserNum:
		return m.AddedDayUserNum()
	case useranalysisstatistics.FieldDayPayment:
		return m.AddedDayPayment()
	case useranalysisstatistics.FieldDayOrderNum:
		return m.AddedDayOrderNum()
	case useranalysisstatistics.FieldDayPayUser:
		return m.AddedDayPayUser()
	case useranalysisstatistics.FieldDayRegPayment:
		return m.AddedDayRegPayment()
	case useranalysisstatistics.FieldDayRegUserNum:
		return m.AddedDayRegUserNum()
	case useranalysisstatistics.FieldDayRegOrderNum:
		return m.AddedDayRegOrderNum()
	case useranalysisstatistics.FieldOldRegPayment:
		return m.AddedOldRegPayment()
	case useranalysisstatistics.FieldOldRegUserNum:
		return m.AddedOldRegUserNum()
	case useranalysisstatistics.FieldOldRegOrderNum:
		return m.AddedOldRegOrderNum()
	case useranalysisstatistics.FieldPayRate:
		return m.AddedPayRate()
	case useranalysisstatistics.FieldArpu:
		return m.AddedArpu()
	case useranalysisstatistics.FieldDayRegArpu:
		return m.AddedDayRegArpu()
	case useranalysisstatistics.FieldDayArpu:
		return m.AddedDayArpu()
	case useranalysisstatistics.FieldDayOldArpu:
		return m.AddedDayOldArpu()
	case useranalysisstatistics.FieldCreateBy:
		return m.AddedCreateBy()
	case useranalysisstatistics.FieldUpdateBy:
		return m.AddedUpdateBy()
	case useranalysisstatistics.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAnalysisStatisticsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useranalysisstatistics.FieldAllUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllUserNum(v)
		return nil
	case useranalysisstatistics.FieldAllPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllPayment(v)
		return nil
	case useranalysisstatistics.FieldAllPayUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllPayUser(v)
		return nil
	case useranalysisstatistics.FieldAllOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllOrderNum(v)
		return nil
	case useranalysisstatistics.FieldDayUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayUserNum(v)
		return nil
	case useranalysisstatistics.FieldDayPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayPayment(v)
		return nil
	case useranalysisstatistics.FieldDayOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayOrderNum(v)
		return nil
	case useranalysisstatistics.FieldDayPayUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayPayUser(v)
		return nil
	case useranalysisstatistics.FieldDayRegPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayRegPayment(v)
		return nil
	case useranalysisstatistics.FieldDayRegUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayRegUserNum(v)
		return nil
	case useranalysisstatistics.FieldDayRegOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayRegOrderNum(v)
		return nil
	case useranalysisstatistics.FieldOldRegPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOldRegPayment(v)
		return nil
	case useranalysisstatistics.FieldOldRegUserNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOldRegUserNum(v)
		return nil
	case useranalysisstatistics.FieldOldRegOrderNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOldRegOrderNum(v)
		return nil
	case useranalysisstatistics.FieldPayRate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayRate(v)
		return nil
	case useranalysisstatistics.FieldArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArpu(v)
		return nil
	case useranalysisstatistics.FieldDayRegArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayRegArpu(v)
		return nil
	case useranalysisstatistics.FieldDayArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayArpu(v)
		return nil
	case useranalysisstatistics.FieldDayOldArpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayOldArpu(v)
		return nil
	case useranalysisstatistics.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case useranalysisstatistics.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case useranalysisstatistics.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserAnalysisStatistics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAnalysisStatisticsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useranalysisstatistics.FieldAllUserNum) {
		fields = append(fields, useranalysisstatistics.FieldAllUserNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldAllPayment) {
		fields = append(fields, useranalysisstatistics.FieldAllPayment)
	}
	if m.FieldCleared(useranalysisstatistics.FieldAllPayUser) {
		fields = append(fields, useranalysisstatistics.FieldAllPayUser)
	}
	if m.FieldCleared(useranalysisstatistics.FieldAllOrderNum) {
		fields = append(fields, useranalysisstatistics.FieldAllOrderNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayUserNum) {
		fields = append(fields, useranalysisstatistics.FieldDayUserNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayPayment) {
		fields = append(fields, useranalysisstatistics.FieldDayPayment)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayOrderNum) {
		fields = append(fields, useranalysisstatistics.FieldDayOrderNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayPayUser) {
		fields = append(fields, useranalysisstatistics.FieldDayPayUser)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayRegPayment) {
		fields = append(fields, useranalysisstatistics.FieldDayRegPayment)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayRegUserNum) {
		fields = append(fields, useranalysisstatistics.FieldDayRegUserNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayRegOrderNum) {
		fields = append(fields, useranalysisstatistics.FieldDayRegOrderNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldOldRegPayment) {
		fields = append(fields, useranalysisstatistics.FieldOldRegPayment)
	}
	if m.FieldCleared(useranalysisstatistics.FieldOldRegUserNum) {
		fields = append(fields, useranalysisstatistics.FieldOldRegUserNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldOldRegOrderNum) {
		fields = append(fields, useranalysisstatistics.FieldOldRegOrderNum)
	}
	if m.FieldCleared(useranalysisstatistics.FieldPayRate) {
		fields = append(fields, useranalysisstatistics.FieldPayRate)
	}
	if m.FieldCleared(useranalysisstatistics.FieldArpu) {
		fields = append(fields, useranalysisstatistics.FieldArpu)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayRegArpu) {
		fields = append(fields, useranalysisstatistics.FieldDayRegArpu)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayArpu) {
		fields = append(fields, useranalysisstatistics.FieldDayArpu)
	}
	if m.FieldCleared(useranalysisstatistics.FieldDayOldArpu) {
		fields = append(fields, useranalysisstatistics.FieldDayOldArpu)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAnalysisStatisticsMutation) ClearField(name string) error {
	switch name {
	case useranalysisstatistics.FieldAllUserNum:
		m.ClearAllUserNum()
		return nil
	case useranalysisstatistics.FieldAllPayment:
		m.ClearAllPayment()
		return nil
	case useranalysisstatistics.FieldAllPayUser:
		m.ClearAllPayUser()
		return nil
	case useranalysisstatistics.FieldAllOrderNum:
		m.ClearAllOrderNum()
		return nil
	case useranalysisstatistics.FieldDayUserNum:
		m.ClearDayUserNum()
		return nil
	case useranalysisstatistics.FieldDayPayment:
		m.ClearDayPayment()
		return nil
	case useranalysisstatistics.FieldDayOrderNum:
		m.ClearDayOrderNum()
		return nil
	case useranalysisstatistics.FieldDayPayUser:
		m.ClearDayPayUser()
		return nil
	case useranalysisstatistics.FieldDayRegPayment:
		m.ClearDayRegPayment()
		return nil
	case useranalysisstatistics.FieldDayRegUserNum:
		m.ClearDayRegUserNum()
		return nil
	case useranalysisstatistics.FieldDayRegOrderNum:
		m.ClearDayRegOrderNum()
		return nil
	case useranalysisstatistics.FieldOldRegPayment:
		m.ClearOldRegPayment()
		return nil
	case useranalysisstatistics.FieldOldRegUserNum:
		m.ClearOldRegUserNum()
		return nil
	case useranalysisstatistics.FieldOldRegOrderNum:
		m.ClearOldRegOrderNum()
		return nil
	case useranalysisstatistics.FieldPayRate:
		m.ClearPayRate()
		return nil
	case useranalysisstatistics.FieldArpu:
		m.ClearArpu()
		return nil
	case useranalysisstatistics.FieldDayRegArpu:
		m.ClearDayRegArpu()
		return nil
	case useranalysisstatistics.FieldDayArpu:
		m.ClearDayArpu()
		return nil
	case useranalysisstatistics.FieldDayOldArpu:
		m.ClearDayOldArpu()
		return nil
	}
	return fmt.Errorf("unknown UserAnalysisStatistics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAnalysisStatisticsMutation) ResetField(name string) error {
	switch name {
	case useranalysisstatistics.FieldStatisticsDate:
		m.ResetStatisticsDate()
		return nil
	case useranalysisstatistics.FieldAllUserNum:
		m.ResetAllUserNum()
		return nil
	case useranalysisstatistics.FieldAllPayment:
		m.ResetAllPayment()
		return nil
	case useranalysisstatistics.FieldAllPayUser:
		m.ResetAllPayUser()
		return nil
	case useranalysisstatistics.FieldAllOrderNum:
		m.ResetAllOrderNum()
		return nil
	case useranalysisstatistics.FieldDayUserNum:
		m.ResetDayUserNum()
		return nil
	case useranalysisstatistics.FieldDayPayment:
		m.ResetDayPayment()
		return nil
	case useranalysisstatistics.FieldDayOrderNum:
		m.ResetDayOrderNum()
		return nil
	case useranalysisstatistics.FieldDayPayUser:
		m.ResetDayPayUser()
		return nil
	case useranalysisstatistics.FieldDayRegPayment:
		m.ResetDayRegPayment()
		return nil
	case useranalysisstatistics.FieldDayRegUserNum:
		m.ResetDayRegUserNum()
		return nil
	case useranalysisstatistics.FieldDayRegOrderNum:
		m.ResetDayRegOrderNum()
		return nil
	case useranalysisstatistics.FieldOldRegPayment:
		m.ResetOldRegPayment()
		return nil
	case useranalysisstatistics.FieldOldRegUserNum:
		m.ResetOldRegUserNum()
		return nil
	case useranalysisstatistics.FieldOldRegOrderNum:
		m.ResetOldRegOrderNum()
		return nil
	case useranalysisstatistics.FieldPayRate:
		m.ResetPayRate()
		return nil
	case useranalysisstatistics.FieldArpu:
		m.ResetArpu()
		return nil
	case useranalysisstatistics.FieldDayRegArpu:
		m.ResetDayRegArpu()
		return nil
	case useranalysisstatistics.FieldDayArpu:
		m.ResetDayArpu()
		return nil
	case useranalysisstatistics.FieldDayOldArpu:
		m.ResetDayOldArpu()
		return nil
	case useranalysisstatistics.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useranalysisstatistics.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useranalysisstatistics.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case useranalysisstatistics.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case useranalysisstatistics.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown UserAnalysisStatistics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAnalysisStatisticsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAnalysisStatisticsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAnalysisStatisticsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAnalysisStatisticsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAnalysisStatisticsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserAnalysisStatistics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAnalysisStatisticsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserAnalysisStatistics edge %s", name)
}

// UserConsumeMutation represents an operation that mutates the UserConsume nodes in the graph.
type UserConsumeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	novelId       *int64
	addnovelId    *int64
	coin          *int64
	addcoin       *int64
	coupon        *int64
	addcoupon     *int64
	discount      *int64
	adddiscount   *int64
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserConsume, error)
	predicates    []predicate.UserConsume
}

var _ ent.Mutation = (*UserConsumeMutation)(nil)

// userconsumeOption allows management of the mutation configuration using functional options.
type userconsumeOption func(*UserConsumeMutation)

// newUserConsumeMutation creates new mutation for the UserConsume entity.
func newUserConsumeMutation(c config, op Op, opts ...userconsumeOption) *UserConsumeMutation {
	m := &UserConsumeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserConsume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserConsumeID sets the ID field of the mutation.
func withUserConsumeID(id int64) userconsumeOption {
	return func(m *UserConsumeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserConsume
		)
		m.oldValue = func(ctx context.Context) (*UserConsume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserConsume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserConsume sets the old UserConsume of the mutation.
func withUserConsume(node *UserConsume) userconsumeOption {
	return func(m *UserConsumeMutation) {
		m.oldValue = func(context.Context) (*UserConsume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserConsumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserConsumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserConsumeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserConsumeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserConsume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNovelId sets the "novelId" field.
func (m *UserConsumeMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *UserConsumeMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *UserConsumeMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *UserConsumeMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *UserConsumeMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
}

// SetCoin sets the "coin" field.
func (m *UserConsumeMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *UserConsumeMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *UserConsumeMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *UserConsumeMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoin clears the value of the "coin" field.
func (m *UserConsumeMutation) ClearCoin() {
	m.coin = nil
	m.addcoin = nil
	m.clearedFields[userconsume.FieldCoin] = struct{}{}
}

// CoinCleared returns if the "coin" field was cleared in this mutation.
func (m *UserConsumeMutation) CoinCleared() bool {
	_, ok := m.clearedFields[userconsume.FieldCoin]
	return ok
}

// ResetCoin resets all changes to the "coin" field.
func (m *UserConsumeMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
	delete(m.clearedFields, userconsume.FieldCoin)
}

// SetCoupon sets the "coupon" field.
func (m *UserConsumeMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *UserConsumeMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *UserConsumeMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *UserConsumeMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoupon clears the value of the "coupon" field.
func (m *UserConsumeMutation) ClearCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	m.clearedFields[userconsume.FieldCoupon] = struct{}{}
}

// CouponCleared returns if the "coupon" field was cleared in this mutation.
func (m *UserConsumeMutation) CouponCleared() bool {
	_, ok := m.clearedFields[userconsume.FieldCoupon]
	return ok
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *UserConsumeMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	delete(m.clearedFields, userconsume.FieldCoupon)
}

// SetDiscount sets the "discount" field.
func (m *UserConsumeMutation) SetDiscount(i int64) {
	m.discount = &i
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *UserConsumeMutation) Discount() (r int64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldDiscount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds i to the "discount" field.
func (m *UserConsumeMutation) AddDiscount(i int64) {
	if m.adddiscount != nil {
		*m.adddiscount += i
	} else {
		m.adddiscount = &i
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *UserConsumeMutation) AddedDiscount() (r int64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiscount clears the value of the "discount" field.
func (m *UserConsumeMutation) ClearDiscount() {
	m.discount = nil
	m.adddiscount = nil
	m.clearedFields[userconsume.FieldDiscount] = struct{}{}
}

// DiscountCleared returns if the "discount" field was cleared in this mutation.
func (m *UserConsumeMutation) DiscountCleared() bool {
	_, ok := m.clearedFields[userconsume.FieldDiscount]
	return ok
}

// ResetDiscount resets all changes to the "discount" field.
func (m *UserConsumeMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
	delete(m.clearedFields, userconsume.FieldDiscount)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserConsumeMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserConsumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserConsumeMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserConsumeMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserConsumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserConsumeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserConsumeMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserConsumeMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *UserConsumeMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *UserConsumeMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserConsumeMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserConsumeMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserConsumeMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *UserConsumeMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *UserConsumeMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserConsumeMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *UserConsumeMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *UserConsumeMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the UserConsume entity.
// If the UserConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsumeMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *UserConsumeMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *UserConsumeMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *UserConsumeMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the UserConsumeMutation builder.
func (m *UserConsumeMutation) Where(ps ...predicate.UserConsume) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserConsumeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserConsume).
func (m *UserConsumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserConsumeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.novelId != nil {
		fields = append(fields, userconsume.FieldNovelId)
	}
	if m.coin != nil {
		fields = append(fields, userconsume.FieldCoin)
	}
	if m.coupon != nil {
		fields = append(fields, userconsume.FieldCoupon)
	}
	if m.discount != nil {
		fields = append(fields, userconsume.FieldDiscount)
	}
	if m.createdAt != nil {
		fields = append(fields, userconsume.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userconsume.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, userconsume.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, userconsume.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, userconsume.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserConsumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userconsume.FieldNovelId:
		return m.NovelId()
	case userconsume.FieldCoin:
		return m.Coin()
	case userconsume.FieldCoupon:
		return m.Coupon()
	case userconsume.FieldDiscount:
		return m.Discount()
	case userconsume.FieldCreatedAt:
		return m.CreatedAt()
	case userconsume.FieldUpdatedAt:
		return m.UpdatedAt()
	case userconsume.FieldCreateBy:
		return m.CreateBy()
	case userconsume.FieldUpdateBy:
		return m.UpdateBy()
	case userconsume.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserConsumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userconsume.FieldNovelId:
		return m.OldNovelId(ctx)
	case userconsume.FieldCoin:
		return m.OldCoin(ctx)
	case userconsume.FieldCoupon:
		return m.OldCoupon(ctx)
	case userconsume.FieldDiscount:
		return m.OldDiscount(ctx)
	case userconsume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userconsume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userconsume.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case userconsume.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case userconsume.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown UserConsume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserConsumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userconsume.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case userconsume.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case userconsume.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case userconsume.FieldDiscount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case userconsume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userconsume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userconsume.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case userconsume.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case userconsume.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserConsume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserConsumeMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, userconsume.FieldNovelId)
	}
	if m.addcoin != nil {
		fields = append(fields, userconsume.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, userconsume.FieldCoupon)
	}
	if m.adddiscount != nil {
		fields = append(fields, userconsume.FieldDiscount)
	}
	if m.addcreateBy != nil {
		fields = append(fields, userconsume.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, userconsume.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, userconsume.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserConsumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userconsume.FieldNovelId:
		return m.AddedNovelId()
	case userconsume.FieldCoin:
		return m.AddedCoin()
	case userconsume.FieldCoupon:
		return m.AddedCoupon()
	case userconsume.FieldDiscount:
		return m.AddedDiscount()
	case userconsume.FieldCreateBy:
		return m.AddedCreateBy()
	case userconsume.FieldUpdateBy:
		return m.AddedUpdateBy()
	case userconsume.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserConsumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userconsume.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case userconsume.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case userconsume.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case userconsume.FieldDiscount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case userconsume.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case userconsume.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case userconsume.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserConsume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserConsumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userconsume.FieldCoin) {
		fields = append(fields, userconsume.FieldCoin)
	}
	if m.FieldCleared(userconsume.FieldCoupon) {
		fields = append(fields, userconsume.FieldCoupon)
	}
	if m.FieldCleared(userconsume.FieldDiscount) {
		fields = append(fields, userconsume.FieldDiscount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserConsumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserConsumeMutation) ClearField(name string) error {
	switch name {
	case userconsume.FieldCoin:
		m.ClearCoin()
		return nil
	case userconsume.FieldCoupon:
		m.ClearCoupon()
		return nil
	case userconsume.FieldDiscount:
		m.ClearDiscount()
		return nil
	}
	return fmt.Errorf("unknown UserConsume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserConsumeMutation) ResetField(name string) error {
	switch name {
	case userconsume.FieldNovelId:
		m.ResetNovelId()
		return nil
	case userconsume.FieldCoin:
		m.ResetCoin()
		return nil
	case userconsume.FieldCoupon:
		m.ResetCoupon()
		return nil
	case userconsume.FieldDiscount:
		m.ResetDiscount()
		return nil
	case userconsume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userconsume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userconsume.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case userconsume.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case userconsume.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown UserConsume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserConsumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserConsumeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserConsumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserConsumeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserConsumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserConsumeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserConsumeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserConsume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserConsumeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserConsume edge %s", name)
}

// UserResourceMutation represents an operation that mutates the UserResource nodes in the graph.
type UserResourceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	resType       *string
	_Name         *string
	url           *string
	summary       *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserResource, error)
	predicates    []predicate.UserResource
}

var _ ent.Mutation = (*UserResourceMutation)(nil)

// userresourceOption allows management of the mutation configuration using functional options.
type userresourceOption func(*UserResourceMutation)

// newUserResourceMutation creates new mutation for the UserResource entity.
func newUserResourceMutation(c config, op Op, opts ...userresourceOption) *UserResourceMutation {
	m := &UserResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserResourceID sets the ID field of the mutation.
func withUserResourceID(id int64) userresourceOption {
	return func(m *UserResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserResource
		)
		m.oldValue = func(ctx context.Context) (*UserResource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserResource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserResource sets the old UserResource of the mutation.
func withUserResource(node *UserResource) userresourceOption {
	return func(m *UserResourceMutation) {
		m.oldValue = func(context.Context) (*UserResource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserResourceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserResourceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserResource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResType sets the "resType" field.
func (m *UserResourceMutation) SetResType(s string) {
	m.resType = &s
}

// ResType returns the value of the "resType" field in the mutation.
func (m *UserResourceMutation) ResType() (r string, exists bool) {
	v := m.resType
	if v == nil {
		return
	}
	return *v, true
}

// OldResType returns the old "resType" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldResType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResType: %w", err)
	}
	return oldValue.ResType, nil
}

// ClearResType clears the value of the "resType" field.
func (m *UserResourceMutation) ClearResType() {
	m.resType = nil
	m.clearedFields[userresource.FieldResType] = struct{}{}
}

// ResTypeCleared returns if the "resType" field was cleared in this mutation.
func (m *UserResourceMutation) ResTypeCleared() bool {
	_, ok := m.clearedFields[userresource.FieldResType]
	return ok
}

// ResetResType resets all changes to the "resType" field.
func (m *UserResourceMutation) ResetResType() {
	m.resType = nil
	delete(m.clearedFields, userresource.FieldResType)
}

// SetName sets the "Name" field.
func (m *UserResourceMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserResourceMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "Name" field.
func (m *UserResourceMutation) ClearName() {
	m._Name = nil
	m.clearedFields[userresource.FieldName] = struct{}{}
}

// NameCleared returns if the "Name" field was cleared in this mutation.
func (m *UserResourceMutation) NameCleared() bool {
	_, ok := m.clearedFields[userresource.FieldName]
	return ok
}

// ResetName resets all changes to the "Name" field.
func (m *UserResourceMutation) ResetName() {
	m._Name = nil
	delete(m.clearedFields, userresource.FieldName)
}

// SetURL sets the "url" field.
func (m *UserResourceMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserResourceMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *UserResourceMutation) ClearURL() {
	m.url = nil
	m.clearedFields[userresource.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *UserResourceMutation) URLCleared() bool {
	_, ok := m.clearedFields[userresource.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *UserResourceMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, userresource.FieldURL)
}

// SetSummary sets the "summary" field.
func (m *UserResourceMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *UserResourceMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *UserResourceMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[userresource.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *UserResourceMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[userresource.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *UserResourceMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, userresource.FieldSummary)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserResourceMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserResourceMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserResourceMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserResourceMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserResourceMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserResourceMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *UserResourceMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *UserResourceMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserResourceMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserResourceMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserResourceMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *UserResourceMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *UserResourceMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserResourceMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *UserResourceMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *UserResourceMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the UserResource entity.
// If the UserResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *UserResourceMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *UserResourceMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *UserResourceMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the UserResourceMutation builder.
func (m *UserResourceMutation) Where(ps ...predicate.UserResource) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserResourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserResource).
func (m *UserResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserResourceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.resType != nil {
		fields = append(fields, userresource.FieldResType)
	}
	if m._Name != nil {
		fields = append(fields, userresource.FieldName)
	}
	if m.url != nil {
		fields = append(fields, userresource.FieldURL)
	}
	if m.summary != nil {
		fields = append(fields, userresource.FieldSummary)
	}
	if m.createdAt != nil {
		fields = append(fields, userresource.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userresource.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, userresource.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, userresource.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, userresource.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userresource.FieldResType:
		return m.ResType()
	case userresource.FieldName:
		return m.Name()
	case userresource.FieldURL:
		return m.URL()
	case userresource.FieldSummary:
		return m.Summary()
	case userresource.FieldCreatedAt:
		return m.CreatedAt()
	case userresource.FieldUpdatedAt:
		return m.UpdatedAt()
	case userresource.FieldCreateBy:
		return m.CreateBy()
	case userresource.FieldUpdateBy:
		return m.UpdateBy()
	case userresource.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userresource.FieldResType:
		return m.OldResType(ctx)
	case userresource.FieldName:
		return m.OldName(ctx)
	case userresource.FieldURL:
		return m.OldURL(ctx)
	case userresource.FieldSummary:
		return m.OldSummary(ctx)
	case userresource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userresource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userresource.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case userresource.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case userresource.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown UserResource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userresource.FieldResType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResType(v)
		return nil
	case userresource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userresource.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case userresource.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case userresource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userresource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userresource.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case userresource.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case userresource.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserResource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserResourceMutation) AddedFields() []string {
	var fields []string
	if m.addcreateBy != nil {
		fields = append(fields, userresource.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, userresource.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, userresource.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userresource.FieldCreateBy:
		return m.AddedCreateBy()
	case userresource.FieldUpdateBy:
		return m.AddedUpdateBy()
	case userresource.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userresource.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case userresource.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case userresource.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserResource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userresource.FieldResType) {
		fields = append(fields, userresource.FieldResType)
	}
	if m.FieldCleared(userresource.FieldName) {
		fields = append(fields, userresource.FieldName)
	}
	if m.FieldCleared(userresource.FieldURL) {
		fields = append(fields, userresource.FieldURL)
	}
	if m.FieldCleared(userresource.FieldSummary) {
		fields = append(fields, userresource.FieldSummary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserResourceMutation) ClearField(name string) error {
	switch name {
	case userresource.FieldResType:
		m.ClearResType()
		return nil
	case userresource.FieldName:
		m.ClearName()
		return nil
	case userresource.FieldURL:
		m.ClearURL()
		return nil
	case userresource.FieldSummary:
		m.ClearSummary()
		return nil
	}
	return fmt.Errorf("unknown UserResource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserResourceMutation) ResetField(name string) error {
	switch name {
	case userresource.FieldResType:
		m.ResetResType()
		return nil
	case userresource.FieldName:
		m.ResetName()
		return nil
	case userresource.FieldURL:
		m.ResetURL()
		return nil
	case userresource.FieldSummary:
		m.ResetSummary()
		return nil
	case userresource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userresource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userresource.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case userresource.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case userresource.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown UserResource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserResourceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserResourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserResourceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserResourceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserResource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserResourceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserResource edge %s", name)
}

// UserResourceRecordMutation represents an operation that mutates the UserResourceRecord nodes in the graph.
type UserResourceRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	userId        *int64
	adduserId     *int64
	resId         *int64
	addresId      *int64
	def           *bool
	name          *string
	url           *string
	resType       *string
	remark        *string
	state         *int32
	addstate      *int32
	effectTime    *time.Time
	expiredTime   *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserResourceRecord, error)
	predicates    []predicate.UserResourceRecord
}

var _ ent.Mutation = (*UserResourceRecordMutation)(nil)

// userresourcerecordOption allows management of the mutation configuration using functional options.
type userresourcerecordOption func(*UserResourceRecordMutation)

// newUserResourceRecordMutation creates new mutation for the UserResourceRecord entity.
func newUserResourceRecordMutation(c config, op Op, opts ...userresourcerecordOption) *UserResourceRecordMutation {
	m := &UserResourceRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserResourceRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserResourceRecordID sets the ID field of the mutation.
func withUserResourceRecordID(id int64) userresourcerecordOption {
	return func(m *UserResourceRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserResourceRecord
		)
		m.oldValue = func(ctx context.Context) (*UserResourceRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserResourceRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserResourceRecord sets the old UserResourceRecord of the mutation.
func withUserResourceRecord(node *UserResourceRecord) userresourcerecordOption {
	return func(m *UserResourceRecordMutation) {
		m.oldValue = func(context.Context) (*UserResourceRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserResourceRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserResourceRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserResourceRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserResourceRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserResourceRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *UserResourceRecordMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserResourceRecordMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *UserResourceRecordMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *UserResourceRecordMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserId clears the value of the "userId" field.
func (m *UserResourceRecordMutation) ClearUserId() {
	m.userId = nil
	m.adduserId = nil
	m.clearedFields[userresourcerecord.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *UserResourceRecordMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserResourceRecordMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
	delete(m.clearedFields, userresourcerecord.FieldUserId)
}

// SetResId sets the "resId" field.
func (m *UserResourceRecordMutation) SetResId(i int64) {
	m.resId = &i
	m.addresId = nil
}

// ResId returns the value of the "resId" field in the mutation.
func (m *UserResourceRecordMutation) ResId() (r int64, exists bool) {
	v := m.resId
	if v == nil {
		return
	}
	return *v, true
}

// OldResId returns the old "resId" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldResId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResId: %w", err)
	}
	return oldValue.ResId, nil
}

// AddResId adds i to the "resId" field.
func (m *UserResourceRecordMutation) AddResId(i int64) {
	if m.addresId != nil {
		*m.addresId += i
	} else {
		m.addresId = &i
	}
}

// AddedResId returns the value that was added to the "resId" field in this mutation.
func (m *UserResourceRecordMutation) AddedResId() (r int64, exists bool) {
	v := m.addresId
	if v == nil {
		return
	}
	return *v, true
}

// ClearResId clears the value of the "resId" field.
func (m *UserResourceRecordMutation) ClearResId() {
	m.resId = nil
	m.addresId = nil
	m.clearedFields[userresourcerecord.FieldResId] = struct{}{}
}

// ResIdCleared returns if the "resId" field was cleared in this mutation.
func (m *UserResourceRecordMutation) ResIdCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldResId]
	return ok
}

// ResetResId resets all changes to the "resId" field.
func (m *UserResourceRecordMutation) ResetResId() {
	m.resId = nil
	m.addresId = nil
	delete(m.clearedFields, userresourcerecord.FieldResId)
}

// SetDef sets the "def" field.
func (m *UserResourceRecordMutation) SetDef(b bool) {
	m.def = &b
}

// Def returns the value of the "def" field in the mutation.
func (m *UserResourceRecordMutation) Def() (r bool, exists bool) {
	v := m.def
	if v == nil {
		return
	}
	return *v, true
}

// OldDef returns the old "def" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldDef(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDef: %w", err)
	}
	return oldValue.Def, nil
}

// ClearDef clears the value of the "def" field.
func (m *UserResourceRecordMutation) ClearDef() {
	m.def = nil
	m.clearedFields[userresourcerecord.FieldDef] = struct{}{}
}

// DefCleared returns if the "def" field was cleared in this mutation.
func (m *UserResourceRecordMutation) DefCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldDef]
	return ok
}

// ResetDef resets all changes to the "def" field.
func (m *UserResourceRecordMutation) ResetDef() {
	m.def = nil
	delete(m.clearedFields, userresourcerecord.FieldDef)
}

// SetName sets the "name" field.
func (m *UserResourceRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserResourceRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserResourceRecordMutation) ClearName() {
	m.name = nil
	m.clearedFields[userresourcerecord.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserResourceRecordMutation) NameCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserResourceRecordMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, userresourcerecord.FieldName)
}

// SetURL sets the "url" field.
func (m *UserResourceRecordMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserResourceRecordMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *UserResourceRecordMutation) ClearURL() {
	m.url = nil
	m.clearedFields[userresourcerecord.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *UserResourceRecordMutation) URLCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *UserResourceRecordMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, userresourcerecord.FieldURL)
}

// SetResType sets the "resType" field.
func (m *UserResourceRecordMutation) SetResType(s string) {
	m.resType = &s
}

// ResType returns the value of the "resType" field in the mutation.
func (m *UserResourceRecordMutation) ResType() (r string, exists bool) {
	v := m.resType
	if v == nil {
		return
	}
	return *v, true
}

// OldResType returns the old "resType" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldResType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResType: %w", err)
	}
	return oldValue.ResType, nil
}

// ClearResType clears the value of the "resType" field.
func (m *UserResourceRecordMutation) ClearResType() {
	m.resType = nil
	m.clearedFields[userresourcerecord.FieldResType] = struct{}{}
}

// ResTypeCleared returns if the "resType" field was cleared in this mutation.
func (m *UserResourceRecordMutation) ResTypeCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldResType]
	return ok
}

// ResetResType resets all changes to the "resType" field.
func (m *UserResourceRecordMutation) ResetResType() {
	m.resType = nil
	delete(m.clearedFields, userresourcerecord.FieldResType)
}

// SetRemark sets the "remark" field.
func (m *UserResourceRecordMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *UserResourceRecordMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *UserResourceRecordMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[userresourcerecord.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *UserResourceRecordMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *UserResourceRecordMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, userresourcerecord.FieldRemark)
}

// SetState sets the "state" field.
func (m *UserResourceRecordMutation) SetState(i int32) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *UserResourceRecordMutation) State() (r int32, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldState(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *UserResourceRecordMutation) AddState(i int32) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *UserResourceRecordMutation) AddedState() (r int32, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ClearState clears the value of the "state" field.
func (m *UserResourceRecordMutation) ClearState() {
	m.state = nil
	m.addstate = nil
	m.clearedFields[userresourcerecord.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *UserResourceRecordMutation) StateCleared() bool {
	_, ok := m.clearedFields[userresourcerecord.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *UserResourceRecordMutation) ResetState() {
	m.state = nil
	m.addstate = nil
	delete(m.clearedFields, userresourcerecord.FieldState)
}

// SetEffectTime sets the "effectTime" field.
func (m *UserResourceRecordMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *UserResourceRecordMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *UserResourceRecordMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *UserResourceRecordMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *UserResourceRecordMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *UserResourceRecordMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserResourceRecordMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserResourceRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserResourceRecordMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserResourceRecordMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserResourceRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserResourceRecordMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserResourceRecordMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserResourceRecordMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *UserResourceRecordMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *UserResourceRecordMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserResourceRecordMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserResourceRecordMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserResourceRecordMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *UserResourceRecordMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *UserResourceRecordMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserResourceRecordMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *UserResourceRecordMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *UserResourceRecordMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the UserResourceRecord entity.
// If the UserResourceRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserResourceRecordMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *UserResourceRecordMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *UserResourceRecordMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *UserResourceRecordMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the UserResourceRecordMutation builder.
func (m *UserResourceRecordMutation) Where(ps ...predicate.UserResourceRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserResourceRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserResourceRecord).
func (m *UserResourceRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserResourceRecordMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.userId != nil {
		fields = append(fields, userresourcerecord.FieldUserId)
	}
	if m.resId != nil {
		fields = append(fields, userresourcerecord.FieldResId)
	}
	if m.def != nil {
		fields = append(fields, userresourcerecord.FieldDef)
	}
	if m.name != nil {
		fields = append(fields, userresourcerecord.FieldName)
	}
	if m.url != nil {
		fields = append(fields, userresourcerecord.FieldURL)
	}
	if m.resType != nil {
		fields = append(fields, userresourcerecord.FieldResType)
	}
	if m.remark != nil {
		fields = append(fields, userresourcerecord.FieldRemark)
	}
	if m.state != nil {
		fields = append(fields, userresourcerecord.FieldState)
	}
	if m.effectTime != nil {
		fields = append(fields, userresourcerecord.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, userresourcerecord.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, userresourcerecord.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userresourcerecord.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, userresourcerecord.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, userresourcerecord.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, userresourcerecord.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserResourceRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userresourcerecord.FieldUserId:
		return m.UserId()
	case userresourcerecord.FieldResId:
		return m.ResId()
	case userresourcerecord.FieldDef:
		return m.Def()
	case userresourcerecord.FieldName:
		return m.Name()
	case userresourcerecord.FieldURL:
		return m.URL()
	case userresourcerecord.FieldResType:
		return m.ResType()
	case userresourcerecord.FieldRemark:
		return m.Remark()
	case userresourcerecord.FieldState:
		return m.State()
	case userresourcerecord.FieldEffectTime:
		return m.EffectTime()
	case userresourcerecord.FieldExpiredTime:
		return m.ExpiredTime()
	case userresourcerecord.FieldCreatedAt:
		return m.CreatedAt()
	case userresourcerecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case userresourcerecord.FieldCreateBy:
		return m.CreateBy()
	case userresourcerecord.FieldUpdateBy:
		return m.UpdateBy()
	case userresourcerecord.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserResourceRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userresourcerecord.FieldUserId:
		return m.OldUserId(ctx)
	case userresourcerecord.FieldResId:
		return m.OldResId(ctx)
	case userresourcerecord.FieldDef:
		return m.OldDef(ctx)
	case userresourcerecord.FieldName:
		return m.OldName(ctx)
	case userresourcerecord.FieldURL:
		return m.OldURL(ctx)
	case userresourcerecord.FieldResType:
		return m.OldResType(ctx)
	case userresourcerecord.FieldRemark:
		return m.OldRemark(ctx)
	case userresourcerecord.FieldState:
		return m.OldState(ctx)
	case userresourcerecord.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case userresourcerecord.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case userresourcerecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userresourcerecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userresourcerecord.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case userresourcerecord.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case userresourcerecord.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown UserResourceRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserResourceRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userresourcerecord.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userresourcerecord.FieldResId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResId(v)
		return nil
	case userresourcerecord.FieldDef:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDef(v)
		return nil
	case userresourcerecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userresourcerecord.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case userresourcerecord.FieldResType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResType(v)
		return nil
	case userresourcerecord.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case userresourcerecord.FieldState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case userresourcerecord.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case userresourcerecord.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case userresourcerecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userresourcerecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userresourcerecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case userresourcerecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case userresourcerecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserResourceRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserResourceRecordMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, userresourcerecord.FieldUserId)
	}
	if m.addresId != nil {
		fields = append(fields, userresourcerecord.FieldResId)
	}
	if m.addstate != nil {
		fields = append(fields, userresourcerecord.FieldState)
	}
	if m.addcreateBy != nil {
		fields = append(fields, userresourcerecord.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, userresourcerecord.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, userresourcerecord.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserResourceRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userresourcerecord.FieldUserId:
		return m.AddedUserId()
	case userresourcerecord.FieldResId:
		return m.AddedResId()
	case userresourcerecord.FieldState:
		return m.AddedState()
	case userresourcerecord.FieldCreateBy:
		return m.AddedCreateBy()
	case userresourcerecord.FieldUpdateBy:
		return m.AddedUpdateBy()
	case userresourcerecord.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserResourceRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userresourcerecord.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case userresourcerecord.FieldResId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResId(v)
		return nil
	case userresourcerecord.FieldState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case userresourcerecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case userresourcerecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case userresourcerecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserResourceRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserResourceRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userresourcerecord.FieldUserId) {
		fields = append(fields, userresourcerecord.FieldUserId)
	}
	if m.FieldCleared(userresourcerecord.FieldResId) {
		fields = append(fields, userresourcerecord.FieldResId)
	}
	if m.FieldCleared(userresourcerecord.FieldDef) {
		fields = append(fields, userresourcerecord.FieldDef)
	}
	if m.FieldCleared(userresourcerecord.FieldName) {
		fields = append(fields, userresourcerecord.FieldName)
	}
	if m.FieldCleared(userresourcerecord.FieldURL) {
		fields = append(fields, userresourcerecord.FieldURL)
	}
	if m.FieldCleared(userresourcerecord.FieldResType) {
		fields = append(fields, userresourcerecord.FieldResType)
	}
	if m.FieldCleared(userresourcerecord.FieldRemark) {
		fields = append(fields, userresourcerecord.FieldRemark)
	}
	if m.FieldCleared(userresourcerecord.FieldState) {
		fields = append(fields, userresourcerecord.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserResourceRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserResourceRecordMutation) ClearField(name string) error {
	switch name {
	case userresourcerecord.FieldUserId:
		m.ClearUserId()
		return nil
	case userresourcerecord.FieldResId:
		m.ClearResId()
		return nil
	case userresourcerecord.FieldDef:
		m.ClearDef()
		return nil
	case userresourcerecord.FieldName:
		m.ClearName()
		return nil
	case userresourcerecord.FieldURL:
		m.ClearURL()
		return nil
	case userresourcerecord.FieldResType:
		m.ClearResType()
		return nil
	case userresourcerecord.FieldRemark:
		m.ClearRemark()
		return nil
	case userresourcerecord.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown UserResourceRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserResourceRecordMutation) ResetField(name string) error {
	switch name {
	case userresourcerecord.FieldUserId:
		m.ResetUserId()
		return nil
	case userresourcerecord.FieldResId:
		m.ResetResId()
		return nil
	case userresourcerecord.FieldDef:
		m.ResetDef()
		return nil
	case userresourcerecord.FieldName:
		m.ResetName()
		return nil
	case userresourcerecord.FieldURL:
		m.ResetURL()
		return nil
	case userresourcerecord.FieldResType:
		m.ResetResType()
		return nil
	case userresourcerecord.FieldRemark:
		m.ResetRemark()
		return nil
	case userresourcerecord.FieldState:
		m.ResetState()
		return nil
	case userresourcerecord.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case userresourcerecord.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case userresourcerecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userresourcerecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userresourcerecord.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case userresourcerecord.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case userresourcerecord.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown UserResourceRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserResourceRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserResourceRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserResourceRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserResourceRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserResourceRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserResourceRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserResourceRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserResourceRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserResourceRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserResourceRecord edge %s", name)
}

// VipTypeMutation represents an operation that mutates the VipType nodes in the graph.
type VipTypeMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	vipName         *string
	isSuper         *bool
	validDays       *int32
	addvalidDays    *int32
	discountRate    *int64
	adddiscountRate *int64
	avatarId        *int64
	addavatarId     *int64
	summary         *string
	createdAt       *time.Time
	updatedAt       *time.Time
	createBy        *int64
	addcreateBy     *int64
	updateBy        *int64
	addupdateBy     *int64
	tenantId        *int64
	addtenantId     *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*VipType, error)
	predicates      []predicate.VipType
}

var _ ent.Mutation = (*VipTypeMutation)(nil)

// viptypeOption allows management of the mutation configuration using functional options.
type viptypeOption func(*VipTypeMutation)

// newVipTypeMutation creates new mutation for the VipType entity.
func newVipTypeMutation(c config, op Op, opts ...viptypeOption) *VipTypeMutation {
	m := &VipTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeVipType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVipTypeID sets the ID field of the mutation.
func withVipTypeID(id int64) viptypeOption {
	return func(m *VipTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *VipType
		)
		m.oldValue = func(ctx context.Context) (*VipType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VipType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVipType sets the old VipType of the mutation.
func withVipType(node *VipType) viptypeOption {
	return func(m *VipTypeMutation) {
		m.oldValue = func(context.Context) (*VipType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VipTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VipTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VipTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VipTypeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VipType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVipName sets the "vipName" field.
func (m *VipTypeMutation) SetVipName(s string) {
	m.vipName = &s
}

// VipName returns the value of the "vipName" field in the mutation.
func (m *VipTypeMutation) VipName() (r string, exists bool) {
	v := m.vipName
	if v == nil {
		return
	}
	return *v, true
}

// OldVipName returns the old "vipName" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldVipName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipName: %w", err)
	}
	return oldValue.VipName, nil
}

// ClearVipName clears the value of the "vipName" field.
func (m *VipTypeMutation) ClearVipName() {
	m.vipName = nil
	m.clearedFields[viptype.FieldVipName] = struct{}{}
}

// VipNameCleared returns if the "vipName" field was cleared in this mutation.
func (m *VipTypeMutation) VipNameCleared() bool {
	_, ok := m.clearedFields[viptype.FieldVipName]
	return ok
}

// ResetVipName resets all changes to the "vipName" field.
func (m *VipTypeMutation) ResetVipName() {
	m.vipName = nil
	delete(m.clearedFields, viptype.FieldVipName)
}

// SetIsSuper sets the "isSuper" field.
func (m *VipTypeMutation) SetIsSuper(b bool) {
	m.isSuper = &b
}

// IsSuper returns the value of the "isSuper" field in the mutation.
func (m *VipTypeMutation) IsSuper() (r bool, exists bool) {
	v := m.isSuper
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuper returns the old "isSuper" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldIsSuper(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuper: %w", err)
	}
	return oldValue.IsSuper, nil
}

// ClearIsSuper clears the value of the "isSuper" field.
func (m *VipTypeMutation) ClearIsSuper() {
	m.isSuper = nil
	m.clearedFields[viptype.FieldIsSuper] = struct{}{}
}

// IsSuperCleared returns if the "isSuper" field was cleared in this mutation.
func (m *VipTypeMutation) IsSuperCleared() bool {
	_, ok := m.clearedFields[viptype.FieldIsSuper]
	return ok
}

// ResetIsSuper resets all changes to the "isSuper" field.
func (m *VipTypeMutation) ResetIsSuper() {
	m.isSuper = nil
	delete(m.clearedFields, viptype.FieldIsSuper)
}

// SetValidDays sets the "validDays" field.
func (m *VipTypeMutation) SetValidDays(i int32) {
	m.validDays = &i
	m.addvalidDays = nil
}

// ValidDays returns the value of the "validDays" field in the mutation.
func (m *VipTypeMutation) ValidDays() (r int32, exists bool) {
	v := m.validDays
	if v == nil {
		return
	}
	return *v, true
}

// OldValidDays returns the old "validDays" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldValidDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidDays: %w", err)
	}
	return oldValue.ValidDays, nil
}

// AddValidDays adds i to the "validDays" field.
func (m *VipTypeMutation) AddValidDays(i int32) {
	if m.addvalidDays != nil {
		*m.addvalidDays += i
	} else {
		m.addvalidDays = &i
	}
}

// AddedValidDays returns the value that was added to the "validDays" field in this mutation.
func (m *VipTypeMutation) AddedValidDays() (r int32, exists bool) {
	v := m.addvalidDays
	if v == nil {
		return
	}
	return *v, true
}

// ClearValidDays clears the value of the "validDays" field.
func (m *VipTypeMutation) ClearValidDays() {
	m.validDays = nil
	m.addvalidDays = nil
	m.clearedFields[viptype.FieldValidDays] = struct{}{}
}

// ValidDaysCleared returns if the "validDays" field was cleared in this mutation.
func (m *VipTypeMutation) ValidDaysCleared() bool {
	_, ok := m.clearedFields[viptype.FieldValidDays]
	return ok
}

// ResetValidDays resets all changes to the "validDays" field.
func (m *VipTypeMutation) ResetValidDays() {
	m.validDays = nil
	m.addvalidDays = nil
	delete(m.clearedFields, viptype.FieldValidDays)
}

// SetDiscountRate sets the "discountRate" field.
func (m *VipTypeMutation) SetDiscountRate(i int64) {
	m.discountRate = &i
	m.adddiscountRate = nil
}

// DiscountRate returns the value of the "discountRate" field in the mutation.
func (m *VipTypeMutation) DiscountRate() (r int64, exists bool) {
	v := m.discountRate
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountRate returns the old "discountRate" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldDiscountRate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountRate: %w", err)
	}
	return oldValue.DiscountRate, nil
}

// AddDiscountRate adds i to the "discountRate" field.
func (m *VipTypeMutation) AddDiscountRate(i int64) {
	if m.adddiscountRate != nil {
		*m.adddiscountRate += i
	} else {
		m.adddiscountRate = &i
	}
}

// AddedDiscountRate returns the value that was added to the "discountRate" field in this mutation.
func (m *VipTypeMutation) AddedDiscountRate() (r int64, exists bool) {
	v := m.adddiscountRate
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiscountRate clears the value of the "discountRate" field.
func (m *VipTypeMutation) ClearDiscountRate() {
	m.discountRate = nil
	m.adddiscountRate = nil
	m.clearedFields[viptype.FieldDiscountRate] = struct{}{}
}

// DiscountRateCleared returns if the "discountRate" field was cleared in this mutation.
func (m *VipTypeMutation) DiscountRateCleared() bool {
	_, ok := m.clearedFields[viptype.FieldDiscountRate]
	return ok
}

// ResetDiscountRate resets all changes to the "discountRate" field.
func (m *VipTypeMutation) ResetDiscountRate() {
	m.discountRate = nil
	m.adddiscountRate = nil
	delete(m.clearedFields, viptype.FieldDiscountRate)
}

// SetAvatarId sets the "avatarId" field.
func (m *VipTypeMutation) SetAvatarId(i int64) {
	m.avatarId = &i
	m.addavatarId = nil
}

// AvatarId returns the value of the "avatarId" field in the mutation.
func (m *VipTypeMutation) AvatarId() (r int64, exists bool) {
	v := m.avatarId
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarId returns the old "avatarId" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldAvatarId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarId: %w", err)
	}
	return oldValue.AvatarId, nil
}

// AddAvatarId adds i to the "avatarId" field.
func (m *VipTypeMutation) AddAvatarId(i int64) {
	if m.addavatarId != nil {
		*m.addavatarId += i
	} else {
		m.addavatarId = &i
	}
}

// AddedAvatarId returns the value that was added to the "avatarId" field in this mutation.
func (m *VipTypeMutation) AddedAvatarId() (r int64, exists bool) {
	v := m.addavatarId
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvatarId clears the value of the "avatarId" field.
func (m *VipTypeMutation) ClearAvatarId() {
	m.avatarId = nil
	m.addavatarId = nil
	m.clearedFields[viptype.FieldAvatarId] = struct{}{}
}

// AvatarIdCleared returns if the "avatarId" field was cleared in this mutation.
func (m *VipTypeMutation) AvatarIdCleared() bool {
	_, ok := m.clearedFields[viptype.FieldAvatarId]
	return ok
}

// ResetAvatarId resets all changes to the "avatarId" field.
func (m *VipTypeMutation) ResetAvatarId() {
	m.avatarId = nil
	m.addavatarId = nil
	delete(m.clearedFields, viptype.FieldAvatarId)
}

// SetSummary sets the "summary" field.
func (m *VipTypeMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *VipTypeMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *VipTypeMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[viptype.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *VipTypeMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[viptype.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *VipTypeMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, viptype.FieldSummary)
}

// SetCreatedAt sets the "createdAt" field.
func (m *VipTypeMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *VipTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *VipTypeMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *VipTypeMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *VipTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *VipTypeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *VipTypeMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *VipTypeMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *VipTypeMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *VipTypeMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *VipTypeMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *VipTypeMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *VipTypeMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *VipTypeMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *VipTypeMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *VipTypeMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *VipTypeMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *VipTypeMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the VipType entity.
// If the VipType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipTypeMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *VipTypeMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *VipTypeMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *VipTypeMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the VipTypeMutation builder.
func (m *VipTypeMutation) Where(ps ...predicate.VipType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VipTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VipType).
func (m *VipTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VipTypeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.vipName != nil {
		fields = append(fields, viptype.FieldVipName)
	}
	if m.isSuper != nil {
		fields = append(fields, viptype.FieldIsSuper)
	}
	if m.validDays != nil {
		fields = append(fields, viptype.FieldValidDays)
	}
	if m.discountRate != nil {
		fields = append(fields, viptype.FieldDiscountRate)
	}
	if m.avatarId != nil {
		fields = append(fields, viptype.FieldAvatarId)
	}
	if m.summary != nil {
		fields = append(fields, viptype.FieldSummary)
	}
	if m.createdAt != nil {
		fields = append(fields, viptype.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, viptype.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, viptype.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, viptype.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, viptype.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VipTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case viptype.FieldVipName:
		return m.VipName()
	case viptype.FieldIsSuper:
		return m.IsSuper()
	case viptype.FieldValidDays:
		return m.ValidDays()
	case viptype.FieldDiscountRate:
		return m.DiscountRate()
	case viptype.FieldAvatarId:
		return m.AvatarId()
	case viptype.FieldSummary:
		return m.Summary()
	case viptype.FieldCreatedAt:
		return m.CreatedAt()
	case viptype.FieldUpdatedAt:
		return m.UpdatedAt()
	case viptype.FieldCreateBy:
		return m.CreateBy()
	case viptype.FieldUpdateBy:
		return m.UpdateBy()
	case viptype.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VipTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case viptype.FieldVipName:
		return m.OldVipName(ctx)
	case viptype.FieldIsSuper:
		return m.OldIsSuper(ctx)
	case viptype.FieldValidDays:
		return m.OldValidDays(ctx)
	case viptype.FieldDiscountRate:
		return m.OldDiscountRate(ctx)
	case viptype.FieldAvatarId:
		return m.OldAvatarId(ctx)
	case viptype.FieldSummary:
		return m.OldSummary(ctx)
	case viptype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case viptype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case viptype.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case viptype.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case viptype.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown VipType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case viptype.FieldVipName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipName(v)
		return nil
	case viptype.FieldIsSuper:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuper(v)
		return nil
	case viptype.FieldValidDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidDays(v)
		return nil
	case viptype.FieldDiscountRate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountRate(v)
		return nil
	case viptype.FieldAvatarId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarId(v)
		return nil
	case viptype.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case viptype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case viptype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case viptype.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case viptype.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case viptype.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown VipType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VipTypeMutation) AddedFields() []string {
	var fields []string
	if m.addvalidDays != nil {
		fields = append(fields, viptype.FieldValidDays)
	}
	if m.adddiscountRate != nil {
		fields = append(fields, viptype.FieldDiscountRate)
	}
	if m.addavatarId != nil {
		fields = append(fields, viptype.FieldAvatarId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, viptype.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, viptype.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, viptype.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VipTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case viptype.FieldValidDays:
		return m.AddedValidDays()
	case viptype.FieldDiscountRate:
		return m.AddedDiscountRate()
	case viptype.FieldAvatarId:
		return m.AddedAvatarId()
	case viptype.FieldCreateBy:
		return m.AddedCreateBy()
	case viptype.FieldUpdateBy:
		return m.AddedUpdateBy()
	case viptype.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case viptype.FieldValidDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidDays(v)
		return nil
	case viptype.FieldDiscountRate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountRate(v)
		return nil
	case viptype.FieldAvatarId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvatarId(v)
		return nil
	case viptype.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case viptype.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case viptype.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown VipType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VipTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(viptype.FieldVipName) {
		fields = append(fields, viptype.FieldVipName)
	}
	if m.FieldCleared(viptype.FieldIsSuper) {
		fields = append(fields, viptype.FieldIsSuper)
	}
	if m.FieldCleared(viptype.FieldValidDays) {
		fields = append(fields, viptype.FieldValidDays)
	}
	if m.FieldCleared(viptype.FieldDiscountRate) {
		fields = append(fields, viptype.FieldDiscountRate)
	}
	if m.FieldCleared(viptype.FieldAvatarId) {
		fields = append(fields, viptype.FieldAvatarId)
	}
	if m.FieldCleared(viptype.FieldSummary) {
		fields = append(fields, viptype.FieldSummary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VipTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VipTypeMutation) ClearField(name string) error {
	switch name {
	case viptype.FieldVipName:
		m.ClearVipName()
		return nil
	case viptype.FieldIsSuper:
		m.ClearIsSuper()
		return nil
	case viptype.FieldValidDays:
		m.ClearValidDays()
		return nil
	case viptype.FieldDiscountRate:
		m.ClearDiscountRate()
		return nil
	case viptype.FieldAvatarId:
		m.ClearAvatarId()
		return nil
	case viptype.FieldSummary:
		m.ClearSummary()
		return nil
	}
	return fmt.Errorf("unknown VipType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VipTypeMutation) ResetField(name string) error {
	switch name {
	case viptype.FieldVipName:
		m.ResetVipName()
		return nil
	case viptype.FieldIsSuper:
		m.ResetIsSuper()
		return nil
	case viptype.FieldValidDays:
		m.ResetValidDays()
		return nil
	case viptype.FieldDiscountRate:
		m.ResetDiscountRate()
		return nil
	case viptype.FieldAvatarId:
		m.ResetAvatarId()
		return nil
	case viptype.FieldSummary:
		m.ResetSummary()
		return nil
	case viptype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case viptype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case viptype.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case viptype.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case viptype.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown VipType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VipTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VipTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VipTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VipTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VipTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VipTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VipTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VipType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VipTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VipType edge %s", name)
}
