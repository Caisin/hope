// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"hope/apps/novel/internal/data/ent/socialuser"
	"hope/apps/novel/internal/data/ent/tasklog"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// TaskLog is the model entity for the TaskLog schema.
type TaskLog struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// UserId holds the value of the "userId" field.
	// 用户ID
	UserId int64 `json:"userId,omitempty"`
	// TaskGroup holds the value of the "taskGroup" field.
	// 任务分组
	TaskGroup string `json:"taskGroup,omitempty"`
	// TaskCode holds the value of the "taskCode" field.
	// 任务编码
	TaskCode string `json:"taskCode,omitempty"`
	// TaskId holds the value of the "taskId" field.
	// 任务Id
	TaskId int64 `json:"taskId,omitempty"`
	// TaskName holds the value of the "taskName" field.
	// 任务名称
	TaskName string `json:"taskName,omitempty"`
	// Amount holds the value of the "amount" field.
	// 奖励金额
	Amount int64 `json:"amount,omitempty"`
	// Reward holds the value of the "reward" field.
	// 额外奖励金额
	Reward int64 `json:"reward,omitempty"`
	// AmountItem holds the value of the "amountItem" field.
	// 奖励资产科目
	AmountItem int32 `json:"amountItem,omitempty"`
	// RewardItem holds the value of the "rewardItem" field.
	// 额外奖励资产科目
	RewardItem int32 `json:"rewardItem,omitempty"`
	// TargetAmount holds the value of the "targetAmount" field.
	// 目标值
	TargetAmount int64 `json:"targetAmount,omitempty"`
	// DoneAmount holds the value of the "doneAmount" field.
	// 完成值
	DoneAmount int64 `json:"doneAmount,omitempty"`
	// State holds the value of the "state" field.
	// 状态,0
	State int64 `json:"state,omitempty"`
	// DoneAt holds the value of the "doneAt" field.
	// 完成时间
	DoneAt time.Time `json:"doneAt,omitempty"`
	// ObtainAt holds the value of the "obtainAt" field.
	// 领取奖励时间
	ObtainAt time.Time `json:"obtainAt,omitempty"`
	// DoneTimes holds the value of the "doneTimes" field.
	// 完成次数
	DoneTimes int32 `json:"doneTimes,omitempty"`
	// AllTimes holds the value of the "allTimes" field.
	// 可完成次数
	AllTimes int32 `json:"allTimes,omitempty"`
	// EffectTime holds the value of the "effectTime" field.
	// 生效时间
	EffectTime time.Time `json:"effectTime,omitempty"`
	// ExpiredTime holds the value of the "expiredTime" field.
	// 失效时间
	ExpiredTime time.Time `json:"expiredTime,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	// 创建时间
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	// 更新时间
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
	// CreateBy holds the value of the "createBy" field.
	// 创建者
	CreateBy int64 `json:"createBy,omitempty"`
	// UpdateBy holds the value of the "updateBy" field.
	// 更新者
	UpdateBy int64 `json:"updateBy,omitempty"`
	// TenantId holds the value of the "tenantId" field.
	// 租户
	TenantId int64 `json:"tenantId,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TaskLogQuery when eager-loading is set.
	Edges TaskLogEdges `json:"edges"`
}

// TaskLogEdges holds the relations/edges for other nodes in the graph.
type TaskLogEdges struct {
	// User holds the value of the user edge.
	User *SocialUser `json:"user,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// UserOrErr returns the User value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TaskLogEdges) UserOrErr() (*SocialUser, error) {
	if e.loadedTypes[0] {
		if e.User == nil {
			// The edge user was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: socialuser.Label}
		}
		return e.User, nil
	}
	return nil, &NotLoadedError{edge: "user"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TaskLog) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case tasklog.FieldID, tasklog.FieldUserId, tasklog.FieldTaskId, tasklog.FieldAmount, tasklog.FieldReward, tasklog.FieldAmountItem, tasklog.FieldRewardItem, tasklog.FieldTargetAmount, tasklog.FieldDoneAmount, tasklog.FieldState, tasklog.FieldDoneTimes, tasklog.FieldAllTimes, tasklog.FieldCreateBy, tasklog.FieldUpdateBy, tasklog.FieldTenantId:
			values[i] = new(sql.NullInt64)
		case tasklog.FieldTaskGroup, tasklog.FieldTaskCode, tasklog.FieldTaskName:
			values[i] = new(sql.NullString)
		case tasklog.FieldDoneAt, tasklog.FieldObtainAt, tasklog.FieldEffectTime, tasklog.FieldExpiredTime, tasklog.FieldCreatedAt, tasklog.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type TaskLog", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TaskLog fields.
func (tl *TaskLog) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case tasklog.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			tl.ID = int64(value.Int64)
		case tasklog.FieldUserId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field userId", values[i])
			} else if value.Valid {
				tl.UserId = value.Int64
			}
		case tasklog.FieldTaskGroup:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field taskGroup", values[i])
			} else if value.Valid {
				tl.TaskGroup = value.String
			}
		case tasklog.FieldTaskCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field taskCode", values[i])
			} else if value.Valid {
				tl.TaskCode = value.String
			}
		case tasklog.FieldTaskId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field taskId", values[i])
			} else if value.Valid {
				tl.TaskId = value.Int64
			}
		case tasklog.FieldTaskName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field taskName", values[i])
			} else if value.Valid {
				tl.TaskName = value.String
			}
		case tasklog.FieldAmount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field amount", values[i])
			} else if value.Valid {
				tl.Amount = value.Int64
			}
		case tasklog.FieldReward:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field reward", values[i])
			} else if value.Valid {
				tl.Reward = value.Int64
			}
		case tasklog.FieldAmountItem:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field amountItem", values[i])
			} else if value.Valid {
				tl.AmountItem = int32(value.Int64)
			}
		case tasklog.FieldRewardItem:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field rewardItem", values[i])
			} else if value.Valid {
				tl.RewardItem = int32(value.Int64)
			}
		case tasklog.FieldTargetAmount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field targetAmount", values[i])
			} else if value.Valid {
				tl.TargetAmount = value.Int64
			}
		case tasklog.FieldDoneAmount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field doneAmount", values[i])
			} else if value.Valid {
				tl.DoneAmount = value.Int64
			}
		case tasklog.FieldState:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field state", values[i])
			} else if value.Valid {
				tl.State = value.Int64
			}
		case tasklog.FieldDoneAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field doneAt", values[i])
			} else if value.Valid {
				tl.DoneAt = value.Time
			}
		case tasklog.FieldObtainAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field obtainAt", values[i])
			} else if value.Valid {
				tl.ObtainAt = value.Time
			}
		case tasklog.FieldDoneTimes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field doneTimes", values[i])
			} else if value.Valid {
				tl.DoneTimes = int32(value.Int64)
			}
		case tasklog.FieldAllTimes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field allTimes", values[i])
			} else if value.Valid {
				tl.AllTimes = int32(value.Int64)
			}
		case tasklog.FieldEffectTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field effectTime", values[i])
			} else if value.Valid {
				tl.EffectTime = value.Time
			}
		case tasklog.FieldExpiredTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field expiredTime", values[i])
			} else if value.Valid {
				tl.ExpiredTime = value.Time
			}
		case tasklog.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdAt", values[i])
			} else if value.Valid {
				tl.CreatedAt = value.Time
			}
		case tasklog.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedAt", values[i])
			} else if value.Valid {
				tl.UpdatedAt = value.Time
			}
		case tasklog.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field createBy", values[i])
			} else if value.Valid {
				tl.CreateBy = value.Int64
			}
		case tasklog.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updateBy", values[i])
			} else if value.Valid {
				tl.UpdateBy = value.Int64
			}
		case tasklog.FieldTenantId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenantId", values[i])
			} else if value.Valid {
				tl.TenantId = value.Int64
			}
		}
	}
	return nil
}

// QueryUser queries the "user" edge of the TaskLog entity.
func (tl *TaskLog) QueryUser() *SocialUserQuery {
	return (&TaskLogClient{config: tl.config}).QueryUser(tl)
}

// Update returns a builder for updating this TaskLog.
// Note that you need to call TaskLog.Unwrap() before calling this method if this TaskLog
// was returned from a transaction, and the transaction was committed or rolled back.
func (tl *TaskLog) Update() *TaskLogUpdateOne {
	return (&TaskLogClient{config: tl.config}).UpdateOne(tl)
}

// Unwrap unwraps the TaskLog entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (tl *TaskLog) Unwrap() *TaskLog {
	tx, ok := tl.config.driver.(*txDriver)
	if !ok {
		panic("ent: TaskLog is not a transactional entity")
	}
	tl.config.driver = tx.drv
	return tl
}

// String implements the fmt.Stringer.
func (tl *TaskLog) String() string {
	var builder strings.Builder
	builder.WriteString("TaskLog(")
	builder.WriteString(fmt.Sprintf("id=%v", tl.ID))
	builder.WriteString(", userId=")
	builder.WriteString(fmt.Sprintf("%v", tl.UserId))
	builder.WriteString(", taskGroup=")
	builder.WriteString(tl.TaskGroup)
	builder.WriteString(", taskCode=")
	builder.WriteString(tl.TaskCode)
	builder.WriteString(", taskId=")
	builder.WriteString(fmt.Sprintf("%v", tl.TaskId))
	builder.WriteString(", taskName=")
	builder.WriteString(tl.TaskName)
	builder.WriteString(", amount=")
	builder.WriteString(fmt.Sprintf("%v", tl.Amount))
	builder.WriteString(", reward=")
	builder.WriteString(fmt.Sprintf("%v", tl.Reward))
	builder.WriteString(", amountItem=")
	builder.WriteString(fmt.Sprintf("%v", tl.AmountItem))
	builder.WriteString(", rewardItem=")
	builder.WriteString(fmt.Sprintf("%v", tl.RewardItem))
	builder.WriteString(", targetAmount=")
	builder.WriteString(fmt.Sprintf("%v", tl.TargetAmount))
	builder.WriteString(", doneAmount=")
	builder.WriteString(fmt.Sprintf("%v", tl.DoneAmount))
	builder.WriteString(", state=")
	builder.WriteString(fmt.Sprintf("%v", tl.State))
	builder.WriteString(", doneAt=")
	builder.WriteString(tl.DoneAt.Format(time.ANSIC))
	builder.WriteString(", obtainAt=")
	builder.WriteString(tl.ObtainAt.Format(time.ANSIC))
	builder.WriteString(", doneTimes=")
	builder.WriteString(fmt.Sprintf("%v", tl.DoneTimes))
	builder.WriteString(", allTimes=")
	builder.WriteString(fmt.Sprintf("%v", tl.AllTimes))
	builder.WriteString(", effectTime=")
	builder.WriteString(tl.EffectTime.Format(time.ANSIC))
	builder.WriteString(", expiredTime=")
	builder.WriteString(tl.ExpiredTime.Format(time.ANSIC))
	builder.WriteString(", createdAt=")
	builder.WriteString(tl.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updatedAt=")
	builder.WriteString(tl.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", createBy=")
	builder.WriteString(fmt.Sprintf("%v", tl.CreateBy))
	builder.WriteString(", updateBy=")
	builder.WriteString(fmt.Sprintf("%v", tl.UpdateBy))
	builder.WriteString(", tenantId=")
	builder.WriteString(fmt.Sprintf("%v", tl.TenantId))
	builder.WriteByte(')')
	return builder.String()
}

// TaskLogs is a parsable slice of TaskLog.
type TaskLogs []*TaskLog

func (tl TaskLogs) config(cfg config) {
	for _i := range tl {
		tl[_i].config = cfg
	}
}
