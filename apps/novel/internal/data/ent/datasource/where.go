// Code generated by entc, DO NOT EDIT.

package datasource

import (
	"hope/apps/novel/internal/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// DbName applies equality check predicate on the "dbName" field. It's identical to DbNameEQ.
func DbName(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDbName), v))
	})
}

// Host applies equality check predicate on the "host" field. It's identical to HostEQ.
func Host(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHost), v))
	})
}

// Port applies equality check predicate on the "port" field. It's identical to PortEQ.
func Port(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPort), v))
	})
}

// Database applies equality check predicate on the "database" field. It's identical to DatabaseEQ.
func Database(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDatabase), v))
	})
}

// UserName applies equality check predicate on the "userName" field. It's identical to UserNameEQ.
func UserName(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserName), v))
	})
}

// Pwd applies equality check predicate on the "pwd" field. It's identical to PwdEQ.
func Pwd(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPwd), v))
	})
}

// Status applies equality check predicate on the "status" field. It's identical to StatusEQ.
func Status(v bool) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// ConnMaxIdleTime applies equality check predicate on the "connMaxIdleTime" field. It's identical to ConnMaxIdleTimeEQ.
func ConnMaxIdleTime(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxLifeTime applies equality check predicate on the "connMaxLifeTime" field. It's identical to ConnMaxLifeTimeEQ.
func ConnMaxLifeTime(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldConnMaxLifeTime), v))
	})
}

// MaxIdleConns applies equality check predicate on the "maxIdleConns" field. It's identical to MaxIdleConnsEQ.
func MaxIdleConns(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxIdleConns), v))
	})
}

// MaxOpenConns applies equality check predicate on the "maxOpenConns" field. It's identical to MaxOpenConnsEQ.
func MaxOpenConns(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxOpenConns), v))
	})
}

// Remark applies equality check predicate on the "remark" field. It's identical to RemarkEQ.
func Remark(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemark), v))
	})
}

// CreatedAt applies equality check predicate on the "createdAt" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updatedAt" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// CreateBy applies equality check predicate on the "createBy" field. It's identical to CreateByEQ.
func CreateBy(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateBy), v))
	})
}

// UpdateBy applies equality check predicate on the "updateBy" field. It's identical to UpdateByEQ.
func UpdateBy(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateBy), v))
	})
}

// TenantId applies equality check predicate on the "tenantId" field. It's identical to TenantIdEQ.
func TenantId(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantId), v))
	})
}

// DbNameEQ applies the EQ predicate on the "dbName" field.
func DbNameEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDbName), v))
	})
}

// DbNameNEQ applies the NEQ predicate on the "dbName" field.
func DbNameNEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDbName), v))
	})
}

// DbNameIn applies the In predicate on the "dbName" field.
func DbNameIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDbName), v...))
	})
}

// DbNameNotIn applies the NotIn predicate on the "dbName" field.
func DbNameNotIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDbName), v...))
	})
}

// DbNameGT applies the GT predicate on the "dbName" field.
func DbNameGT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDbName), v))
	})
}

// DbNameGTE applies the GTE predicate on the "dbName" field.
func DbNameGTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDbName), v))
	})
}

// DbNameLT applies the LT predicate on the "dbName" field.
func DbNameLT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDbName), v))
	})
}

// DbNameLTE applies the LTE predicate on the "dbName" field.
func DbNameLTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDbName), v))
	})
}

// DbNameContains applies the Contains predicate on the "dbName" field.
func DbNameContains(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDbName), v))
	})
}

// DbNameHasPrefix applies the HasPrefix predicate on the "dbName" field.
func DbNameHasPrefix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDbName), v))
	})
}

// DbNameHasSuffix applies the HasSuffix predicate on the "dbName" field.
func DbNameHasSuffix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDbName), v))
	})
}

// DbNameIsNil applies the IsNil predicate on the "dbName" field.
func DbNameIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDbName)))
	})
}

// DbNameNotNil applies the NotNil predicate on the "dbName" field.
func DbNameNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDbName)))
	})
}

// DbNameEqualFold applies the EqualFold predicate on the "dbName" field.
func DbNameEqualFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDbName), v))
	})
}

// DbNameContainsFold applies the ContainsFold predicate on the "dbName" field.
func DbNameContainsFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDbName), v))
	})
}

// HostEQ applies the EQ predicate on the "host" field.
func HostEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHost), v))
	})
}

// HostNEQ applies the NEQ predicate on the "host" field.
func HostNEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHost), v))
	})
}

// HostIn applies the In predicate on the "host" field.
func HostIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHost), v...))
	})
}

// HostNotIn applies the NotIn predicate on the "host" field.
func HostNotIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHost), v...))
	})
}

// HostGT applies the GT predicate on the "host" field.
func HostGT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHost), v))
	})
}

// HostGTE applies the GTE predicate on the "host" field.
func HostGTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHost), v))
	})
}

// HostLT applies the LT predicate on the "host" field.
func HostLT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHost), v))
	})
}

// HostLTE applies the LTE predicate on the "host" field.
func HostLTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHost), v))
	})
}

// HostContains applies the Contains predicate on the "host" field.
func HostContains(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHost), v))
	})
}

// HostHasPrefix applies the HasPrefix predicate on the "host" field.
func HostHasPrefix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHost), v))
	})
}

// HostHasSuffix applies the HasSuffix predicate on the "host" field.
func HostHasSuffix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHost), v))
	})
}

// HostIsNil applies the IsNil predicate on the "host" field.
func HostIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldHost)))
	})
}

// HostNotNil applies the NotNil predicate on the "host" field.
func HostNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldHost)))
	})
}

// HostEqualFold applies the EqualFold predicate on the "host" field.
func HostEqualFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHost), v))
	})
}

// HostContainsFold applies the ContainsFold predicate on the "host" field.
func HostContainsFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHost), v))
	})
}

// PortEQ applies the EQ predicate on the "port" field.
func PortEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPort), v))
	})
}

// PortNEQ applies the NEQ predicate on the "port" field.
func PortNEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPort), v))
	})
}

// PortIn applies the In predicate on the "port" field.
func PortIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPort), v...))
	})
}

// PortNotIn applies the NotIn predicate on the "port" field.
func PortNotIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPort), v...))
	})
}

// PortGT applies the GT predicate on the "port" field.
func PortGT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPort), v))
	})
}

// PortGTE applies the GTE predicate on the "port" field.
func PortGTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPort), v))
	})
}

// PortLT applies the LT predicate on the "port" field.
func PortLT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPort), v))
	})
}

// PortLTE applies the LTE predicate on the "port" field.
func PortLTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPort), v))
	})
}

// PortIsNil applies the IsNil predicate on the "port" field.
func PortIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPort)))
	})
}

// PortNotNil applies the NotNil predicate on the "port" field.
func PortNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPort)))
	})
}

// DatabaseEQ applies the EQ predicate on the "database" field.
func DatabaseEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDatabase), v))
	})
}

// DatabaseNEQ applies the NEQ predicate on the "database" field.
func DatabaseNEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDatabase), v))
	})
}

// DatabaseIn applies the In predicate on the "database" field.
func DatabaseIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDatabase), v...))
	})
}

// DatabaseNotIn applies the NotIn predicate on the "database" field.
func DatabaseNotIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDatabase), v...))
	})
}

// DatabaseGT applies the GT predicate on the "database" field.
func DatabaseGT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDatabase), v))
	})
}

// DatabaseGTE applies the GTE predicate on the "database" field.
func DatabaseGTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDatabase), v))
	})
}

// DatabaseLT applies the LT predicate on the "database" field.
func DatabaseLT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDatabase), v))
	})
}

// DatabaseLTE applies the LTE predicate on the "database" field.
func DatabaseLTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDatabase), v))
	})
}

// DatabaseContains applies the Contains predicate on the "database" field.
func DatabaseContains(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDatabase), v))
	})
}

// DatabaseHasPrefix applies the HasPrefix predicate on the "database" field.
func DatabaseHasPrefix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDatabase), v))
	})
}

// DatabaseHasSuffix applies the HasSuffix predicate on the "database" field.
func DatabaseHasSuffix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDatabase), v))
	})
}

// DatabaseIsNil applies the IsNil predicate on the "database" field.
func DatabaseIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDatabase)))
	})
}

// DatabaseNotNil applies the NotNil predicate on the "database" field.
func DatabaseNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDatabase)))
	})
}

// DatabaseEqualFold applies the EqualFold predicate on the "database" field.
func DatabaseEqualFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDatabase), v))
	})
}

// DatabaseContainsFold applies the ContainsFold predicate on the "database" field.
func DatabaseContainsFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDatabase), v))
	})
}

// UserNameEQ applies the EQ predicate on the "userName" field.
func UserNameEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserName), v))
	})
}

// UserNameNEQ applies the NEQ predicate on the "userName" field.
func UserNameNEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserName), v))
	})
}

// UserNameIn applies the In predicate on the "userName" field.
func UserNameIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserName), v...))
	})
}

// UserNameNotIn applies the NotIn predicate on the "userName" field.
func UserNameNotIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserName), v...))
	})
}

// UserNameGT applies the GT predicate on the "userName" field.
func UserNameGT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserName), v))
	})
}

// UserNameGTE applies the GTE predicate on the "userName" field.
func UserNameGTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserName), v))
	})
}

// UserNameLT applies the LT predicate on the "userName" field.
func UserNameLT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserName), v))
	})
}

// UserNameLTE applies the LTE predicate on the "userName" field.
func UserNameLTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserName), v))
	})
}

// UserNameContains applies the Contains predicate on the "userName" field.
func UserNameContains(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserName), v))
	})
}

// UserNameHasPrefix applies the HasPrefix predicate on the "userName" field.
func UserNameHasPrefix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserName), v))
	})
}

// UserNameHasSuffix applies the HasSuffix predicate on the "userName" field.
func UserNameHasSuffix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserName), v))
	})
}

// UserNameIsNil applies the IsNil predicate on the "userName" field.
func UserNameIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUserName)))
	})
}

// UserNameNotNil applies the NotNil predicate on the "userName" field.
func UserNameNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUserName)))
	})
}

// UserNameEqualFold applies the EqualFold predicate on the "userName" field.
func UserNameEqualFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserName), v))
	})
}

// UserNameContainsFold applies the ContainsFold predicate on the "userName" field.
func UserNameContainsFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserName), v))
	})
}

// PwdEQ applies the EQ predicate on the "pwd" field.
func PwdEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPwd), v))
	})
}

// PwdNEQ applies the NEQ predicate on the "pwd" field.
func PwdNEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPwd), v))
	})
}

// PwdIn applies the In predicate on the "pwd" field.
func PwdIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPwd), v...))
	})
}

// PwdNotIn applies the NotIn predicate on the "pwd" field.
func PwdNotIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPwd), v...))
	})
}

// PwdGT applies the GT predicate on the "pwd" field.
func PwdGT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPwd), v))
	})
}

// PwdGTE applies the GTE predicate on the "pwd" field.
func PwdGTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPwd), v))
	})
}

// PwdLT applies the LT predicate on the "pwd" field.
func PwdLT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPwd), v))
	})
}

// PwdLTE applies the LTE predicate on the "pwd" field.
func PwdLTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPwd), v))
	})
}

// PwdContains applies the Contains predicate on the "pwd" field.
func PwdContains(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPwd), v))
	})
}

// PwdHasPrefix applies the HasPrefix predicate on the "pwd" field.
func PwdHasPrefix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPwd), v))
	})
}

// PwdHasSuffix applies the HasSuffix predicate on the "pwd" field.
func PwdHasSuffix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPwd), v))
	})
}

// PwdIsNil applies the IsNil predicate on the "pwd" field.
func PwdIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPwd)))
	})
}

// PwdNotNil applies the NotNil predicate on the "pwd" field.
func PwdNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPwd)))
	})
}

// PwdEqualFold applies the EqualFold predicate on the "pwd" field.
func PwdEqualFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPwd), v))
	})
}

// PwdContainsFold applies the ContainsFold predicate on the "pwd" field.
func PwdContainsFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPwd), v))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v bool) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v bool) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIsNil applies the IsNil predicate on the "status" field.
func StatusIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatus)))
	})
}

// StatusNotNil applies the NotNil predicate on the "status" field.
func StatusNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatus)))
	})
}

// DbTypeEQ applies the EQ predicate on the "dbType" field.
func DbTypeEQ(v DbType) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDbType), v))
	})
}

// DbTypeNEQ applies the NEQ predicate on the "dbType" field.
func DbTypeNEQ(v DbType) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDbType), v))
	})
}

// DbTypeIn applies the In predicate on the "dbType" field.
func DbTypeIn(vs ...DbType) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDbType), v...))
	})
}

// DbTypeNotIn applies the NotIn predicate on the "dbType" field.
func DbTypeNotIn(vs ...DbType) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDbType), v...))
	})
}

// DbTypeIsNil applies the IsNil predicate on the "dbType" field.
func DbTypeIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDbType)))
	})
}

// DbTypeNotNil applies the NotNil predicate on the "dbType" field.
func DbTypeNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDbType)))
	})
}

// ConnMaxIdleTimeEQ applies the EQ predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxIdleTimeNEQ applies the NEQ predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeNEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxIdleTimeIn applies the In predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldConnMaxIdleTime), v...))
	})
}

// ConnMaxIdleTimeNotIn applies the NotIn predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeNotIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldConnMaxIdleTime), v...))
	})
}

// ConnMaxIdleTimeGT applies the GT predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeGT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxIdleTimeGTE applies the GTE predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeGTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxIdleTimeLT applies the LT predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeLT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxIdleTimeLTE applies the LTE predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeLTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldConnMaxIdleTime), v))
	})
}

// ConnMaxIdleTimeIsNil applies the IsNil predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldConnMaxIdleTime)))
	})
}

// ConnMaxIdleTimeNotNil applies the NotNil predicate on the "connMaxIdleTime" field.
func ConnMaxIdleTimeNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldConnMaxIdleTime)))
	})
}

// ConnMaxLifeTimeEQ applies the EQ predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldConnMaxLifeTime), v))
	})
}

// ConnMaxLifeTimeNEQ applies the NEQ predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeNEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldConnMaxLifeTime), v))
	})
}

// ConnMaxLifeTimeIn applies the In predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldConnMaxLifeTime), v...))
	})
}

// ConnMaxLifeTimeNotIn applies the NotIn predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeNotIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldConnMaxLifeTime), v...))
	})
}

// ConnMaxLifeTimeGT applies the GT predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeGT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldConnMaxLifeTime), v))
	})
}

// ConnMaxLifeTimeGTE applies the GTE predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeGTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldConnMaxLifeTime), v))
	})
}

// ConnMaxLifeTimeLT applies the LT predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeLT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldConnMaxLifeTime), v))
	})
}

// ConnMaxLifeTimeLTE applies the LTE predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeLTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldConnMaxLifeTime), v))
	})
}

// ConnMaxLifeTimeIsNil applies the IsNil predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldConnMaxLifeTime)))
	})
}

// ConnMaxLifeTimeNotNil applies the NotNil predicate on the "connMaxLifeTime" field.
func ConnMaxLifeTimeNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldConnMaxLifeTime)))
	})
}

// MaxIdleConnsEQ applies the EQ predicate on the "maxIdleConns" field.
func MaxIdleConnsEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxIdleConns), v))
	})
}

// MaxIdleConnsNEQ applies the NEQ predicate on the "maxIdleConns" field.
func MaxIdleConnsNEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMaxIdleConns), v))
	})
}

// MaxIdleConnsIn applies the In predicate on the "maxIdleConns" field.
func MaxIdleConnsIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMaxIdleConns), v...))
	})
}

// MaxIdleConnsNotIn applies the NotIn predicate on the "maxIdleConns" field.
func MaxIdleConnsNotIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMaxIdleConns), v...))
	})
}

// MaxIdleConnsGT applies the GT predicate on the "maxIdleConns" field.
func MaxIdleConnsGT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMaxIdleConns), v))
	})
}

// MaxIdleConnsGTE applies the GTE predicate on the "maxIdleConns" field.
func MaxIdleConnsGTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMaxIdleConns), v))
	})
}

// MaxIdleConnsLT applies the LT predicate on the "maxIdleConns" field.
func MaxIdleConnsLT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMaxIdleConns), v))
	})
}

// MaxIdleConnsLTE applies the LTE predicate on the "maxIdleConns" field.
func MaxIdleConnsLTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMaxIdleConns), v))
	})
}

// MaxIdleConnsIsNil applies the IsNil predicate on the "maxIdleConns" field.
func MaxIdleConnsIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMaxIdleConns)))
	})
}

// MaxIdleConnsNotNil applies the NotNil predicate on the "maxIdleConns" field.
func MaxIdleConnsNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMaxIdleConns)))
	})
}

// MaxOpenConnsEQ applies the EQ predicate on the "maxOpenConns" field.
func MaxOpenConnsEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxOpenConns), v))
	})
}

// MaxOpenConnsNEQ applies the NEQ predicate on the "maxOpenConns" field.
func MaxOpenConnsNEQ(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMaxOpenConns), v))
	})
}

// MaxOpenConnsIn applies the In predicate on the "maxOpenConns" field.
func MaxOpenConnsIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMaxOpenConns), v...))
	})
}

// MaxOpenConnsNotIn applies the NotIn predicate on the "maxOpenConns" field.
func MaxOpenConnsNotIn(vs ...int32) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMaxOpenConns), v...))
	})
}

// MaxOpenConnsGT applies the GT predicate on the "maxOpenConns" field.
func MaxOpenConnsGT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMaxOpenConns), v))
	})
}

// MaxOpenConnsGTE applies the GTE predicate on the "maxOpenConns" field.
func MaxOpenConnsGTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMaxOpenConns), v))
	})
}

// MaxOpenConnsLT applies the LT predicate on the "maxOpenConns" field.
func MaxOpenConnsLT(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMaxOpenConns), v))
	})
}

// MaxOpenConnsLTE applies the LTE predicate on the "maxOpenConns" field.
func MaxOpenConnsLTE(v int32) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMaxOpenConns), v))
	})
}

// MaxOpenConnsIsNil applies the IsNil predicate on the "maxOpenConns" field.
func MaxOpenConnsIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMaxOpenConns)))
	})
}

// MaxOpenConnsNotNil applies the NotNil predicate on the "maxOpenConns" field.
func MaxOpenConnsNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMaxOpenConns)))
	})
}

// RemarkEQ applies the EQ predicate on the "remark" field.
func RemarkEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemark), v))
	})
}

// RemarkNEQ applies the NEQ predicate on the "remark" field.
func RemarkNEQ(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRemark), v))
	})
}

// RemarkIn applies the In predicate on the "remark" field.
func RemarkIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRemark), v...))
	})
}

// RemarkNotIn applies the NotIn predicate on the "remark" field.
func RemarkNotIn(vs ...string) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRemark), v...))
	})
}

// RemarkGT applies the GT predicate on the "remark" field.
func RemarkGT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRemark), v))
	})
}

// RemarkGTE applies the GTE predicate on the "remark" field.
func RemarkGTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRemark), v))
	})
}

// RemarkLT applies the LT predicate on the "remark" field.
func RemarkLT(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRemark), v))
	})
}

// RemarkLTE applies the LTE predicate on the "remark" field.
func RemarkLTE(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRemark), v))
	})
}

// RemarkContains applies the Contains predicate on the "remark" field.
func RemarkContains(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRemark), v))
	})
}

// RemarkHasPrefix applies the HasPrefix predicate on the "remark" field.
func RemarkHasPrefix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRemark), v))
	})
}

// RemarkHasSuffix applies the HasSuffix predicate on the "remark" field.
func RemarkHasSuffix(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRemark), v))
	})
}

// RemarkIsNil applies the IsNil predicate on the "remark" field.
func RemarkIsNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRemark)))
	})
}

// RemarkNotNil applies the NotNil predicate on the "remark" field.
func RemarkNotNil() predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRemark)))
	})
}

// RemarkEqualFold applies the EqualFold predicate on the "remark" field.
func RemarkEqualFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRemark), v))
	})
}

// RemarkContainsFold applies the ContainsFold predicate on the "remark" field.
func RemarkContainsFold(v string) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRemark), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "createdAt" field.
func CreatedAtEQ(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "createdAt" field.
func CreatedAtNEQ(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "createdAt" field.
func CreatedAtIn(vs ...time.Time) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "createdAt" field.
func CreatedAtNotIn(vs ...time.Time) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "createdAt" field.
func CreatedAtGT(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "createdAt" field.
func CreatedAtGTE(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "createdAt" field.
func CreatedAtLT(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "createdAt" field.
func CreatedAtLTE(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updatedAt" field.
func UpdatedAtEQ(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updatedAt" field.
func UpdatedAtNEQ(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updatedAt" field.
func UpdatedAtIn(vs ...time.Time) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updatedAt" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updatedAt" field.
func UpdatedAtGT(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updatedAt" field.
func UpdatedAtGTE(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updatedAt" field.
func UpdatedAtLT(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updatedAt" field.
func UpdatedAtLTE(v time.Time) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// CreateByEQ applies the EQ predicate on the "createBy" field.
func CreateByEQ(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateBy), v))
	})
}

// CreateByNEQ applies the NEQ predicate on the "createBy" field.
func CreateByNEQ(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateBy), v))
	})
}

// CreateByIn applies the In predicate on the "createBy" field.
func CreateByIn(vs ...int64) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateBy), v...))
	})
}

// CreateByNotIn applies the NotIn predicate on the "createBy" field.
func CreateByNotIn(vs ...int64) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateBy), v...))
	})
}

// CreateByGT applies the GT predicate on the "createBy" field.
func CreateByGT(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateBy), v))
	})
}

// CreateByGTE applies the GTE predicate on the "createBy" field.
func CreateByGTE(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateBy), v))
	})
}

// CreateByLT applies the LT predicate on the "createBy" field.
func CreateByLT(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateBy), v))
	})
}

// CreateByLTE applies the LTE predicate on the "createBy" field.
func CreateByLTE(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateBy), v))
	})
}

// UpdateByEQ applies the EQ predicate on the "updateBy" field.
func UpdateByEQ(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateBy), v))
	})
}

// UpdateByNEQ applies the NEQ predicate on the "updateBy" field.
func UpdateByNEQ(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateBy), v))
	})
}

// UpdateByIn applies the In predicate on the "updateBy" field.
func UpdateByIn(vs ...int64) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateBy), v...))
	})
}

// UpdateByNotIn applies the NotIn predicate on the "updateBy" field.
func UpdateByNotIn(vs ...int64) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateBy), v...))
	})
}

// UpdateByGT applies the GT predicate on the "updateBy" field.
func UpdateByGT(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateBy), v))
	})
}

// UpdateByGTE applies the GTE predicate on the "updateBy" field.
func UpdateByGTE(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateBy), v))
	})
}

// UpdateByLT applies the LT predicate on the "updateBy" field.
func UpdateByLT(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateBy), v))
	})
}

// UpdateByLTE applies the LTE predicate on the "updateBy" field.
func UpdateByLTE(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateBy), v))
	})
}

// TenantIdEQ applies the EQ predicate on the "tenantId" field.
func TenantIdEQ(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantId), v))
	})
}

// TenantIdNEQ applies the NEQ predicate on the "tenantId" field.
func TenantIdNEQ(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTenantId), v))
	})
}

// TenantIdIn applies the In predicate on the "tenantId" field.
func TenantIdIn(vs ...int64) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTenantId), v...))
	})
}

// TenantIdNotIn applies the NotIn predicate on the "tenantId" field.
func TenantIdNotIn(vs ...int64) predicate.DataSource {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.DataSource(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTenantId), v...))
	})
}

// TenantIdGT applies the GT predicate on the "tenantId" field.
func TenantIdGT(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTenantId), v))
	})
}

// TenantIdGTE applies the GTE predicate on the "tenantId" field.
func TenantIdGTE(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTenantId), v))
	})
}

// TenantIdLT applies the LT predicate on the "tenantId" field.
func TenantIdLT(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTenantId), v))
	})
}

// TenantIdLTE applies the LTE predicate on the "tenantId" field.
func TenantIdLTE(v int64) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTenantId), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.DataSource) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.DataSource) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.DataSource) predicate.DataSource {
	return predicate.DataSource(func(s *sql.Selector) {
		p(s.Not())
	})
}
