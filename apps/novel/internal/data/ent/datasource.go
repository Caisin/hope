// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"hope/apps/novel/internal/data/ent/datasource"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// DataSource is the model entity for the DataSource schema.
type DataSource struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// DbName holds the value of the "dbName" field.
	// 数据源名称
	DbName string `json:"dbName,omitempty"`
	// Host holds the value of the "host" field.
	// 数据源名称
	Host string `json:"host,omitempty"`
	// Port holds the value of the "port" field.
	// 数据源名称
	Port int32 `json:"port,omitempty"`
	// Database holds the value of the "database" field.
	// 数据源名称
	Database string `json:"database,omitempty"`
	// UserName holds the value of the "userName" field.
	// 用户名
	UserName string `json:"userName,omitempty"`
	// Pwd holds the value of the "pwd" field.
	// 密码
	Pwd string `json:"pwd,omitempty"`
	// Status holds the value of the "status" field.
	// 状态
	Status bool `json:"status,omitempty"`
	// DbType holds the value of the "dbType" field.
	// 数据库类型
	DbType datasource.DbType `json:"dbType,omitempty"`
	// ConnMaxIdleTime holds the value of the "connMaxIdleTime" field.
	// 最大空闲连接数
	ConnMaxIdleTime int32 `json:"connMaxIdleTime,omitempty"`
	// ConnMaxLifeTime holds the value of the "connMaxLifeTime" field.
	// 连接可重用的最大时间长度
	ConnMaxLifeTime int32 `json:"connMaxLifeTime,omitempty"`
	// MaxIdleConns holds the value of the "maxIdleConns" field.
	// 最大空闲
	MaxIdleConns int32 `json:"maxIdleConns,omitempty"`
	// MaxOpenConns holds the value of the "maxOpenConns" field.
	// 最大打开连接数
	MaxOpenConns int32 `json:"maxOpenConns,omitempty"`
	// Remark holds the value of the "remark" field.
	// 备注
	Remark string `json:"remark,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	// 创建时间
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	// 更新时间
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
	// CreateBy holds the value of the "createBy" field.
	// 创建者
	CreateBy int64 `json:"createBy,omitempty"`
	// UpdateBy holds the value of the "updateBy" field.
	// 更新者
	UpdateBy int64 `json:"updateBy,omitempty"`
	// TenantId holds the value of the "tenantId" field.
	// 租户
	TenantId int64 `json:"tenantId,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*DataSource) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case datasource.FieldStatus:
			values[i] = new(sql.NullBool)
		case datasource.FieldID, datasource.FieldPort, datasource.FieldConnMaxIdleTime, datasource.FieldConnMaxLifeTime, datasource.FieldMaxIdleConns, datasource.FieldMaxOpenConns, datasource.FieldCreateBy, datasource.FieldUpdateBy, datasource.FieldTenantId:
			values[i] = new(sql.NullInt64)
		case datasource.FieldDbName, datasource.FieldHost, datasource.FieldDatabase, datasource.FieldUserName, datasource.FieldPwd, datasource.FieldDbType, datasource.FieldRemark:
			values[i] = new(sql.NullString)
		case datasource.FieldCreatedAt, datasource.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type DataSource", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the DataSource fields.
func (ds *DataSource) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case datasource.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ds.ID = int64(value.Int64)
		case datasource.FieldDbName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dbName", values[i])
			} else if value.Valid {
				ds.DbName = value.String
			}
		case datasource.FieldHost:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field host", values[i])
			} else if value.Valid {
				ds.Host = value.String
			}
		case datasource.FieldPort:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field port", values[i])
			} else if value.Valid {
				ds.Port = int32(value.Int64)
			}
		case datasource.FieldDatabase:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field database", values[i])
			} else if value.Valid {
				ds.Database = value.String
			}
		case datasource.FieldUserName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field userName", values[i])
			} else if value.Valid {
				ds.UserName = value.String
			}
		case datasource.FieldPwd:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pwd", values[i])
			} else if value.Valid {
				ds.Pwd = value.String
			}
		case datasource.FieldStatus:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				ds.Status = value.Bool
			}
		case datasource.FieldDbType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dbType", values[i])
			} else if value.Valid {
				ds.DbType = datasource.DbType(value.String)
			}
		case datasource.FieldConnMaxIdleTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field connMaxIdleTime", values[i])
			} else if value.Valid {
				ds.ConnMaxIdleTime = int32(value.Int64)
			}
		case datasource.FieldConnMaxLifeTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field connMaxLifeTime", values[i])
			} else if value.Valid {
				ds.ConnMaxLifeTime = int32(value.Int64)
			}
		case datasource.FieldMaxIdleConns:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field maxIdleConns", values[i])
			} else if value.Valid {
				ds.MaxIdleConns = int32(value.Int64)
			}
		case datasource.FieldMaxOpenConns:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field maxOpenConns", values[i])
			} else if value.Valid {
				ds.MaxOpenConns = int32(value.Int64)
			}
		case datasource.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				ds.Remark = value.String
			}
		case datasource.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdAt", values[i])
			} else if value.Valid {
				ds.CreatedAt = value.Time
			}
		case datasource.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedAt", values[i])
			} else if value.Valid {
				ds.UpdatedAt = value.Time
			}
		case datasource.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field createBy", values[i])
			} else if value.Valid {
				ds.CreateBy = value.Int64
			}
		case datasource.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updateBy", values[i])
			} else if value.Valid {
				ds.UpdateBy = value.Int64
			}
		case datasource.FieldTenantId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenantId", values[i])
			} else if value.Valid {
				ds.TenantId = value.Int64
			}
		}
	}
	return nil
}

// Update returns a builder for updating this DataSource.
// Note that you need to call DataSource.Unwrap() before calling this method if this DataSource
// was returned from a transaction, and the transaction was committed or rolled back.
func (ds *DataSource) Update() *DataSourceUpdateOne {
	return (&DataSourceClient{config: ds.config}).UpdateOne(ds)
}

// Unwrap unwraps the DataSource entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ds *DataSource) Unwrap() *DataSource {
	tx, ok := ds.config.driver.(*txDriver)
	if !ok {
		panic("ent: DataSource is not a transactional entity")
	}
	ds.config.driver = tx.drv
	return ds
}

// String implements the fmt.Stringer.
func (ds *DataSource) String() string {
	var builder strings.Builder
	builder.WriteString("DataSource(")
	builder.WriteString(fmt.Sprintf("id=%v", ds.ID))
	builder.WriteString(", dbName=")
	builder.WriteString(ds.DbName)
	builder.WriteString(", host=")
	builder.WriteString(ds.Host)
	builder.WriteString(", port=")
	builder.WriteString(fmt.Sprintf("%v", ds.Port))
	builder.WriteString(", database=")
	builder.WriteString(ds.Database)
	builder.WriteString(", userName=")
	builder.WriteString(ds.UserName)
	builder.WriteString(", pwd=")
	builder.WriteString(ds.Pwd)
	builder.WriteString(", status=")
	builder.WriteString(fmt.Sprintf("%v", ds.Status))
	builder.WriteString(", dbType=")
	builder.WriteString(fmt.Sprintf("%v", ds.DbType))
	builder.WriteString(", connMaxIdleTime=")
	builder.WriteString(fmt.Sprintf("%v", ds.ConnMaxIdleTime))
	builder.WriteString(", connMaxLifeTime=")
	builder.WriteString(fmt.Sprintf("%v", ds.ConnMaxLifeTime))
	builder.WriteString(", maxIdleConns=")
	builder.WriteString(fmt.Sprintf("%v", ds.MaxIdleConns))
	builder.WriteString(", maxOpenConns=")
	builder.WriteString(fmt.Sprintf("%v", ds.MaxOpenConns))
	builder.WriteString(", remark=")
	builder.WriteString(ds.Remark)
	builder.WriteString(", createdAt=")
	builder.WriteString(ds.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updatedAt=")
	builder.WriteString(ds.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", createBy=")
	builder.WriteString(fmt.Sprintf("%v", ds.CreateBy))
	builder.WriteString(", updateBy=")
	builder.WriteString(fmt.Sprintf("%v", ds.UpdateBy))
	builder.WriteString(", tenantId=")
	builder.WriteString(fmt.Sprintf("%v", ds.TenantId))
	builder.WriteByte(')')
	return builder.String()
}

// DataSources is a parsable slice of DataSource.
type DataSources []*DataSource

func (ds DataSources) config(cfg config) {
	for _i := range ds {
		ds[_i].config = cfg
	}
}
