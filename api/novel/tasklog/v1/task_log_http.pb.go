// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type TaskLogHTTPServer interface {
	BatchDeleteTaskLog(context.Context, *TaskLogBatchDeleteReq) (*TaskLogDeleteReply, error)
	CreateTaskLog(context.Context, *TaskLogCreateReq) (*TaskLogCreateReply, error)
	DeleteTaskLog(context.Context, *TaskLogDeleteReq) (*TaskLogDeleteReply, error)
	GetPageTaskLog(context.Context, *TaskLogPageReq) (*TaskLogPageReply, error)
	GetTaskLog(context.Context, *TaskLogReq) (*TaskLogReply, error)
	UpdateTaskLog(context.Context, *TaskLogUpdateReq) (*TaskLogUpdateReply, error)
}

func RegisterTaskLogHTTPServer(s *http.Server, srv TaskLogHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/tasklog/page", _TaskLog_GetPageTaskLog0_HTTP_Handler(srv))
	r.GET("/v1/tasklog/{id}", _TaskLog_GetTaskLog0_HTTP_Handler(srv))
	r.PUT("/v1/tasklog/{id}", _TaskLog_UpdateTaskLog0_HTTP_Handler(srv))
	r.POST("/v1/tasklog", _TaskLog_CreateTaskLog0_HTTP_Handler(srv))
	r.DELETE("/v1/tasklog/{id}", _TaskLog_DeleteTaskLog0_HTTP_Handler(srv))
	r.DELETE("/v1/tasklog", _TaskLog_BatchDeleteTaskLog0_HTTP_Handler(srv))
}

func _TaskLog_GetPageTaskLog0_HTTP_Handler(srv TaskLogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TaskLogPageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/tasklog.v1.TaskLog/GetPageTaskLog")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetPageTaskLog(ctx, req.(*TaskLogPageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TaskLogPageReply)
		return ctx.Result(200, reply)
	}
}

func _TaskLog_GetTaskLog0_HTTP_Handler(srv TaskLogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TaskLogReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/tasklog.v1.TaskLog/GetTaskLog")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTaskLog(ctx, req.(*TaskLogReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TaskLogReply)
		return ctx.Result(200, reply)
	}
}

func _TaskLog_UpdateTaskLog0_HTTP_Handler(srv TaskLogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TaskLogUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/tasklog.v1.TaskLog/UpdateTaskLog")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateTaskLog(ctx, req.(*TaskLogUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TaskLogUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _TaskLog_CreateTaskLog0_HTTP_Handler(srv TaskLogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TaskLogCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/tasklog.v1.TaskLog/CreateTaskLog")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTaskLog(ctx, req.(*TaskLogCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TaskLogCreateReply)
		return ctx.Result(200, reply)
	}
}

func _TaskLog_DeleteTaskLog0_HTTP_Handler(srv TaskLogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TaskLogDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/tasklog.v1.TaskLog/DeleteTaskLog")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteTaskLog(ctx, req.(*TaskLogDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TaskLogDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _TaskLog_BatchDeleteTaskLog0_HTTP_Handler(srv TaskLogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TaskLogBatchDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/tasklog.v1.TaskLog/BatchDeleteTaskLog")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteTaskLog(ctx, req.(*TaskLogBatchDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TaskLogDeleteReply)
		return ctx.Result(200, reply)
	}
}

type TaskLogHTTPClient interface {
	BatchDeleteTaskLog(ctx context.Context, req *TaskLogBatchDeleteReq, opts ...http.CallOption) (rsp *TaskLogDeleteReply, err error)
	CreateTaskLog(ctx context.Context, req *TaskLogCreateReq, opts ...http.CallOption) (rsp *TaskLogCreateReply, err error)
	DeleteTaskLog(ctx context.Context, req *TaskLogDeleteReq, opts ...http.CallOption) (rsp *TaskLogDeleteReply, err error)
	GetPageTaskLog(ctx context.Context, req *TaskLogPageReq, opts ...http.CallOption) (rsp *TaskLogPageReply, err error)
	GetTaskLog(ctx context.Context, req *TaskLogReq, opts ...http.CallOption) (rsp *TaskLogReply, err error)
	UpdateTaskLog(ctx context.Context, req *TaskLogUpdateReq, opts ...http.CallOption) (rsp *TaskLogUpdateReply, err error)
}

type TaskLogHTTPClientImpl struct {
	cc *http.Client
}

func NewTaskLogHTTPClient(client *http.Client) TaskLogHTTPClient {
	return &TaskLogHTTPClientImpl{client}
}

func (c *TaskLogHTTPClientImpl) BatchDeleteTaskLog(ctx context.Context, in *TaskLogBatchDeleteReq, opts ...http.CallOption) (*TaskLogDeleteReply, error) {
	var out TaskLogDeleteReply
	pattern := "/v1/tasklog"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/tasklog.v1.TaskLog/BatchDeleteTaskLog"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TaskLogHTTPClientImpl) CreateTaskLog(ctx context.Context, in *TaskLogCreateReq, opts ...http.CallOption) (*TaskLogCreateReply, error) {
	var out TaskLogCreateReply
	pattern := "/v1/tasklog"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/tasklog.v1.TaskLog/CreateTaskLog"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TaskLogHTTPClientImpl) DeleteTaskLog(ctx context.Context, in *TaskLogDeleteReq, opts ...http.CallOption) (*TaskLogDeleteReply, error) {
	var out TaskLogDeleteReply
	pattern := "/v1/tasklog/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/tasklog.v1.TaskLog/DeleteTaskLog"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TaskLogHTTPClientImpl) GetPageTaskLog(ctx context.Context, in *TaskLogPageReq, opts ...http.CallOption) (*TaskLogPageReply, error) {
	var out TaskLogPageReply
	pattern := "/v1/tasklog/page"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/tasklog.v1.TaskLog/GetPageTaskLog"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TaskLogHTTPClientImpl) GetTaskLog(ctx context.Context, in *TaskLogReq, opts ...http.CallOption) (*TaskLogReply, error) {
	var out TaskLogReply
	pattern := "/v1/tasklog/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/tasklog.v1.TaskLog/GetTaskLog"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TaskLogHTTPClientImpl) UpdateTaskLog(ctx context.Context, in *TaskLogUpdateReq, opts ...http.CallOption) (*TaskLogUpdateReply, error) {
	var out TaskLogUpdateReply
	pattern := "/v1/tasklog/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/tasklog.v1.TaskLog/UpdateTaskLog"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
