// Code generated by entc, DO NOT EDIT.

package socialuser

import (
	"hope/apps/novel/internal/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// UserId applies equality check predicate on the "userId" field. It's identical to UserIdEQ.
func UserId(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserId), v))
	})
}

// Unionid applies equality check predicate on the "unionid" field. It's identical to UnionidEQ.
func Unionid(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnionid), v))
	})
}

// Token applies equality check predicate on the "token" field. It's identical to TokenEQ.
func Token(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToken), v))
	})
}

// Openid applies equality check predicate on the "openid" field. It's identical to OpenidEQ.
func Openid(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOpenid), v))
	})
}

// RoutineOpenid applies equality check predicate on the "routineOpenid" field. It's identical to RoutineOpenidEQ.
func RoutineOpenid(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoutineOpenid), v))
	})
}

// UserName applies equality check predicate on the "userName" field. It's identical to UserNameEQ.
func UserName(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserName), v))
	})
}

// NickName applies equality check predicate on the "nickName" field. It's identical to NickNameEQ.
func NickName(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNickName), v))
	})
}

// Birthday applies equality check predicate on the "birthday" field. It's identical to BirthdayEQ.
func Birthday(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBirthday), v))
	})
}

// Phone applies equality check predicate on the "phone" field. It's identical to PhoneEQ.
func Phone(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPhone), v))
	})
}

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// Password applies equality check predicate on the "password" field. It's identical to PasswordEQ.
func Password(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPassword), v))
	})
}

// Avatar applies equality check predicate on the "avatar" field. It's identical to AvatarEQ.
func Avatar(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAvatar), v))
	})
}

// Sex applies equality check predicate on the "sex" field. It's identical to SexEQ.
func Sex(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSex), v))
	})
}

// Region applies equality check predicate on the "region" field. It's identical to RegionEQ.
func Region(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRegion), v))
	})
}

// City applies equality check predicate on the "city" field. It's identical to CityEQ.
func City(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCity), v))
	})
}

// Language applies equality check predicate on the "language" field. It's identical to LanguageEQ.
func Language(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLanguage), v))
	})
}

// Province applies equality check predicate on the "province" field. It's identical to ProvinceEQ.
func Province(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProvince), v))
	})
}

// Country applies equality check predicate on the "country" field. It's identical to CountryEQ.
func Country(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCountry), v))
	})
}

// Signature applies equality check predicate on the "signature" field. It's identical to SignatureEQ.
func Signature(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSignature), v))
	})
}

// Remark applies equality check predicate on the "remark" field. It's identical to RemarkEQ.
func Remark(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemark), v))
	})
}

// Groupid applies equality check predicate on the "groupid" field. It's identical to GroupidEQ.
func Groupid(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGroupid), v))
	})
}

// TagidList applies equality check predicate on the "tagidList" field. It's identical to TagidListEQ.
func TagidList(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTagidList), v))
	})
}

// Subscribe applies equality check predicate on the "subscribe" field. It's identical to SubscribeEQ.
func Subscribe(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSubscribe), v))
	})
}

// SubscribeTime applies equality check predicate on the "subscribeTime" field. It's identical to SubscribeTimeEQ.
func SubscribeTime(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSubscribeTime), v))
	})
}

// SessionKey applies equality check predicate on the "sessionKey" field. It's identical to SessionKeyEQ.
func SessionKey(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSessionKey), v))
	})
}

// UserType applies equality check predicate on the "userType" field. It's identical to UserTypeEQ.
func UserType(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserType), v))
	})
}

// CreatedAt applies equality check predicate on the "createdAt" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updatedAt" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// CreateBy applies equality check predicate on the "createBy" field. It's identical to CreateByEQ.
func CreateBy(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateBy), v))
	})
}

// UpdateBy applies equality check predicate on the "updateBy" field. It's identical to UpdateByEQ.
func UpdateBy(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateBy), v))
	})
}

// TenantId applies equality check predicate on the "tenantId" field. It's identical to TenantIdEQ.
func TenantId(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantId), v))
	})
}

// UserIdEQ applies the EQ predicate on the "userId" field.
func UserIdEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserId), v))
	})
}

// UserIdNEQ applies the NEQ predicate on the "userId" field.
func UserIdNEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserId), v))
	})
}

// UserIdIn applies the In predicate on the "userId" field.
func UserIdIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserId), v...))
	})
}

// UserIdNotIn applies the NotIn predicate on the "userId" field.
func UserIdNotIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserId), v...))
	})
}

// UserIdGT applies the GT predicate on the "userId" field.
func UserIdGT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserId), v))
	})
}

// UserIdGTE applies the GTE predicate on the "userId" field.
func UserIdGTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserId), v))
	})
}

// UserIdLT applies the LT predicate on the "userId" field.
func UserIdLT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserId), v))
	})
}

// UserIdLTE applies the LTE predicate on the "userId" field.
func UserIdLTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserId), v))
	})
}

// UnionidEQ applies the EQ predicate on the "unionid" field.
func UnionidEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUnionid), v))
	})
}

// UnionidNEQ applies the NEQ predicate on the "unionid" field.
func UnionidNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUnionid), v))
	})
}

// UnionidIn applies the In predicate on the "unionid" field.
func UnionidIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUnionid), v...))
	})
}

// UnionidNotIn applies the NotIn predicate on the "unionid" field.
func UnionidNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUnionid), v...))
	})
}

// UnionidGT applies the GT predicate on the "unionid" field.
func UnionidGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUnionid), v))
	})
}

// UnionidGTE applies the GTE predicate on the "unionid" field.
func UnionidGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUnionid), v))
	})
}

// UnionidLT applies the LT predicate on the "unionid" field.
func UnionidLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUnionid), v))
	})
}

// UnionidLTE applies the LTE predicate on the "unionid" field.
func UnionidLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUnionid), v))
	})
}

// UnionidContains applies the Contains predicate on the "unionid" field.
func UnionidContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUnionid), v))
	})
}

// UnionidHasPrefix applies the HasPrefix predicate on the "unionid" field.
func UnionidHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUnionid), v))
	})
}

// UnionidHasSuffix applies the HasSuffix predicate on the "unionid" field.
func UnionidHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUnionid), v))
	})
}

// UnionidIsNil applies the IsNil predicate on the "unionid" field.
func UnionidIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUnionid)))
	})
}

// UnionidNotNil applies the NotNil predicate on the "unionid" field.
func UnionidNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUnionid)))
	})
}

// UnionidEqualFold applies the EqualFold predicate on the "unionid" field.
func UnionidEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUnionid), v))
	})
}

// UnionidContainsFold applies the ContainsFold predicate on the "unionid" field.
func UnionidContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUnionid), v))
	})
}

// TokenEQ applies the EQ predicate on the "token" field.
func TokenEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToken), v))
	})
}

// TokenNEQ applies the NEQ predicate on the "token" field.
func TokenNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldToken), v))
	})
}

// TokenIn applies the In predicate on the "token" field.
func TokenIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldToken), v...))
	})
}

// TokenNotIn applies the NotIn predicate on the "token" field.
func TokenNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldToken), v...))
	})
}

// TokenGT applies the GT predicate on the "token" field.
func TokenGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldToken), v))
	})
}

// TokenGTE applies the GTE predicate on the "token" field.
func TokenGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldToken), v))
	})
}

// TokenLT applies the LT predicate on the "token" field.
func TokenLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldToken), v))
	})
}

// TokenLTE applies the LTE predicate on the "token" field.
func TokenLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldToken), v))
	})
}

// TokenContains applies the Contains predicate on the "token" field.
func TokenContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldToken), v))
	})
}

// TokenHasPrefix applies the HasPrefix predicate on the "token" field.
func TokenHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldToken), v))
	})
}

// TokenHasSuffix applies the HasSuffix predicate on the "token" field.
func TokenHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldToken), v))
	})
}

// TokenIsNil applies the IsNil predicate on the "token" field.
func TokenIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldToken)))
	})
}

// TokenNotNil applies the NotNil predicate on the "token" field.
func TokenNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldToken)))
	})
}

// TokenEqualFold applies the EqualFold predicate on the "token" field.
func TokenEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldToken), v))
	})
}

// TokenContainsFold applies the ContainsFold predicate on the "token" field.
func TokenContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldToken), v))
	})
}

// OpenidEQ applies the EQ predicate on the "openid" field.
func OpenidEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOpenid), v))
	})
}

// OpenidNEQ applies the NEQ predicate on the "openid" field.
func OpenidNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOpenid), v))
	})
}

// OpenidIn applies the In predicate on the "openid" field.
func OpenidIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOpenid), v...))
	})
}

// OpenidNotIn applies the NotIn predicate on the "openid" field.
func OpenidNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOpenid), v...))
	})
}

// OpenidGT applies the GT predicate on the "openid" field.
func OpenidGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOpenid), v))
	})
}

// OpenidGTE applies the GTE predicate on the "openid" field.
func OpenidGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOpenid), v))
	})
}

// OpenidLT applies the LT predicate on the "openid" field.
func OpenidLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOpenid), v))
	})
}

// OpenidLTE applies the LTE predicate on the "openid" field.
func OpenidLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOpenid), v))
	})
}

// OpenidContains applies the Contains predicate on the "openid" field.
func OpenidContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOpenid), v))
	})
}

// OpenidHasPrefix applies the HasPrefix predicate on the "openid" field.
func OpenidHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOpenid), v))
	})
}

// OpenidHasSuffix applies the HasSuffix predicate on the "openid" field.
func OpenidHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOpenid), v))
	})
}

// OpenidIsNil applies the IsNil predicate on the "openid" field.
func OpenidIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldOpenid)))
	})
}

// OpenidNotNil applies the NotNil predicate on the "openid" field.
func OpenidNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldOpenid)))
	})
}

// OpenidEqualFold applies the EqualFold predicate on the "openid" field.
func OpenidEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOpenid), v))
	})
}

// OpenidContainsFold applies the ContainsFold predicate on the "openid" field.
func OpenidContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOpenid), v))
	})
}

// RoutineOpenidEQ applies the EQ predicate on the "routineOpenid" field.
func RoutineOpenidEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidNEQ applies the NEQ predicate on the "routineOpenid" field.
func RoutineOpenidNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidIn applies the In predicate on the "routineOpenid" field.
func RoutineOpenidIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRoutineOpenid), v...))
	})
}

// RoutineOpenidNotIn applies the NotIn predicate on the "routineOpenid" field.
func RoutineOpenidNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRoutineOpenid), v...))
	})
}

// RoutineOpenidGT applies the GT predicate on the "routineOpenid" field.
func RoutineOpenidGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidGTE applies the GTE predicate on the "routineOpenid" field.
func RoutineOpenidGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidLT applies the LT predicate on the "routineOpenid" field.
func RoutineOpenidLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidLTE applies the LTE predicate on the "routineOpenid" field.
func RoutineOpenidLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidContains applies the Contains predicate on the "routineOpenid" field.
func RoutineOpenidContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidHasPrefix applies the HasPrefix predicate on the "routineOpenid" field.
func RoutineOpenidHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidHasSuffix applies the HasSuffix predicate on the "routineOpenid" field.
func RoutineOpenidHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidIsNil applies the IsNil predicate on the "routineOpenid" field.
func RoutineOpenidIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRoutineOpenid)))
	})
}

// RoutineOpenidNotNil applies the NotNil predicate on the "routineOpenid" field.
func RoutineOpenidNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRoutineOpenid)))
	})
}

// RoutineOpenidEqualFold applies the EqualFold predicate on the "routineOpenid" field.
func RoutineOpenidEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRoutineOpenid), v))
	})
}

// RoutineOpenidContainsFold applies the ContainsFold predicate on the "routineOpenid" field.
func RoutineOpenidContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRoutineOpenid), v))
	})
}

// UserNameEQ applies the EQ predicate on the "userName" field.
func UserNameEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserName), v))
	})
}

// UserNameNEQ applies the NEQ predicate on the "userName" field.
func UserNameNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserName), v))
	})
}

// UserNameIn applies the In predicate on the "userName" field.
func UserNameIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserName), v...))
	})
}

// UserNameNotIn applies the NotIn predicate on the "userName" field.
func UserNameNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserName), v...))
	})
}

// UserNameGT applies the GT predicate on the "userName" field.
func UserNameGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserName), v))
	})
}

// UserNameGTE applies the GTE predicate on the "userName" field.
func UserNameGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserName), v))
	})
}

// UserNameLT applies the LT predicate on the "userName" field.
func UserNameLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserName), v))
	})
}

// UserNameLTE applies the LTE predicate on the "userName" field.
func UserNameLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserName), v))
	})
}

// UserNameContains applies the Contains predicate on the "userName" field.
func UserNameContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserName), v))
	})
}

// UserNameHasPrefix applies the HasPrefix predicate on the "userName" field.
func UserNameHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserName), v))
	})
}

// UserNameHasSuffix applies the HasSuffix predicate on the "userName" field.
func UserNameHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserName), v))
	})
}

// UserNameIsNil applies the IsNil predicate on the "userName" field.
func UserNameIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUserName)))
	})
}

// UserNameNotNil applies the NotNil predicate on the "userName" field.
func UserNameNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUserName)))
	})
}

// UserNameEqualFold applies the EqualFold predicate on the "userName" field.
func UserNameEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserName), v))
	})
}

// UserNameContainsFold applies the ContainsFold predicate on the "userName" field.
func UserNameContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserName), v))
	})
}

// NickNameEQ applies the EQ predicate on the "nickName" field.
func NickNameEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNickName), v))
	})
}

// NickNameNEQ applies the NEQ predicate on the "nickName" field.
func NickNameNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNickName), v))
	})
}

// NickNameIn applies the In predicate on the "nickName" field.
func NickNameIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNickName), v...))
	})
}

// NickNameNotIn applies the NotIn predicate on the "nickName" field.
func NickNameNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNickName), v...))
	})
}

// NickNameGT applies the GT predicate on the "nickName" field.
func NickNameGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNickName), v))
	})
}

// NickNameGTE applies the GTE predicate on the "nickName" field.
func NickNameGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNickName), v))
	})
}

// NickNameLT applies the LT predicate on the "nickName" field.
func NickNameLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNickName), v))
	})
}

// NickNameLTE applies the LTE predicate on the "nickName" field.
func NickNameLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNickName), v))
	})
}

// NickNameContains applies the Contains predicate on the "nickName" field.
func NickNameContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldNickName), v))
	})
}

// NickNameHasPrefix applies the HasPrefix predicate on the "nickName" field.
func NickNameHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldNickName), v))
	})
}

// NickNameHasSuffix applies the HasSuffix predicate on the "nickName" field.
func NickNameHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldNickName), v))
	})
}

// NickNameIsNil applies the IsNil predicate on the "nickName" field.
func NickNameIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldNickName)))
	})
}

// NickNameNotNil applies the NotNil predicate on the "nickName" field.
func NickNameNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldNickName)))
	})
}

// NickNameEqualFold applies the EqualFold predicate on the "nickName" field.
func NickNameEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldNickName), v))
	})
}

// NickNameContainsFold applies the ContainsFold predicate on the "nickName" field.
func NickNameContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldNickName), v))
	})
}

// BirthdayEQ applies the EQ predicate on the "birthday" field.
func BirthdayEQ(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBirthday), v))
	})
}

// BirthdayNEQ applies the NEQ predicate on the "birthday" field.
func BirthdayNEQ(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBirthday), v))
	})
}

// BirthdayIn applies the In predicate on the "birthday" field.
func BirthdayIn(vs ...time.Time) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBirthday), v...))
	})
}

// BirthdayNotIn applies the NotIn predicate on the "birthday" field.
func BirthdayNotIn(vs ...time.Time) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBirthday), v...))
	})
}

// BirthdayGT applies the GT predicate on the "birthday" field.
func BirthdayGT(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBirthday), v))
	})
}

// BirthdayGTE applies the GTE predicate on the "birthday" field.
func BirthdayGTE(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBirthday), v))
	})
}

// BirthdayLT applies the LT predicate on the "birthday" field.
func BirthdayLT(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBirthday), v))
	})
}

// BirthdayLTE applies the LTE predicate on the "birthday" field.
func BirthdayLTE(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBirthday), v))
	})
}

// BirthdayIsNil applies the IsNil predicate on the "birthday" field.
func BirthdayIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBirthday)))
	})
}

// BirthdayNotNil applies the NotNil predicate on the "birthday" field.
func BirthdayNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBirthday)))
	})
}

// PhoneEQ applies the EQ predicate on the "phone" field.
func PhoneEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPhone), v))
	})
}

// PhoneNEQ applies the NEQ predicate on the "phone" field.
func PhoneNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPhone), v))
	})
}

// PhoneIn applies the In predicate on the "phone" field.
func PhoneIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPhone), v...))
	})
}

// PhoneNotIn applies the NotIn predicate on the "phone" field.
func PhoneNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPhone), v...))
	})
}

// PhoneGT applies the GT predicate on the "phone" field.
func PhoneGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPhone), v))
	})
}

// PhoneGTE applies the GTE predicate on the "phone" field.
func PhoneGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPhone), v))
	})
}

// PhoneLT applies the LT predicate on the "phone" field.
func PhoneLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPhone), v))
	})
}

// PhoneLTE applies the LTE predicate on the "phone" field.
func PhoneLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPhone), v))
	})
}

// PhoneContains applies the Contains predicate on the "phone" field.
func PhoneContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPhone), v))
	})
}

// PhoneHasPrefix applies the HasPrefix predicate on the "phone" field.
func PhoneHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPhone), v))
	})
}

// PhoneHasSuffix applies the HasSuffix predicate on the "phone" field.
func PhoneHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPhone), v))
	})
}

// PhoneIsNil applies the IsNil predicate on the "phone" field.
func PhoneIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPhone)))
	})
}

// PhoneNotNil applies the NotNil predicate on the "phone" field.
func PhoneNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPhone)))
	})
}

// PhoneEqualFold applies the EqualFold predicate on the "phone" field.
func PhoneEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPhone), v))
	})
}

// PhoneContainsFold applies the ContainsFold predicate on the "phone" field.
func PhoneContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPhone), v))
	})
}

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEmail), v))
	})
}

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEmail), v...))
	})
}

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEmail), v...))
	})
}

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEmail), v))
	})
}

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEmail), v))
	})
}

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEmail), v))
	})
}

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEmail), v))
	})
}

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEmail), v))
	})
}

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEmail), v))
	})
}

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEmail), v))
	})
}

// EmailIsNil applies the IsNil predicate on the "email" field.
func EmailIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldEmail)))
	})
}

// EmailNotNil applies the NotNil predicate on the "email" field.
func EmailNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldEmail)))
	})
}

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEmail), v))
	})
}

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEmail), v))
	})
}

// PasswordEQ applies the EQ predicate on the "password" field.
func PasswordEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPassword), v))
	})
}

// PasswordNEQ applies the NEQ predicate on the "password" field.
func PasswordNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPassword), v))
	})
}

// PasswordIn applies the In predicate on the "password" field.
func PasswordIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPassword), v...))
	})
}

// PasswordNotIn applies the NotIn predicate on the "password" field.
func PasswordNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPassword), v...))
	})
}

// PasswordGT applies the GT predicate on the "password" field.
func PasswordGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPassword), v))
	})
}

// PasswordGTE applies the GTE predicate on the "password" field.
func PasswordGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPassword), v))
	})
}

// PasswordLT applies the LT predicate on the "password" field.
func PasswordLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPassword), v))
	})
}

// PasswordLTE applies the LTE predicate on the "password" field.
func PasswordLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPassword), v))
	})
}

// PasswordContains applies the Contains predicate on the "password" field.
func PasswordContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPassword), v))
	})
}

// PasswordHasPrefix applies the HasPrefix predicate on the "password" field.
func PasswordHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPassword), v))
	})
}

// PasswordHasSuffix applies the HasSuffix predicate on the "password" field.
func PasswordHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPassword), v))
	})
}

// PasswordIsNil applies the IsNil predicate on the "password" field.
func PasswordIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPassword)))
	})
}

// PasswordNotNil applies the NotNil predicate on the "password" field.
func PasswordNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPassword)))
	})
}

// PasswordEqualFold applies the EqualFold predicate on the "password" field.
func PasswordEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPassword), v))
	})
}

// PasswordContainsFold applies the ContainsFold predicate on the "password" field.
func PasswordContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPassword), v))
	})
}

// AvatarEQ applies the EQ predicate on the "avatar" field.
func AvatarEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAvatar), v))
	})
}

// AvatarNEQ applies the NEQ predicate on the "avatar" field.
func AvatarNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAvatar), v))
	})
}

// AvatarIn applies the In predicate on the "avatar" field.
func AvatarIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAvatar), v...))
	})
}

// AvatarNotIn applies the NotIn predicate on the "avatar" field.
func AvatarNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAvatar), v...))
	})
}

// AvatarGT applies the GT predicate on the "avatar" field.
func AvatarGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAvatar), v))
	})
}

// AvatarGTE applies the GTE predicate on the "avatar" field.
func AvatarGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAvatar), v))
	})
}

// AvatarLT applies the LT predicate on the "avatar" field.
func AvatarLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAvatar), v))
	})
}

// AvatarLTE applies the LTE predicate on the "avatar" field.
func AvatarLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAvatar), v))
	})
}

// AvatarContains applies the Contains predicate on the "avatar" field.
func AvatarContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAvatar), v))
	})
}

// AvatarHasPrefix applies the HasPrefix predicate on the "avatar" field.
func AvatarHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAvatar), v))
	})
}

// AvatarHasSuffix applies the HasSuffix predicate on the "avatar" field.
func AvatarHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAvatar), v))
	})
}

// AvatarIsNil applies the IsNil predicate on the "avatar" field.
func AvatarIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAvatar)))
	})
}

// AvatarNotNil applies the NotNil predicate on the "avatar" field.
func AvatarNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAvatar)))
	})
}

// AvatarEqualFold applies the EqualFold predicate on the "avatar" field.
func AvatarEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAvatar), v))
	})
}

// AvatarContainsFold applies the ContainsFold predicate on the "avatar" field.
func AvatarContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAvatar), v))
	})
}

// SexEQ applies the EQ predicate on the "sex" field.
func SexEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSex), v))
	})
}

// SexNEQ applies the NEQ predicate on the "sex" field.
func SexNEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSex), v))
	})
}

// SexIn applies the In predicate on the "sex" field.
func SexIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSex), v...))
	})
}

// SexNotIn applies the NotIn predicate on the "sex" field.
func SexNotIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSex), v...))
	})
}

// SexGT applies the GT predicate on the "sex" field.
func SexGT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSex), v))
	})
}

// SexGTE applies the GTE predicate on the "sex" field.
func SexGTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSex), v))
	})
}

// SexLT applies the LT predicate on the "sex" field.
func SexLT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSex), v))
	})
}

// SexLTE applies the LTE predicate on the "sex" field.
func SexLTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSex), v))
	})
}

// SexIsNil applies the IsNil predicate on the "sex" field.
func SexIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSex)))
	})
}

// SexNotNil applies the NotNil predicate on the "sex" field.
func SexNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSex)))
	})
}

// RegionEQ applies the EQ predicate on the "region" field.
func RegionEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRegion), v))
	})
}

// RegionNEQ applies the NEQ predicate on the "region" field.
func RegionNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRegion), v))
	})
}

// RegionIn applies the In predicate on the "region" field.
func RegionIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRegion), v...))
	})
}

// RegionNotIn applies the NotIn predicate on the "region" field.
func RegionNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRegion), v...))
	})
}

// RegionGT applies the GT predicate on the "region" field.
func RegionGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRegion), v))
	})
}

// RegionGTE applies the GTE predicate on the "region" field.
func RegionGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRegion), v))
	})
}

// RegionLT applies the LT predicate on the "region" field.
func RegionLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRegion), v))
	})
}

// RegionLTE applies the LTE predicate on the "region" field.
func RegionLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRegion), v))
	})
}

// RegionContains applies the Contains predicate on the "region" field.
func RegionContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRegion), v))
	})
}

// RegionHasPrefix applies the HasPrefix predicate on the "region" field.
func RegionHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRegion), v))
	})
}

// RegionHasSuffix applies the HasSuffix predicate on the "region" field.
func RegionHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRegion), v))
	})
}

// RegionIsNil applies the IsNil predicate on the "region" field.
func RegionIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRegion)))
	})
}

// RegionNotNil applies the NotNil predicate on the "region" field.
func RegionNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRegion)))
	})
}

// RegionEqualFold applies the EqualFold predicate on the "region" field.
func RegionEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRegion), v))
	})
}

// RegionContainsFold applies the ContainsFold predicate on the "region" field.
func RegionContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRegion), v))
	})
}

// CityEQ applies the EQ predicate on the "city" field.
func CityEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCity), v))
	})
}

// CityNEQ applies the NEQ predicate on the "city" field.
func CityNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCity), v))
	})
}

// CityIn applies the In predicate on the "city" field.
func CityIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCity), v...))
	})
}

// CityNotIn applies the NotIn predicate on the "city" field.
func CityNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCity), v...))
	})
}

// CityGT applies the GT predicate on the "city" field.
func CityGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCity), v))
	})
}

// CityGTE applies the GTE predicate on the "city" field.
func CityGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCity), v))
	})
}

// CityLT applies the LT predicate on the "city" field.
func CityLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCity), v))
	})
}

// CityLTE applies the LTE predicate on the "city" field.
func CityLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCity), v))
	})
}

// CityContains applies the Contains predicate on the "city" field.
func CityContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCity), v))
	})
}

// CityHasPrefix applies the HasPrefix predicate on the "city" field.
func CityHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCity), v))
	})
}

// CityHasSuffix applies the HasSuffix predicate on the "city" field.
func CityHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCity), v))
	})
}

// CityIsNil applies the IsNil predicate on the "city" field.
func CityIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCity)))
	})
}

// CityNotNil applies the NotNil predicate on the "city" field.
func CityNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCity)))
	})
}

// CityEqualFold applies the EqualFold predicate on the "city" field.
func CityEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCity), v))
	})
}

// CityContainsFold applies the ContainsFold predicate on the "city" field.
func CityContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCity), v))
	})
}

// LanguageEQ applies the EQ predicate on the "language" field.
func LanguageEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLanguage), v))
	})
}

// LanguageNEQ applies the NEQ predicate on the "language" field.
func LanguageNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLanguage), v))
	})
}

// LanguageIn applies the In predicate on the "language" field.
func LanguageIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLanguage), v...))
	})
}

// LanguageNotIn applies the NotIn predicate on the "language" field.
func LanguageNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLanguage), v...))
	})
}

// LanguageGT applies the GT predicate on the "language" field.
func LanguageGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLanguage), v))
	})
}

// LanguageGTE applies the GTE predicate on the "language" field.
func LanguageGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLanguage), v))
	})
}

// LanguageLT applies the LT predicate on the "language" field.
func LanguageLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLanguage), v))
	})
}

// LanguageLTE applies the LTE predicate on the "language" field.
func LanguageLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLanguage), v))
	})
}

// LanguageContains applies the Contains predicate on the "language" field.
func LanguageContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLanguage), v))
	})
}

// LanguageHasPrefix applies the HasPrefix predicate on the "language" field.
func LanguageHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLanguage), v))
	})
}

// LanguageHasSuffix applies the HasSuffix predicate on the "language" field.
func LanguageHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLanguage), v))
	})
}

// LanguageIsNil applies the IsNil predicate on the "language" field.
func LanguageIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLanguage)))
	})
}

// LanguageNotNil applies the NotNil predicate on the "language" field.
func LanguageNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLanguage)))
	})
}

// LanguageEqualFold applies the EqualFold predicate on the "language" field.
func LanguageEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLanguage), v))
	})
}

// LanguageContainsFold applies the ContainsFold predicate on the "language" field.
func LanguageContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLanguage), v))
	})
}

// ProvinceEQ applies the EQ predicate on the "province" field.
func ProvinceEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProvince), v))
	})
}

// ProvinceNEQ applies the NEQ predicate on the "province" field.
func ProvinceNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldProvince), v))
	})
}

// ProvinceIn applies the In predicate on the "province" field.
func ProvinceIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldProvince), v...))
	})
}

// ProvinceNotIn applies the NotIn predicate on the "province" field.
func ProvinceNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldProvince), v...))
	})
}

// ProvinceGT applies the GT predicate on the "province" field.
func ProvinceGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldProvince), v))
	})
}

// ProvinceGTE applies the GTE predicate on the "province" field.
func ProvinceGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldProvince), v))
	})
}

// ProvinceLT applies the LT predicate on the "province" field.
func ProvinceLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldProvince), v))
	})
}

// ProvinceLTE applies the LTE predicate on the "province" field.
func ProvinceLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldProvince), v))
	})
}

// ProvinceContains applies the Contains predicate on the "province" field.
func ProvinceContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldProvince), v))
	})
}

// ProvinceHasPrefix applies the HasPrefix predicate on the "province" field.
func ProvinceHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldProvince), v))
	})
}

// ProvinceHasSuffix applies the HasSuffix predicate on the "province" field.
func ProvinceHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldProvince), v))
	})
}

// ProvinceIsNil applies the IsNil predicate on the "province" field.
func ProvinceIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldProvince)))
	})
}

// ProvinceNotNil applies the NotNil predicate on the "province" field.
func ProvinceNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldProvince)))
	})
}

// ProvinceEqualFold applies the EqualFold predicate on the "province" field.
func ProvinceEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldProvince), v))
	})
}

// ProvinceContainsFold applies the ContainsFold predicate on the "province" field.
func ProvinceContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldProvince), v))
	})
}

// CountryEQ applies the EQ predicate on the "country" field.
func CountryEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCountry), v))
	})
}

// CountryNEQ applies the NEQ predicate on the "country" field.
func CountryNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCountry), v))
	})
}

// CountryIn applies the In predicate on the "country" field.
func CountryIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCountry), v...))
	})
}

// CountryNotIn applies the NotIn predicate on the "country" field.
func CountryNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCountry), v...))
	})
}

// CountryGT applies the GT predicate on the "country" field.
func CountryGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCountry), v))
	})
}

// CountryGTE applies the GTE predicate on the "country" field.
func CountryGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCountry), v))
	})
}

// CountryLT applies the LT predicate on the "country" field.
func CountryLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCountry), v))
	})
}

// CountryLTE applies the LTE predicate on the "country" field.
func CountryLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCountry), v))
	})
}

// CountryContains applies the Contains predicate on the "country" field.
func CountryContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCountry), v))
	})
}

// CountryHasPrefix applies the HasPrefix predicate on the "country" field.
func CountryHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCountry), v))
	})
}

// CountryHasSuffix applies the HasSuffix predicate on the "country" field.
func CountryHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCountry), v))
	})
}

// CountryIsNil applies the IsNil predicate on the "country" field.
func CountryIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCountry)))
	})
}

// CountryNotNil applies the NotNil predicate on the "country" field.
func CountryNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCountry)))
	})
}

// CountryEqualFold applies the EqualFold predicate on the "country" field.
func CountryEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCountry), v))
	})
}

// CountryContainsFold applies the ContainsFold predicate on the "country" field.
func CountryContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCountry), v))
	})
}

// SignatureEQ applies the EQ predicate on the "signature" field.
func SignatureEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSignature), v))
	})
}

// SignatureNEQ applies the NEQ predicate on the "signature" field.
func SignatureNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSignature), v))
	})
}

// SignatureIn applies the In predicate on the "signature" field.
func SignatureIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSignature), v...))
	})
}

// SignatureNotIn applies the NotIn predicate on the "signature" field.
func SignatureNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSignature), v...))
	})
}

// SignatureGT applies the GT predicate on the "signature" field.
func SignatureGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSignature), v))
	})
}

// SignatureGTE applies the GTE predicate on the "signature" field.
func SignatureGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSignature), v))
	})
}

// SignatureLT applies the LT predicate on the "signature" field.
func SignatureLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSignature), v))
	})
}

// SignatureLTE applies the LTE predicate on the "signature" field.
func SignatureLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSignature), v))
	})
}

// SignatureContains applies the Contains predicate on the "signature" field.
func SignatureContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSignature), v))
	})
}

// SignatureHasPrefix applies the HasPrefix predicate on the "signature" field.
func SignatureHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSignature), v))
	})
}

// SignatureHasSuffix applies the HasSuffix predicate on the "signature" field.
func SignatureHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSignature), v))
	})
}

// SignatureIsNil applies the IsNil predicate on the "signature" field.
func SignatureIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSignature)))
	})
}

// SignatureNotNil applies the NotNil predicate on the "signature" field.
func SignatureNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSignature)))
	})
}

// SignatureEqualFold applies the EqualFold predicate on the "signature" field.
func SignatureEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSignature), v))
	})
}

// SignatureContainsFold applies the ContainsFold predicate on the "signature" field.
func SignatureContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSignature), v))
	})
}

// RemarkEQ applies the EQ predicate on the "remark" field.
func RemarkEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemark), v))
	})
}

// RemarkNEQ applies the NEQ predicate on the "remark" field.
func RemarkNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRemark), v))
	})
}

// RemarkIn applies the In predicate on the "remark" field.
func RemarkIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRemark), v...))
	})
}

// RemarkNotIn applies the NotIn predicate on the "remark" field.
func RemarkNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRemark), v...))
	})
}

// RemarkGT applies the GT predicate on the "remark" field.
func RemarkGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRemark), v))
	})
}

// RemarkGTE applies the GTE predicate on the "remark" field.
func RemarkGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRemark), v))
	})
}

// RemarkLT applies the LT predicate on the "remark" field.
func RemarkLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRemark), v))
	})
}

// RemarkLTE applies the LTE predicate on the "remark" field.
func RemarkLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRemark), v))
	})
}

// RemarkContains applies the Contains predicate on the "remark" field.
func RemarkContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRemark), v))
	})
}

// RemarkHasPrefix applies the HasPrefix predicate on the "remark" field.
func RemarkHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRemark), v))
	})
}

// RemarkHasSuffix applies the HasSuffix predicate on the "remark" field.
func RemarkHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRemark), v))
	})
}

// RemarkIsNil applies the IsNil predicate on the "remark" field.
func RemarkIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRemark)))
	})
}

// RemarkNotNil applies the NotNil predicate on the "remark" field.
func RemarkNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRemark)))
	})
}

// RemarkEqualFold applies the EqualFold predicate on the "remark" field.
func RemarkEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRemark), v))
	})
}

// RemarkContainsFold applies the ContainsFold predicate on the "remark" field.
func RemarkContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRemark), v))
	})
}

// GroupidEQ applies the EQ predicate on the "groupid" field.
func GroupidEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGroupid), v))
	})
}

// GroupidNEQ applies the NEQ predicate on the "groupid" field.
func GroupidNEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGroupid), v))
	})
}

// GroupidIn applies the In predicate on the "groupid" field.
func GroupidIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGroupid), v...))
	})
}

// GroupidNotIn applies the NotIn predicate on the "groupid" field.
func GroupidNotIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGroupid), v...))
	})
}

// GroupidGT applies the GT predicate on the "groupid" field.
func GroupidGT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGroupid), v))
	})
}

// GroupidGTE applies the GTE predicate on the "groupid" field.
func GroupidGTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGroupid), v))
	})
}

// GroupidLT applies the LT predicate on the "groupid" field.
func GroupidLT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGroupid), v))
	})
}

// GroupidLTE applies the LTE predicate on the "groupid" field.
func GroupidLTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGroupid), v))
	})
}

// GroupidIsNil applies the IsNil predicate on the "groupid" field.
func GroupidIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGroupid)))
	})
}

// GroupidNotNil applies the NotNil predicate on the "groupid" field.
func GroupidNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGroupid)))
	})
}

// TagidListEQ applies the EQ predicate on the "tagidList" field.
func TagidListEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTagidList), v))
	})
}

// TagidListNEQ applies the NEQ predicate on the "tagidList" field.
func TagidListNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTagidList), v))
	})
}

// TagidListIn applies the In predicate on the "tagidList" field.
func TagidListIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTagidList), v...))
	})
}

// TagidListNotIn applies the NotIn predicate on the "tagidList" field.
func TagidListNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTagidList), v...))
	})
}

// TagidListGT applies the GT predicate on the "tagidList" field.
func TagidListGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTagidList), v))
	})
}

// TagidListGTE applies the GTE predicate on the "tagidList" field.
func TagidListGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTagidList), v))
	})
}

// TagidListLT applies the LT predicate on the "tagidList" field.
func TagidListLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTagidList), v))
	})
}

// TagidListLTE applies the LTE predicate on the "tagidList" field.
func TagidListLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTagidList), v))
	})
}

// TagidListContains applies the Contains predicate on the "tagidList" field.
func TagidListContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTagidList), v))
	})
}

// TagidListHasPrefix applies the HasPrefix predicate on the "tagidList" field.
func TagidListHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTagidList), v))
	})
}

// TagidListHasSuffix applies the HasSuffix predicate on the "tagidList" field.
func TagidListHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTagidList), v))
	})
}

// TagidListIsNil applies the IsNil predicate on the "tagidList" field.
func TagidListIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTagidList)))
	})
}

// TagidListNotNil applies the NotNil predicate on the "tagidList" field.
func TagidListNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTagidList)))
	})
}

// TagidListEqualFold applies the EqualFold predicate on the "tagidList" field.
func TagidListEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTagidList), v))
	})
}

// TagidListContainsFold applies the ContainsFold predicate on the "tagidList" field.
func TagidListContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTagidList), v))
	})
}

// SubscribeEQ applies the EQ predicate on the "subscribe" field.
func SubscribeEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSubscribe), v))
	})
}

// SubscribeNEQ applies the NEQ predicate on the "subscribe" field.
func SubscribeNEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSubscribe), v))
	})
}

// SubscribeIn applies the In predicate on the "subscribe" field.
func SubscribeIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSubscribe), v...))
	})
}

// SubscribeNotIn applies the NotIn predicate on the "subscribe" field.
func SubscribeNotIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSubscribe), v...))
	})
}

// SubscribeGT applies the GT predicate on the "subscribe" field.
func SubscribeGT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSubscribe), v))
	})
}

// SubscribeGTE applies the GTE predicate on the "subscribe" field.
func SubscribeGTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSubscribe), v))
	})
}

// SubscribeLT applies the LT predicate on the "subscribe" field.
func SubscribeLT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSubscribe), v))
	})
}

// SubscribeLTE applies the LTE predicate on the "subscribe" field.
func SubscribeLTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSubscribe), v))
	})
}

// SubscribeIsNil applies the IsNil predicate on the "subscribe" field.
func SubscribeIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSubscribe)))
	})
}

// SubscribeNotNil applies the NotNil predicate on the "subscribe" field.
func SubscribeNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSubscribe)))
	})
}

// SubscribeTimeEQ applies the EQ predicate on the "subscribeTime" field.
func SubscribeTimeEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSubscribeTime), v))
	})
}

// SubscribeTimeNEQ applies the NEQ predicate on the "subscribeTime" field.
func SubscribeTimeNEQ(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSubscribeTime), v))
	})
}

// SubscribeTimeIn applies the In predicate on the "subscribeTime" field.
func SubscribeTimeIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSubscribeTime), v...))
	})
}

// SubscribeTimeNotIn applies the NotIn predicate on the "subscribeTime" field.
func SubscribeTimeNotIn(vs ...int32) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSubscribeTime), v...))
	})
}

// SubscribeTimeGT applies the GT predicate on the "subscribeTime" field.
func SubscribeTimeGT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSubscribeTime), v))
	})
}

// SubscribeTimeGTE applies the GTE predicate on the "subscribeTime" field.
func SubscribeTimeGTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSubscribeTime), v))
	})
}

// SubscribeTimeLT applies the LT predicate on the "subscribeTime" field.
func SubscribeTimeLT(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSubscribeTime), v))
	})
}

// SubscribeTimeLTE applies the LTE predicate on the "subscribeTime" field.
func SubscribeTimeLTE(v int32) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSubscribeTime), v))
	})
}

// SubscribeTimeIsNil applies the IsNil predicate on the "subscribeTime" field.
func SubscribeTimeIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSubscribeTime)))
	})
}

// SubscribeTimeNotNil applies the NotNil predicate on the "subscribeTime" field.
func SubscribeTimeNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSubscribeTime)))
	})
}

// SessionKeyEQ applies the EQ predicate on the "sessionKey" field.
func SessionKeyEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSessionKey), v))
	})
}

// SessionKeyNEQ applies the NEQ predicate on the "sessionKey" field.
func SessionKeyNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSessionKey), v))
	})
}

// SessionKeyIn applies the In predicate on the "sessionKey" field.
func SessionKeyIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSessionKey), v...))
	})
}

// SessionKeyNotIn applies the NotIn predicate on the "sessionKey" field.
func SessionKeyNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSessionKey), v...))
	})
}

// SessionKeyGT applies the GT predicate on the "sessionKey" field.
func SessionKeyGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSessionKey), v))
	})
}

// SessionKeyGTE applies the GTE predicate on the "sessionKey" field.
func SessionKeyGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSessionKey), v))
	})
}

// SessionKeyLT applies the LT predicate on the "sessionKey" field.
func SessionKeyLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSessionKey), v))
	})
}

// SessionKeyLTE applies the LTE predicate on the "sessionKey" field.
func SessionKeyLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSessionKey), v))
	})
}

// SessionKeyContains applies the Contains predicate on the "sessionKey" field.
func SessionKeyContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSessionKey), v))
	})
}

// SessionKeyHasPrefix applies the HasPrefix predicate on the "sessionKey" field.
func SessionKeyHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSessionKey), v))
	})
}

// SessionKeyHasSuffix applies the HasSuffix predicate on the "sessionKey" field.
func SessionKeyHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSessionKey), v))
	})
}

// SessionKeyIsNil applies the IsNil predicate on the "sessionKey" field.
func SessionKeyIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSessionKey)))
	})
}

// SessionKeyNotNil applies the NotNil predicate on the "sessionKey" field.
func SessionKeyNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSessionKey)))
	})
}

// SessionKeyEqualFold applies the EqualFold predicate on the "sessionKey" field.
func SessionKeyEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSessionKey), v))
	})
}

// SessionKeyContainsFold applies the ContainsFold predicate on the "sessionKey" field.
func SessionKeyContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSessionKey), v))
	})
}

// UserTypeEQ applies the EQ predicate on the "userType" field.
func UserTypeEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserType), v))
	})
}

// UserTypeNEQ applies the NEQ predicate on the "userType" field.
func UserTypeNEQ(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserType), v))
	})
}

// UserTypeIn applies the In predicate on the "userType" field.
func UserTypeIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserType), v...))
	})
}

// UserTypeNotIn applies the NotIn predicate on the "userType" field.
func UserTypeNotIn(vs ...string) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserType), v...))
	})
}

// UserTypeGT applies the GT predicate on the "userType" field.
func UserTypeGT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserType), v))
	})
}

// UserTypeGTE applies the GTE predicate on the "userType" field.
func UserTypeGTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserType), v))
	})
}

// UserTypeLT applies the LT predicate on the "userType" field.
func UserTypeLT(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserType), v))
	})
}

// UserTypeLTE applies the LTE predicate on the "userType" field.
func UserTypeLTE(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserType), v))
	})
}

// UserTypeContains applies the Contains predicate on the "userType" field.
func UserTypeContains(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserType), v))
	})
}

// UserTypeHasPrefix applies the HasPrefix predicate on the "userType" field.
func UserTypeHasPrefix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserType), v))
	})
}

// UserTypeHasSuffix applies the HasSuffix predicate on the "userType" field.
func UserTypeHasSuffix(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserType), v))
	})
}

// UserTypeIsNil applies the IsNil predicate on the "userType" field.
func UserTypeIsNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUserType)))
	})
}

// UserTypeNotNil applies the NotNil predicate on the "userType" field.
func UserTypeNotNil() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUserType)))
	})
}

// UserTypeEqualFold applies the EqualFold predicate on the "userType" field.
func UserTypeEqualFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserType), v))
	})
}

// UserTypeContainsFold applies the ContainsFold predicate on the "userType" field.
func UserTypeContainsFold(v string) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserType), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "createdAt" field.
func CreatedAtEQ(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "createdAt" field.
func CreatedAtNEQ(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "createdAt" field.
func CreatedAtIn(vs ...time.Time) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "createdAt" field.
func CreatedAtNotIn(vs ...time.Time) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "createdAt" field.
func CreatedAtGT(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "createdAt" field.
func CreatedAtGTE(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "createdAt" field.
func CreatedAtLT(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "createdAt" field.
func CreatedAtLTE(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updatedAt" field.
func UpdatedAtEQ(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updatedAt" field.
func UpdatedAtNEQ(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updatedAt" field.
func UpdatedAtIn(vs ...time.Time) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updatedAt" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updatedAt" field.
func UpdatedAtGT(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updatedAt" field.
func UpdatedAtGTE(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updatedAt" field.
func UpdatedAtLT(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updatedAt" field.
func UpdatedAtLTE(v time.Time) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// CreateByEQ applies the EQ predicate on the "createBy" field.
func CreateByEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateBy), v))
	})
}

// CreateByNEQ applies the NEQ predicate on the "createBy" field.
func CreateByNEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateBy), v))
	})
}

// CreateByIn applies the In predicate on the "createBy" field.
func CreateByIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateBy), v...))
	})
}

// CreateByNotIn applies the NotIn predicate on the "createBy" field.
func CreateByNotIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateBy), v...))
	})
}

// CreateByGT applies the GT predicate on the "createBy" field.
func CreateByGT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateBy), v))
	})
}

// CreateByGTE applies the GTE predicate on the "createBy" field.
func CreateByGTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateBy), v))
	})
}

// CreateByLT applies the LT predicate on the "createBy" field.
func CreateByLT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateBy), v))
	})
}

// CreateByLTE applies the LTE predicate on the "createBy" field.
func CreateByLTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateBy), v))
	})
}

// UpdateByEQ applies the EQ predicate on the "updateBy" field.
func UpdateByEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateBy), v))
	})
}

// UpdateByNEQ applies the NEQ predicate on the "updateBy" field.
func UpdateByNEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateBy), v))
	})
}

// UpdateByIn applies the In predicate on the "updateBy" field.
func UpdateByIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateBy), v...))
	})
}

// UpdateByNotIn applies the NotIn predicate on the "updateBy" field.
func UpdateByNotIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateBy), v...))
	})
}

// UpdateByGT applies the GT predicate on the "updateBy" field.
func UpdateByGT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateBy), v))
	})
}

// UpdateByGTE applies the GTE predicate on the "updateBy" field.
func UpdateByGTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateBy), v))
	})
}

// UpdateByLT applies the LT predicate on the "updateBy" field.
func UpdateByLT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateBy), v))
	})
}

// UpdateByLTE applies the LTE predicate on the "updateBy" field.
func UpdateByLTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateBy), v))
	})
}

// TenantIdEQ applies the EQ predicate on the "tenantId" field.
func TenantIdEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantId), v))
	})
}

// TenantIdNEQ applies the NEQ predicate on the "tenantId" field.
func TenantIdNEQ(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTenantId), v))
	})
}

// TenantIdIn applies the In predicate on the "tenantId" field.
func TenantIdIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTenantId), v...))
	})
}

// TenantIdNotIn applies the NotIn predicate on the "tenantId" field.
func TenantIdNotIn(vs ...int64) predicate.SocialUser {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.SocialUser(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTenantId), v...))
	})
}

// TenantIdGT applies the GT predicate on the "tenantId" field.
func TenantIdGT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTenantId), v))
	})
}

// TenantIdGTE applies the GTE predicate on the "tenantId" field.
func TenantIdGTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTenantId), v))
	})
}

// TenantIdLT applies the LT predicate on the "tenantId" field.
func TenantIdLT(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTenantId), v))
	})
}

// TenantIdLTE applies the LTE predicate on the "tenantId" field.
func TenantIdLTE(v int64) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTenantId), v))
	})
}

// HasTasks applies the HasEdge predicate on the "tasks" edge.
func HasTasks() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TasksTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TasksTable, TasksColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTasksWith applies the HasEdge predicate on the "tasks" edge with a given conditions (other predicates).
func HasTasksWith(preds ...predicate.TaskLog) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TasksInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TasksTable, TasksColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasListenRecords applies the HasEdge predicate on the "listenRecords" edge.
func HasListenRecords() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ListenRecordsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ListenRecordsTable, ListenRecordsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasListenRecordsWith applies the HasEdge predicate on the "listenRecords" edge with a given conditions (other predicates).
func HasListenRecordsWith(preds ...predicate.ListenRecord) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ListenRecordsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ListenRecordsTable, ListenRecordsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAds applies the HasEdge predicate on the "ads" edge.
func HasAds() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AdsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AdsTable, AdsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAdsWith applies the HasEdge predicate on the "ads" edge with a given conditions (other predicates).
func HasAdsWith(preds ...predicate.AdChangeLog) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AdsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AdsTable, AdsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasBookshelves applies the HasEdge predicate on the "bookshelves" edge.
func HasBookshelves() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BookshelvesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BookshelvesTable, BookshelvesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasBookshelvesWith applies the HasEdge predicate on the "bookshelves" edge with a given conditions (other predicates).
func HasBookshelvesWith(preds ...predicate.NovelBookshelf) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BookshelvesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BookshelvesTable, BookshelvesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAutoBuyNovels applies the HasEdge predicate on the "autoBuyNovels" edge.
func HasAutoBuyNovels() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AutoBuyNovelsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AutoBuyNovelsTable, AutoBuyNovelsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAutoBuyNovelsWith applies the HasEdge predicate on the "autoBuyNovels" edge with a given conditions (other predicates).
func HasAutoBuyNovelsWith(preds ...predicate.NovelAutoBuy) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AutoBuyNovelsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AutoBuyNovelsTable, AutoBuyNovelsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasComments applies the HasEdge predicate on the "comments" edge.
func HasComments() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CommentsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CommentsTable, CommentsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCommentsWith applies the HasEdge predicate on the "comments" edge with a given conditions (other predicates).
func HasCommentsWith(preds ...predicate.NovelComment) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CommentsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CommentsTable, CommentsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasMsgs applies the HasEdge predicate on the "msgs" edge.
func HasMsgs() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(MsgsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, MsgsTable, MsgsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasMsgsWith applies the HasEdge predicate on the "msgs" edge with a given conditions (other predicates).
func HasMsgsWith(preds ...predicate.UserMsg) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(MsgsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, MsgsTable, MsgsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasOrders applies the HasEdge predicate on the "orders" edge.
func HasOrders() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(OrdersTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, OrdersTable, OrdersColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasOrdersWith applies the HasEdge predicate on the "orders" edge with a given conditions (other predicates).
func HasOrdersWith(preds ...predicate.PayOrder) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(OrdersInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, OrdersTable, OrdersColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasVips applies the HasEdge predicate on the "vips" edge.
func HasVips() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(VipsTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, VipsTable, VipsPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasVipsWith applies the HasEdge predicate on the "vips" edge with a given conditions (other predicates).
func HasVipsWith(preds ...predicate.VipUser) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(VipsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, VipsTable, VipsPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasBalances applies the HasEdge predicate on the "balances" edge.
func HasBalances() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BalancesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BalancesTable, BalancesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasBalancesWith applies the HasEdge predicate on the "balances" edge with a given conditions (other predicates).
func HasBalancesWith(preds ...predicate.AmBalance) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BalancesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BalancesTable, BalancesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAssetLogs applies the HasEdge predicate on the "assetLogs" edge.
func HasAssetLogs() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AssetLogsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AssetLogsTable, AssetLogsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAssetLogsWith applies the HasEdge predicate on the "assetLogs" edge with a given conditions (other predicates).
func HasAssetLogsWith(preds ...predicate.AssetChangeLog) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AssetLogsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AssetLogsTable, AssetLogsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasBuyChapterRecords applies the HasEdge predicate on the "buyChapterRecords" edge.
func HasBuyChapterRecords() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BuyChapterRecordsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BuyChapterRecordsTable, BuyChapterRecordsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasBuyChapterRecordsWith applies the HasEdge predicate on the "buyChapterRecords" edge with a given conditions (other predicates).
func HasBuyChapterRecordsWith(preds ...predicate.NovelBuyChapterRecord) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BuyChapterRecordsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BuyChapterRecordsTable, BuyChapterRecordsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasBuyNovelRecords applies the HasEdge predicate on the "buyNovelRecords" edge.
func HasBuyNovelRecords() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BuyNovelRecordsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BuyNovelRecordsTable, BuyNovelRecordsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasBuyNovelRecordsWith applies the HasEdge predicate on the "buyNovelRecords" edge with a given conditions (other predicates).
func HasBuyNovelRecordsWith(preds ...predicate.NovelBuyRecord) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(BuyNovelRecordsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BuyNovelRecordsTable, BuyNovelRecordsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasChannel applies the HasEdge predicate on the "channel" edge.
func HasChannel() predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChannelTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ChannelTable, ChannelColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasChannelWith applies the HasEdge predicate on the "channel" edge with a given conditions (other predicates).
func HasChannelWith(preds ...predicate.AdChannel) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChannelInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ChannelTable, ChannelColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.SocialUser) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.SocialUser) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.SocialUser) predicate.SocialUser {
	return predicate.SocialUser(func(s *sql.Selector) {
		p(s.Not())
	})
}
