// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"hope/apps/novel/internal/data/ent/activity"
	"hope/apps/novel/internal/data/ent/activitycomponent"
	"hope/apps/novel/internal/data/ent/adchangelog"
	"hope/apps/novel/internal/data/ent/adchannel"
	"hope/apps/novel/internal/data/ent/agreementlog"
	"hope/apps/novel/internal/data/ent/ambalance"
	"hope/apps/novel/internal/data/ent/appversion"
	"hope/apps/novel/internal/data/ent/assetchangelog"
	"hope/apps/novel/internal/data/ent/assetitem"
	"hope/apps/novel/internal/data/ent/bookpackage"
	"hope/apps/novel/internal/data/ent/clienterror"
	"hope/apps/novel/internal/data/ent/customernovelconfig"
	"hope/apps/novel/internal/data/ent/customernovels"
	"hope/apps/novel/internal/data/ent/datasource"
	"hope/apps/novel/internal/data/ent/listenrecord"
	"hope/apps/novel/internal/data/ent/novel"
	"hope/apps/novel/internal/data/ent/novelautobuy"
	"hope/apps/novel/internal/data/ent/novelbookshelf"
	"hope/apps/novel/internal/data/ent/novelbuychapterrecord"
	"hope/apps/novel/internal/data/ent/novelbuyrecord"
	"hope/apps/novel/internal/data/ent/novelchapter"
	"hope/apps/novel/internal/data/ent/novelclassify"
	"hope/apps/novel/internal/data/ent/novelcomment"
	"hope/apps/novel/internal/data/ent/novelconsume"
	"hope/apps/novel/internal/data/ent/novelmsg"
	"hope/apps/novel/internal/data/ent/payorder"
	"hope/apps/novel/internal/data/ent/predicate"
	"hope/apps/novel/internal/data/ent/schema"
	"hope/apps/novel/internal/data/ent/socialuser"
	"hope/apps/novel/internal/data/ent/tasklog"
	"hope/apps/novel/internal/data/ent/userevent"
	"hope/apps/novel/internal/data/ent/usermsg"
	"hope/apps/novel/internal/data/ent/vipuser"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity              = "Activity"
	TypeActivityComponent     = "ActivityComponent"
	TypeAdChangeLog           = "AdChangeLog"
	TypeAdChannel             = "AdChannel"
	TypeAgreementLog          = "AgreementLog"
	TypeAmBalance             = "AmBalance"
	TypeAppVersion            = "AppVersion"
	TypeAssetChangeLog        = "AssetChangeLog"
	TypeAssetItem             = "AssetItem"
	TypeBookPackage           = "BookPackage"
	TypeClientError           = "ClientError"
	TypeCustomerNovelConfig   = "CustomerNovelConfig"
	TypeCustomerNovels        = "CustomerNovels"
	TypeDataSource            = "DataSource"
	TypeListenRecord          = "ListenRecord"
	TypeNovel                 = "Novel"
	TypeNovelAutoBuy          = "NovelAutoBuy"
	TypeNovelBookshelf        = "NovelBookshelf"
	TypeNovelBuyChapterRecord = "NovelBuyChapterRecord"
	TypeNovelBuyRecord        = "NovelBuyRecord"
	TypeNovelChapter          = "NovelChapter"
	TypeNovelClassify         = "NovelClassify"
	TypeNovelComment          = "NovelComment"
	TypeNovelConsume          = "NovelConsume"
	TypeNovelMsg              = "NovelMsg"
	TypePayOrder              = "PayOrder"
	TypeSocialUser            = "SocialUser"
	TypeTaskLog               = "TaskLog"
	TypeUserEvent             = "UserEvent"
	TypeUserMsg               = "UserMsg"
	TypeVipUser               = "VipUser"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	activityCode  *string
	activityName  *string
	summary       *string
	ruleImgSc     *string
	ruleImgTc     *string
	popupImg      *string
	regDays       *int32
	addregDays    *int32
	cycleType     *string
	effectTime    *time.Time
	expiredTime   *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Activity, error)
	predicates    []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id int64) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Activity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityCode sets the "activityCode" field.
func (m *ActivityMutation) SetActivityCode(s string) {
	m.activityCode = &s
}

// ActivityCode returns the value of the "activityCode" field in the mutation.
func (m *ActivityMutation) ActivityCode() (r string, exists bool) {
	v := m.activityCode
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityCode returns the old "activityCode" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldActivityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityCode: %w", err)
	}
	return oldValue.ActivityCode, nil
}

// ClearActivityCode clears the value of the "activityCode" field.
func (m *ActivityMutation) ClearActivityCode() {
	m.activityCode = nil
	m.clearedFields[activity.FieldActivityCode] = struct{}{}
}

// ActivityCodeCleared returns if the "activityCode" field was cleared in this mutation.
func (m *ActivityMutation) ActivityCodeCleared() bool {
	_, ok := m.clearedFields[activity.FieldActivityCode]
	return ok
}

// ResetActivityCode resets all changes to the "activityCode" field.
func (m *ActivityMutation) ResetActivityCode() {
	m.activityCode = nil
	delete(m.clearedFields, activity.FieldActivityCode)
}

// SetActivityName sets the "activityName" field.
func (m *ActivityMutation) SetActivityName(s string) {
	m.activityName = &s
}

// ActivityName returns the value of the "activityName" field in the mutation.
func (m *ActivityMutation) ActivityName() (r string, exists bool) {
	v := m.activityName
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityName returns the old "activityName" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldActivityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityName: %w", err)
	}
	return oldValue.ActivityName, nil
}

// ClearActivityName clears the value of the "activityName" field.
func (m *ActivityMutation) ClearActivityName() {
	m.activityName = nil
	m.clearedFields[activity.FieldActivityName] = struct{}{}
}

// ActivityNameCleared returns if the "activityName" field was cleared in this mutation.
func (m *ActivityMutation) ActivityNameCleared() bool {
	_, ok := m.clearedFields[activity.FieldActivityName]
	return ok
}

// ResetActivityName resets all changes to the "activityName" field.
func (m *ActivityMutation) ResetActivityName() {
	m.activityName = nil
	delete(m.clearedFields, activity.FieldActivityName)
}

// SetSummary sets the "summary" field.
func (m *ActivityMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ActivityMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ActivityMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[activity.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ActivityMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[activity.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ActivityMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, activity.FieldSummary)
}

// SetRuleImgSc sets the "ruleImgSc" field.
func (m *ActivityMutation) SetRuleImgSc(s string) {
	m.ruleImgSc = &s
}

// RuleImgSc returns the value of the "ruleImgSc" field in the mutation.
func (m *ActivityMutation) RuleImgSc() (r string, exists bool) {
	v := m.ruleImgSc
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleImgSc returns the old "ruleImgSc" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRuleImgSc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleImgSc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleImgSc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleImgSc: %w", err)
	}
	return oldValue.RuleImgSc, nil
}

// ClearRuleImgSc clears the value of the "ruleImgSc" field.
func (m *ActivityMutation) ClearRuleImgSc() {
	m.ruleImgSc = nil
	m.clearedFields[activity.FieldRuleImgSc] = struct{}{}
}

// RuleImgScCleared returns if the "ruleImgSc" field was cleared in this mutation.
func (m *ActivityMutation) RuleImgScCleared() bool {
	_, ok := m.clearedFields[activity.FieldRuleImgSc]
	return ok
}

// ResetRuleImgSc resets all changes to the "ruleImgSc" field.
func (m *ActivityMutation) ResetRuleImgSc() {
	m.ruleImgSc = nil
	delete(m.clearedFields, activity.FieldRuleImgSc)
}

// SetRuleImgTc sets the "ruleImgTc" field.
func (m *ActivityMutation) SetRuleImgTc(s string) {
	m.ruleImgTc = &s
}

// RuleImgTc returns the value of the "ruleImgTc" field in the mutation.
func (m *ActivityMutation) RuleImgTc() (r string, exists bool) {
	v := m.ruleImgTc
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleImgTc returns the old "ruleImgTc" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRuleImgTc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleImgTc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleImgTc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleImgTc: %w", err)
	}
	return oldValue.RuleImgTc, nil
}

// ClearRuleImgTc clears the value of the "ruleImgTc" field.
func (m *ActivityMutation) ClearRuleImgTc() {
	m.ruleImgTc = nil
	m.clearedFields[activity.FieldRuleImgTc] = struct{}{}
}

// RuleImgTcCleared returns if the "ruleImgTc" field was cleared in this mutation.
func (m *ActivityMutation) RuleImgTcCleared() bool {
	_, ok := m.clearedFields[activity.FieldRuleImgTc]
	return ok
}

// ResetRuleImgTc resets all changes to the "ruleImgTc" field.
func (m *ActivityMutation) ResetRuleImgTc() {
	m.ruleImgTc = nil
	delete(m.clearedFields, activity.FieldRuleImgTc)
}

// SetPopupImg sets the "popupImg" field.
func (m *ActivityMutation) SetPopupImg(s string) {
	m.popupImg = &s
}

// PopupImg returns the value of the "popupImg" field in the mutation.
func (m *ActivityMutation) PopupImg() (r string, exists bool) {
	v := m.popupImg
	if v == nil {
		return
	}
	return *v, true
}

// OldPopupImg returns the old "popupImg" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldPopupImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopupImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopupImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopupImg: %w", err)
	}
	return oldValue.PopupImg, nil
}

// ClearPopupImg clears the value of the "popupImg" field.
func (m *ActivityMutation) ClearPopupImg() {
	m.popupImg = nil
	m.clearedFields[activity.FieldPopupImg] = struct{}{}
}

// PopupImgCleared returns if the "popupImg" field was cleared in this mutation.
func (m *ActivityMutation) PopupImgCleared() bool {
	_, ok := m.clearedFields[activity.FieldPopupImg]
	return ok
}

// ResetPopupImg resets all changes to the "popupImg" field.
func (m *ActivityMutation) ResetPopupImg() {
	m.popupImg = nil
	delete(m.clearedFields, activity.FieldPopupImg)
}

// SetRegDays sets the "regDays" field.
func (m *ActivityMutation) SetRegDays(i int32) {
	m.regDays = &i
	m.addregDays = nil
}

// RegDays returns the value of the "regDays" field in the mutation.
func (m *ActivityMutation) RegDays() (r int32, exists bool) {
	v := m.regDays
	if v == nil {
		return
	}
	return *v, true
}

// OldRegDays returns the old "regDays" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRegDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegDays: %w", err)
	}
	return oldValue.RegDays, nil
}

// AddRegDays adds i to the "regDays" field.
func (m *ActivityMutation) AddRegDays(i int32) {
	if m.addregDays != nil {
		*m.addregDays += i
	} else {
		m.addregDays = &i
	}
}

// AddedRegDays returns the value that was added to the "regDays" field in this mutation.
func (m *ActivityMutation) AddedRegDays() (r int32, exists bool) {
	v := m.addregDays
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegDays clears the value of the "regDays" field.
func (m *ActivityMutation) ClearRegDays() {
	m.regDays = nil
	m.addregDays = nil
	m.clearedFields[activity.FieldRegDays] = struct{}{}
}

// RegDaysCleared returns if the "regDays" field was cleared in this mutation.
func (m *ActivityMutation) RegDaysCleared() bool {
	_, ok := m.clearedFields[activity.FieldRegDays]
	return ok
}

// ResetRegDays resets all changes to the "regDays" field.
func (m *ActivityMutation) ResetRegDays() {
	m.regDays = nil
	m.addregDays = nil
	delete(m.clearedFields, activity.FieldRegDays)
}

// SetCycleType sets the "cycleType" field.
func (m *ActivityMutation) SetCycleType(s string) {
	m.cycleType = &s
}

// CycleType returns the value of the "cycleType" field in the mutation.
func (m *ActivityMutation) CycleType() (r string, exists bool) {
	v := m.cycleType
	if v == nil {
		return
	}
	return *v, true
}

// OldCycleType returns the old "cycleType" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCycleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycleType: %w", err)
	}
	return oldValue.CycleType, nil
}

// ClearCycleType clears the value of the "cycleType" field.
func (m *ActivityMutation) ClearCycleType() {
	m.cycleType = nil
	m.clearedFields[activity.FieldCycleType] = struct{}{}
}

// CycleTypeCleared returns if the "cycleType" field was cleared in this mutation.
func (m *ActivityMutation) CycleTypeCleared() bool {
	_, ok := m.clearedFields[activity.FieldCycleType]
	return ok
}

// ResetCycleType resets all changes to the "cycleType" field.
func (m *ActivityMutation) ResetCycleType() {
	m.cycleType = nil
	delete(m.clearedFields, activity.FieldCycleType)
}

// SetEffectTime sets the "effectTime" field.
func (m *ActivityMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *ActivityMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ClearEffectTime clears the value of the "effectTime" field.
func (m *ActivityMutation) ClearEffectTime() {
	m.effectTime = nil
	m.clearedFields[activity.FieldEffectTime] = struct{}{}
}

// EffectTimeCleared returns if the "effectTime" field was cleared in this mutation.
func (m *ActivityMutation) EffectTimeCleared() bool {
	_, ok := m.clearedFields[activity.FieldEffectTime]
	return ok
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *ActivityMutation) ResetEffectTime() {
	m.effectTime = nil
	delete(m.clearedFields, activity.FieldEffectTime)
}

// SetExpiredTime sets the "expiredTime" field.
func (m *ActivityMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *ActivityMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ClearExpiredTime clears the value of the "expiredTime" field.
func (m *ActivityMutation) ClearExpiredTime() {
	m.expiredTime = nil
	m.clearedFields[activity.FieldExpiredTime] = struct{}{}
}

// ExpiredTimeCleared returns if the "expiredTime" field was cleared in this mutation.
func (m *ActivityMutation) ExpiredTimeCleared() bool {
	_, ok := m.clearedFields[activity.FieldExpiredTime]
	return ok
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *ActivityMutation) ResetExpiredTime() {
	m.expiredTime = nil
	delete(m.clearedFields, activity.FieldExpiredTime)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ActivityMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ActivityMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ActivityMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ActivityMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ActivityMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ActivityMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ActivityMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ActivityMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ActivityMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ActivityMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ActivityMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ActivityMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ActivityMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ActivityMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ActivityMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ActivityMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ActivityMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ActivityMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ActivityMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.activityCode != nil {
		fields = append(fields, activity.FieldActivityCode)
	}
	if m.activityName != nil {
		fields = append(fields, activity.FieldActivityName)
	}
	if m.summary != nil {
		fields = append(fields, activity.FieldSummary)
	}
	if m.ruleImgSc != nil {
		fields = append(fields, activity.FieldRuleImgSc)
	}
	if m.ruleImgTc != nil {
		fields = append(fields, activity.FieldRuleImgTc)
	}
	if m.popupImg != nil {
		fields = append(fields, activity.FieldPopupImg)
	}
	if m.regDays != nil {
		fields = append(fields, activity.FieldRegDays)
	}
	if m.cycleType != nil {
		fields = append(fields, activity.FieldCycleType)
	}
	if m.effectTime != nil {
		fields = append(fields, activity.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, activity.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, activity.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, activity.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, activity.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, activity.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, activity.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldActivityCode:
		return m.ActivityCode()
	case activity.FieldActivityName:
		return m.ActivityName()
	case activity.FieldSummary:
		return m.Summary()
	case activity.FieldRuleImgSc:
		return m.RuleImgSc()
	case activity.FieldRuleImgTc:
		return m.RuleImgTc()
	case activity.FieldPopupImg:
		return m.PopupImg()
	case activity.FieldRegDays:
		return m.RegDays()
	case activity.FieldCycleType:
		return m.CycleType()
	case activity.FieldEffectTime:
		return m.EffectTime()
	case activity.FieldExpiredTime:
		return m.ExpiredTime()
	case activity.FieldCreatedAt:
		return m.CreatedAt()
	case activity.FieldUpdatedAt:
		return m.UpdatedAt()
	case activity.FieldCreateBy:
		return m.CreateBy()
	case activity.FieldUpdateBy:
		return m.UpdateBy()
	case activity.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldActivityCode:
		return m.OldActivityCode(ctx)
	case activity.FieldActivityName:
		return m.OldActivityName(ctx)
	case activity.FieldSummary:
		return m.OldSummary(ctx)
	case activity.FieldRuleImgSc:
		return m.OldRuleImgSc(ctx)
	case activity.FieldRuleImgTc:
		return m.OldRuleImgTc(ctx)
	case activity.FieldPopupImg:
		return m.OldPopupImg(ctx)
	case activity.FieldRegDays:
		return m.OldRegDays(ctx)
	case activity.FieldCycleType:
		return m.OldCycleType(ctx)
	case activity.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case activity.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case activity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activity.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case activity.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case activity.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldActivityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityCode(v)
		return nil
	case activity.FieldActivityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityName(v)
		return nil
	case activity.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case activity.FieldRuleImgSc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleImgSc(v)
		return nil
	case activity.FieldRuleImgTc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleImgTc(v)
		return nil
	case activity.FieldPopupImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopupImg(v)
		return nil
	case activity.FieldRegDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegDays(v)
		return nil
	case activity.FieldCycleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycleType(v)
		return nil
	case activity.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case activity.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case activity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activity.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case activity.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case activity.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.addregDays != nil {
		fields = append(fields, activity.FieldRegDays)
	}
	if m.addcreateBy != nil {
		fields = append(fields, activity.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, activity.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, activity.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldRegDays:
		return m.AddedRegDays()
	case activity.FieldCreateBy:
		return m.AddedCreateBy()
	case activity.FieldUpdateBy:
		return m.AddedUpdateBy()
	case activity.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldRegDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegDays(v)
		return nil
	case activity.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case activity.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case activity.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldActivityCode) {
		fields = append(fields, activity.FieldActivityCode)
	}
	if m.FieldCleared(activity.FieldActivityName) {
		fields = append(fields, activity.FieldActivityName)
	}
	if m.FieldCleared(activity.FieldSummary) {
		fields = append(fields, activity.FieldSummary)
	}
	if m.FieldCleared(activity.FieldRuleImgSc) {
		fields = append(fields, activity.FieldRuleImgSc)
	}
	if m.FieldCleared(activity.FieldRuleImgTc) {
		fields = append(fields, activity.FieldRuleImgTc)
	}
	if m.FieldCleared(activity.FieldPopupImg) {
		fields = append(fields, activity.FieldPopupImg)
	}
	if m.FieldCleared(activity.FieldRegDays) {
		fields = append(fields, activity.FieldRegDays)
	}
	if m.FieldCleared(activity.FieldCycleType) {
		fields = append(fields, activity.FieldCycleType)
	}
	if m.FieldCleared(activity.FieldEffectTime) {
		fields = append(fields, activity.FieldEffectTime)
	}
	if m.FieldCleared(activity.FieldExpiredTime) {
		fields = append(fields, activity.FieldExpiredTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldActivityCode:
		m.ClearActivityCode()
		return nil
	case activity.FieldActivityName:
		m.ClearActivityName()
		return nil
	case activity.FieldSummary:
		m.ClearSummary()
		return nil
	case activity.FieldRuleImgSc:
		m.ClearRuleImgSc()
		return nil
	case activity.FieldRuleImgTc:
		m.ClearRuleImgTc()
		return nil
	case activity.FieldPopupImg:
		m.ClearPopupImg()
		return nil
	case activity.FieldRegDays:
		m.ClearRegDays()
		return nil
	case activity.FieldCycleType:
		m.ClearCycleType()
		return nil
	case activity.FieldEffectTime:
		m.ClearEffectTime()
		return nil
	case activity.FieldExpiredTime:
		m.ClearExpiredTime()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldActivityCode:
		m.ResetActivityCode()
		return nil
	case activity.FieldActivityName:
		m.ResetActivityName()
		return nil
	case activity.FieldSummary:
		m.ResetSummary()
		return nil
	case activity.FieldRuleImgSc:
		m.ResetRuleImgSc()
		return nil
	case activity.FieldRuleImgTc:
		m.ResetRuleImgTc()
		return nil
	case activity.FieldPopupImg:
		m.ResetPopupImg()
		return nil
	case activity.FieldRegDays:
		m.ResetRegDays()
		return nil
	case activity.FieldCycleType:
		m.ResetCycleType()
		return nil
	case activity.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case activity.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case activity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activity.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case activity.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case activity.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Activity edge %s", name)
}

// ActivityComponentMutation represents an operation that mutates the ActivityComponent nodes in the graph.
type ActivityComponentMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	activityCode   *string
	componentType  *string
	policy         *string
	vipDays        *bool
	minConsume     *int64
	addminConsume  *int64
	maxConsume     *int64
	addmaxConsume  *int64
	minPayNum      *int64
	addminPayNum   *int64
	payTimes       *int64
	addpayTimes    *int64
	payAmount      *int64
	addpayAmount   *int64
	regDays        *int64
	addregDays     *int64
	summary        *string
	assetItemId    *int32
	addassetItemId *int32
	amount         *int64
	addamount      *int64
	resId          *int64
	addresId       *int64
	resDays        *int32
	addresDays     *int32
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ActivityComponent, error)
	predicates     []predicate.ActivityComponent
}

var _ ent.Mutation = (*ActivityComponentMutation)(nil)

// activitycomponentOption allows management of the mutation configuration using functional options.
type activitycomponentOption func(*ActivityComponentMutation)

// newActivityComponentMutation creates new mutation for the ActivityComponent entity.
func newActivityComponentMutation(c config, op Op, opts ...activitycomponentOption) *ActivityComponentMutation {
	m := &ActivityComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityComponentID sets the ID field of the mutation.
func withActivityComponentID(id int64) activitycomponentOption {
	return func(m *ActivityComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityComponent
		)
		m.oldValue = func(ctx context.Context) (*ActivityComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityComponent sets the old ActivityComponent of the mutation.
func withActivityComponent(node *ActivityComponent) activitycomponentOption {
	return func(m *ActivityComponentMutation) {
		m.oldValue = func(context.Context) (*ActivityComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityComponentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityComponentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityCode sets the "activityCode" field.
func (m *ActivityComponentMutation) SetActivityCode(s string) {
	m.activityCode = &s
}

// ActivityCode returns the value of the "activityCode" field in the mutation.
func (m *ActivityComponentMutation) ActivityCode() (r string, exists bool) {
	v := m.activityCode
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityCode returns the old "activityCode" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldActivityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityCode: %w", err)
	}
	return oldValue.ActivityCode, nil
}

// ClearActivityCode clears the value of the "activityCode" field.
func (m *ActivityComponentMutation) ClearActivityCode() {
	m.activityCode = nil
	m.clearedFields[activitycomponent.FieldActivityCode] = struct{}{}
}

// ActivityCodeCleared returns if the "activityCode" field was cleared in this mutation.
func (m *ActivityComponentMutation) ActivityCodeCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldActivityCode]
	return ok
}

// ResetActivityCode resets all changes to the "activityCode" field.
func (m *ActivityComponentMutation) ResetActivityCode() {
	m.activityCode = nil
	delete(m.clearedFields, activitycomponent.FieldActivityCode)
}

// SetComponentType sets the "componentType" field.
func (m *ActivityComponentMutation) SetComponentType(s string) {
	m.componentType = &s
}

// ComponentType returns the value of the "componentType" field in the mutation.
func (m *ActivityComponentMutation) ComponentType() (r string, exists bool) {
	v := m.componentType
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentType returns the old "componentType" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldComponentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentType: %w", err)
	}
	return oldValue.ComponentType, nil
}

// ClearComponentType clears the value of the "componentType" field.
func (m *ActivityComponentMutation) ClearComponentType() {
	m.componentType = nil
	m.clearedFields[activitycomponent.FieldComponentType] = struct{}{}
}

// ComponentTypeCleared returns if the "componentType" field was cleared in this mutation.
func (m *ActivityComponentMutation) ComponentTypeCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldComponentType]
	return ok
}

// ResetComponentType resets all changes to the "componentType" field.
func (m *ActivityComponentMutation) ResetComponentType() {
	m.componentType = nil
	delete(m.clearedFields, activitycomponent.FieldComponentType)
}

// SetPolicy sets the "policy" field.
func (m *ActivityComponentMutation) SetPolicy(s string) {
	m.policy = &s
}

// Policy returns the value of the "policy" field in the mutation.
func (m *ActivityComponentMutation) Policy() (r string, exists bool) {
	v := m.policy
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicy returns the old "policy" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldPolicy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicy: %w", err)
	}
	return oldValue.Policy, nil
}

// ClearPolicy clears the value of the "policy" field.
func (m *ActivityComponentMutation) ClearPolicy() {
	m.policy = nil
	m.clearedFields[activitycomponent.FieldPolicy] = struct{}{}
}

// PolicyCleared returns if the "policy" field was cleared in this mutation.
func (m *ActivityComponentMutation) PolicyCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldPolicy]
	return ok
}

// ResetPolicy resets all changes to the "policy" field.
func (m *ActivityComponentMutation) ResetPolicy() {
	m.policy = nil
	delete(m.clearedFields, activitycomponent.FieldPolicy)
}

// SetVipDays sets the "vipDays" field.
func (m *ActivityComponentMutation) SetVipDays(b bool) {
	m.vipDays = &b
}

// VipDays returns the value of the "vipDays" field in the mutation.
func (m *ActivityComponentMutation) VipDays() (r bool, exists bool) {
	v := m.vipDays
	if v == nil {
		return
	}
	return *v, true
}

// OldVipDays returns the old "vipDays" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldVipDays(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipDays: %w", err)
	}
	return oldValue.VipDays, nil
}

// ClearVipDays clears the value of the "vipDays" field.
func (m *ActivityComponentMutation) ClearVipDays() {
	m.vipDays = nil
	m.clearedFields[activitycomponent.FieldVipDays] = struct{}{}
}

// VipDaysCleared returns if the "vipDays" field was cleared in this mutation.
func (m *ActivityComponentMutation) VipDaysCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldVipDays]
	return ok
}

// ResetVipDays resets all changes to the "vipDays" field.
func (m *ActivityComponentMutation) ResetVipDays() {
	m.vipDays = nil
	delete(m.clearedFields, activitycomponent.FieldVipDays)
}

// SetMinConsume sets the "minConsume" field.
func (m *ActivityComponentMutation) SetMinConsume(i int64) {
	m.minConsume = &i
	m.addminConsume = nil
}

// MinConsume returns the value of the "minConsume" field in the mutation.
func (m *ActivityComponentMutation) MinConsume() (r int64, exists bool) {
	v := m.minConsume
	if v == nil {
		return
	}
	return *v, true
}

// OldMinConsume returns the old "minConsume" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldMinConsume(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinConsume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinConsume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinConsume: %w", err)
	}
	return oldValue.MinConsume, nil
}

// AddMinConsume adds i to the "minConsume" field.
func (m *ActivityComponentMutation) AddMinConsume(i int64) {
	if m.addminConsume != nil {
		*m.addminConsume += i
	} else {
		m.addminConsume = &i
	}
}

// AddedMinConsume returns the value that was added to the "minConsume" field in this mutation.
func (m *ActivityComponentMutation) AddedMinConsume() (r int64, exists bool) {
	v := m.addminConsume
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinConsume clears the value of the "minConsume" field.
func (m *ActivityComponentMutation) ClearMinConsume() {
	m.minConsume = nil
	m.addminConsume = nil
	m.clearedFields[activitycomponent.FieldMinConsume] = struct{}{}
}

// MinConsumeCleared returns if the "minConsume" field was cleared in this mutation.
func (m *ActivityComponentMutation) MinConsumeCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldMinConsume]
	return ok
}

// ResetMinConsume resets all changes to the "minConsume" field.
func (m *ActivityComponentMutation) ResetMinConsume() {
	m.minConsume = nil
	m.addminConsume = nil
	delete(m.clearedFields, activitycomponent.FieldMinConsume)
}

// SetMaxConsume sets the "maxConsume" field.
func (m *ActivityComponentMutation) SetMaxConsume(i int64) {
	m.maxConsume = &i
	m.addmaxConsume = nil
}

// MaxConsume returns the value of the "maxConsume" field in the mutation.
func (m *ActivityComponentMutation) MaxConsume() (r int64, exists bool) {
	v := m.maxConsume
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxConsume returns the old "maxConsume" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldMaxConsume(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxConsume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxConsume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxConsume: %w", err)
	}
	return oldValue.MaxConsume, nil
}

// AddMaxConsume adds i to the "maxConsume" field.
func (m *ActivityComponentMutation) AddMaxConsume(i int64) {
	if m.addmaxConsume != nil {
		*m.addmaxConsume += i
	} else {
		m.addmaxConsume = &i
	}
}

// AddedMaxConsume returns the value that was added to the "maxConsume" field in this mutation.
func (m *ActivityComponentMutation) AddedMaxConsume() (r int64, exists bool) {
	v := m.addmaxConsume
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxConsume clears the value of the "maxConsume" field.
func (m *ActivityComponentMutation) ClearMaxConsume() {
	m.maxConsume = nil
	m.addmaxConsume = nil
	m.clearedFields[activitycomponent.FieldMaxConsume] = struct{}{}
}

// MaxConsumeCleared returns if the "maxConsume" field was cleared in this mutation.
func (m *ActivityComponentMutation) MaxConsumeCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldMaxConsume]
	return ok
}

// ResetMaxConsume resets all changes to the "maxConsume" field.
func (m *ActivityComponentMutation) ResetMaxConsume() {
	m.maxConsume = nil
	m.addmaxConsume = nil
	delete(m.clearedFields, activitycomponent.FieldMaxConsume)
}

// SetMinPayNum sets the "minPayNum" field.
func (m *ActivityComponentMutation) SetMinPayNum(i int64) {
	m.minPayNum = &i
	m.addminPayNum = nil
}

// MinPayNum returns the value of the "minPayNum" field in the mutation.
func (m *ActivityComponentMutation) MinPayNum() (r int64, exists bool) {
	v := m.minPayNum
	if v == nil {
		return
	}
	return *v, true
}

// OldMinPayNum returns the old "minPayNum" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldMinPayNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinPayNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinPayNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinPayNum: %w", err)
	}
	return oldValue.MinPayNum, nil
}

// AddMinPayNum adds i to the "minPayNum" field.
func (m *ActivityComponentMutation) AddMinPayNum(i int64) {
	if m.addminPayNum != nil {
		*m.addminPayNum += i
	} else {
		m.addminPayNum = &i
	}
}

// AddedMinPayNum returns the value that was added to the "minPayNum" field in this mutation.
func (m *ActivityComponentMutation) AddedMinPayNum() (r int64, exists bool) {
	v := m.addminPayNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinPayNum clears the value of the "minPayNum" field.
func (m *ActivityComponentMutation) ClearMinPayNum() {
	m.minPayNum = nil
	m.addminPayNum = nil
	m.clearedFields[activitycomponent.FieldMinPayNum] = struct{}{}
}

// MinPayNumCleared returns if the "minPayNum" field was cleared in this mutation.
func (m *ActivityComponentMutation) MinPayNumCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldMinPayNum]
	return ok
}

// ResetMinPayNum resets all changes to the "minPayNum" field.
func (m *ActivityComponentMutation) ResetMinPayNum() {
	m.minPayNum = nil
	m.addminPayNum = nil
	delete(m.clearedFields, activitycomponent.FieldMinPayNum)
}

// SetPayTimes sets the "payTimes" field.
func (m *ActivityComponentMutation) SetPayTimes(i int64) {
	m.payTimes = &i
	m.addpayTimes = nil
}

// PayTimes returns the value of the "payTimes" field in the mutation.
func (m *ActivityComponentMutation) PayTimes() (r int64, exists bool) {
	v := m.payTimes
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTimes returns the old "payTimes" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldPayTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTimes: %w", err)
	}
	return oldValue.PayTimes, nil
}

// AddPayTimes adds i to the "payTimes" field.
func (m *ActivityComponentMutation) AddPayTimes(i int64) {
	if m.addpayTimes != nil {
		*m.addpayTimes += i
	} else {
		m.addpayTimes = &i
	}
}

// AddedPayTimes returns the value that was added to the "payTimes" field in this mutation.
func (m *ActivityComponentMutation) AddedPayTimes() (r int64, exists bool) {
	v := m.addpayTimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayTimes clears the value of the "payTimes" field.
func (m *ActivityComponentMutation) ClearPayTimes() {
	m.payTimes = nil
	m.addpayTimes = nil
	m.clearedFields[activitycomponent.FieldPayTimes] = struct{}{}
}

// PayTimesCleared returns if the "payTimes" field was cleared in this mutation.
func (m *ActivityComponentMutation) PayTimesCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldPayTimes]
	return ok
}

// ResetPayTimes resets all changes to the "payTimes" field.
func (m *ActivityComponentMutation) ResetPayTimes() {
	m.payTimes = nil
	m.addpayTimes = nil
	delete(m.clearedFields, activitycomponent.FieldPayTimes)
}

// SetPayAmount sets the "payAmount" field.
func (m *ActivityComponentMutation) SetPayAmount(i int64) {
	m.payAmount = &i
	m.addpayAmount = nil
}

// PayAmount returns the value of the "payAmount" field in the mutation.
func (m *ActivityComponentMutation) PayAmount() (r int64, exists bool) {
	v := m.payAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldPayAmount returns the old "payAmount" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldPayAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayAmount: %w", err)
	}
	return oldValue.PayAmount, nil
}

// AddPayAmount adds i to the "payAmount" field.
func (m *ActivityComponentMutation) AddPayAmount(i int64) {
	if m.addpayAmount != nil {
		*m.addpayAmount += i
	} else {
		m.addpayAmount = &i
	}
}

// AddedPayAmount returns the value that was added to the "payAmount" field in this mutation.
func (m *ActivityComponentMutation) AddedPayAmount() (r int64, exists bool) {
	v := m.addpayAmount
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayAmount clears the value of the "payAmount" field.
func (m *ActivityComponentMutation) ClearPayAmount() {
	m.payAmount = nil
	m.addpayAmount = nil
	m.clearedFields[activitycomponent.FieldPayAmount] = struct{}{}
}

// PayAmountCleared returns if the "payAmount" field was cleared in this mutation.
func (m *ActivityComponentMutation) PayAmountCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldPayAmount]
	return ok
}

// ResetPayAmount resets all changes to the "payAmount" field.
func (m *ActivityComponentMutation) ResetPayAmount() {
	m.payAmount = nil
	m.addpayAmount = nil
	delete(m.clearedFields, activitycomponent.FieldPayAmount)
}

// SetRegDays sets the "regDays" field.
func (m *ActivityComponentMutation) SetRegDays(i int64) {
	m.regDays = &i
	m.addregDays = nil
}

// RegDays returns the value of the "regDays" field in the mutation.
func (m *ActivityComponentMutation) RegDays() (r int64, exists bool) {
	v := m.regDays
	if v == nil {
		return
	}
	return *v, true
}

// OldRegDays returns the old "regDays" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldRegDays(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegDays: %w", err)
	}
	return oldValue.RegDays, nil
}

// AddRegDays adds i to the "regDays" field.
func (m *ActivityComponentMutation) AddRegDays(i int64) {
	if m.addregDays != nil {
		*m.addregDays += i
	} else {
		m.addregDays = &i
	}
}

// AddedRegDays returns the value that was added to the "regDays" field in this mutation.
func (m *ActivityComponentMutation) AddedRegDays() (r int64, exists bool) {
	v := m.addregDays
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegDays clears the value of the "regDays" field.
func (m *ActivityComponentMutation) ClearRegDays() {
	m.regDays = nil
	m.addregDays = nil
	m.clearedFields[activitycomponent.FieldRegDays] = struct{}{}
}

// RegDaysCleared returns if the "regDays" field was cleared in this mutation.
func (m *ActivityComponentMutation) RegDaysCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldRegDays]
	return ok
}

// ResetRegDays resets all changes to the "regDays" field.
func (m *ActivityComponentMutation) ResetRegDays() {
	m.regDays = nil
	m.addregDays = nil
	delete(m.clearedFields, activitycomponent.FieldRegDays)
}

// SetSummary sets the "summary" field.
func (m *ActivityComponentMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ActivityComponentMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ActivityComponentMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[activitycomponent.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ActivityComponentMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ActivityComponentMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, activitycomponent.FieldSummary)
}

// SetAssetItemId sets the "assetItemId" field.
func (m *ActivityComponentMutation) SetAssetItemId(i int32) {
	m.assetItemId = &i
	m.addassetItemId = nil
}

// AssetItemId returns the value of the "assetItemId" field in the mutation.
func (m *ActivityComponentMutation) AssetItemId() (r int32, exists bool) {
	v := m.assetItemId
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetItemId returns the old "assetItemId" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldAssetItemId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetItemId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetItemId: %w", err)
	}
	return oldValue.AssetItemId, nil
}

// AddAssetItemId adds i to the "assetItemId" field.
func (m *ActivityComponentMutation) AddAssetItemId(i int32) {
	if m.addassetItemId != nil {
		*m.addassetItemId += i
	} else {
		m.addassetItemId = &i
	}
}

// AddedAssetItemId returns the value that was added to the "assetItemId" field in this mutation.
func (m *ActivityComponentMutation) AddedAssetItemId() (r int32, exists bool) {
	v := m.addassetItemId
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssetItemId clears the value of the "assetItemId" field.
func (m *ActivityComponentMutation) ClearAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
	m.clearedFields[activitycomponent.FieldAssetItemId] = struct{}{}
}

// AssetItemIdCleared returns if the "assetItemId" field was cleared in this mutation.
func (m *ActivityComponentMutation) AssetItemIdCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldAssetItemId]
	return ok
}

// ResetAssetItemId resets all changes to the "assetItemId" field.
func (m *ActivityComponentMutation) ResetAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
	delete(m.clearedFields, activitycomponent.FieldAssetItemId)
}

// SetAmount sets the "amount" field.
func (m *ActivityComponentMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ActivityComponentMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *ActivityComponentMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ActivityComponentMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *ActivityComponentMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[activitycomponent.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *ActivityComponentMutation) AmountCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *ActivityComponentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, activitycomponent.FieldAmount)
}

// SetResId sets the "resId" field.
func (m *ActivityComponentMutation) SetResId(i int64) {
	m.resId = &i
	m.addresId = nil
}

// ResId returns the value of the "resId" field in the mutation.
func (m *ActivityComponentMutation) ResId() (r int64, exists bool) {
	v := m.resId
	if v == nil {
		return
	}
	return *v, true
}

// OldResId returns the old "resId" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldResId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResId: %w", err)
	}
	return oldValue.ResId, nil
}

// AddResId adds i to the "resId" field.
func (m *ActivityComponentMutation) AddResId(i int64) {
	if m.addresId != nil {
		*m.addresId += i
	} else {
		m.addresId = &i
	}
}

// AddedResId returns the value that was added to the "resId" field in this mutation.
func (m *ActivityComponentMutation) AddedResId() (r int64, exists bool) {
	v := m.addresId
	if v == nil {
		return
	}
	return *v, true
}

// ClearResId clears the value of the "resId" field.
func (m *ActivityComponentMutation) ClearResId() {
	m.resId = nil
	m.addresId = nil
	m.clearedFields[activitycomponent.FieldResId] = struct{}{}
}

// ResIdCleared returns if the "resId" field was cleared in this mutation.
func (m *ActivityComponentMutation) ResIdCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldResId]
	return ok
}

// ResetResId resets all changes to the "resId" field.
func (m *ActivityComponentMutation) ResetResId() {
	m.resId = nil
	m.addresId = nil
	delete(m.clearedFields, activitycomponent.FieldResId)
}

// SetResDays sets the "resDays" field.
func (m *ActivityComponentMutation) SetResDays(i int32) {
	m.resDays = &i
	m.addresDays = nil
}

// ResDays returns the value of the "resDays" field in the mutation.
func (m *ActivityComponentMutation) ResDays() (r int32, exists bool) {
	v := m.resDays
	if v == nil {
		return
	}
	return *v, true
}

// OldResDays returns the old "resDays" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldResDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResDays: %w", err)
	}
	return oldValue.ResDays, nil
}

// AddResDays adds i to the "resDays" field.
func (m *ActivityComponentMutation) AddResDays(i int32) {
	if m.addresDays != nil {
		*m.addresDays += i
	} else {
		m.addresDays = &i
	}
}

// AddedResDays returns the value that was added to the "resDays" field in this mutation.
func (m *ActivityComponentMutation) AddedResDays() (r int32, exists bool) {
	v := m.addresDays
	if v == nil {
		return
	}
	return *v, true
}

// ClearResDays clears the value of the "resDays" field.
func (m *ActivityComponentMutation) ClearResDays() {
	m.resDays = nil
	m.addresDays = nil
	m.clearedFields[activitycomponent.FieldResDays] = struct{}{}
}

// ResDaysCleared returns if the "resDays" field was cleared in this mutation.
func (m *ActivityComponentMutation) ResDaysCleared() bool {
	_, ok := m.clearedFields[activitycomponent.FieldResDays]
	return ok
}

// ResetResDays resets all changes to the "resDays" field.
func (m *ActivityComponentMutation) ResetResDays() {
	m.resDays = nil
	m.addresDays = nil
	delete(m.clearedFields, activitycomponent.FieldResDays)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ActivityComponentMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ActivityComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ActivityComponentMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ActivityComponentMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ActivityComponentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ActivityComponentMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ActivityComponentMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ActivityComponentMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ActivityComponentMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ActivityComponentMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ActivityComponentMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ActivityComponentMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ActivityComponentMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ActivityComponentMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ActivityComponentMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ActivityComponentMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ActivityComponentMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ActivityComponentMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the ActivityComponent entity.
// If the ActivityComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityComponentMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ActivityComponentMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ActivityComponentMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ActivityComponentMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the ActivityComponentMutation builder.
func (m *ActivityComponentMutation) Where(ps ...predicate.ActivityComponent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivityComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ActivityComponent).
func (m *ActivityComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityComponentMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.activityCode != nil {
		fields = append(fields, activitycomponent.FieldActivityCode)
	}
	if m.componentType != nil {
		fields = append(fields, activitycomponent.FieldComponentType)
	}
	if m.policy != nil {
		fields = append(fields, activitycomponent.FieldPolicy)
	}
	if m.vipDays != nil {
		fields = append(fields, activitycomponent.FieldVipDays)
	}
	if m.minConsume != nil {
		fields = append(fields, activitycomponent.FieldMinConsume)
	}
	if m.maxConsume != nil {
		fields = append(fields, activitycomponent.FieldMaxConsume)
	}
	if m.minPayNum != nil {
		fields = append(fields, activitycomponent.FieldMinPayNum)
	}
	if m.payTimes != nil {
		fields = append(fields, activitycomponent.FieldPayTimes)
	}
	if m.payAmount != nil {
		fields = append(fields, activitycomponent.FieldPayAmount)
	}
	if m.regDays != nil {
		fields = append(fields, activitycomponent.FieldRegDays)
	}
	if m.summary != nil {
		fields = append(fields, activitycomponent.FieldSummary)
	}
	if m.assetItemId != nil {
		fields = append(fields, activitycomponent.FieldAssetItemId)
	}
	if m.amount != nil {
		fields = append(fields, activitycomponent.FieldAmount)
	}
	if m.resId != nil {
		fields = append(fields, activitycomponent.FieldResId)
	}
	if m.resDays != nil {
		fields = append(fields, activitycomponent.FieldResDays)
	}
	if m.createdAt != nil {
		fields = append(fields, activitycomponent.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, activitycomponent.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, activitycomponent.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, activitycomponent.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, activitycomponent.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitycomponent.FieldActivityCode:
		return m.ActivityCode()
	case activitycomponent.FieldComponentType:
		return m.ComponentType()
	case activitycomponent.FieldPolicy:
		return m.Policy()
	case activitycomponent.FieldVipDays:
		return m.VipDays()
	case activitycomponent.FieldMinConsume:
		return m.MinConsume()
	case activitycomponent.FieldMaxConsume:
		return m.MaxConsume()
	case activitycomponent.FieldMinPayNum:
		return m.MinPayNum()
	case activitycomponent.FieldPayTimes:
		return m.PayTimes()
	case activitycomponent.FieldPayAmount:
		return m.PayAmount()
	case activitycomponent.FieldRegDays:
		return m.RegDays()
	case activitycomponent.FieldSummary:
		return m.Summary()
	case activitycomponent.FieldAssetItemId:
		return m.AssetItemId()
	case activitycomponent.FieldAmount:
		return m.Amount()
	case activitycomponent.FieldResId:
		return m.ResId()
	case activitycomponent.FieldResDays:
		return m.ResDays()
	case activitycomponent.FieldCreatedAt:
		return m.CreatedAt()
	case activitycomponent.FieldUpdatedAt:
		return m.UpdatedAt()
	case activitycomponent.FieldCreateBy:
		return m.CreateBy()
	case activitycomponent.FieldUpdateBy:
		return m.UpdateBy()
	case activitycomponent.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitycomponent.FieldActivityCode:
		return m.OldActivityCode(ctx)
	case activitycomponent.FieldComponentType:
		return m.OldComponentType(ctx)
	case activitycomponent.FieldPolicy:
		return m.OldPolicy(ctx)
	case activitycomponent.FieldVipDays:
		return m.OldVipDays(ctx)
	case activitycomponent.FieldMinConsume:
		return m.OldMinConsume(ctx)
	case activitycomponent.FieldMaxConsume:
		return m.OldMaxConsume(ctx)
	case activitycomponent.FieldMinPayNum:
		return m.OldMinPayNum(ctx)
	case activitycomponent.FieldPayTimes:
		return m.OldPayTimes(ctx)
	case activitycomponent.FieldPayAmount:
		return m.OldPayAmount(ctx)
	case activitycomponent.FieldRegDays:
		return m.OldRegDays(ctx)
	case activitycomponent.FieldSummary:
		return m.OldSummary(ctx)
	case activitycomponent.FieldAssetItemId:
		return m.OldAssetItemId(ctx)
	case activitycomponent.FieldAmount:
		return m.OldAmount(ctx)
	case activitycomponent.FieldResId:
		return m.OldResId(ctx)
	case activitycomponent.FieldResDays:
		return m.OldResDays(ctx)
	case activitycomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activitycomponent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activitycomponent.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case activitycomponent.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case activitycomponent.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitycomponent.FieldActivityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityCode(v)
		return nil
	case activitycomponent.FieldComponentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentType(v)
		return nil
	case activitycomponent.FieldPolicy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicy(v)
		return nil
	case activitycomponent.FieldVipDays:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipDays(v)
		return nil
	case activitycomponent.FieldMinConsume:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinConsume(v)
		return nil
	case activitycomponent.FieldMaxConsume:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxConsume(v)
		return nil
	case activitycomponent.FieldMinPayNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinPayNum(v)
		return nil
	case activitycomponent.FieldPayTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTimes(v)
		return nil
	case activitycomponent.FieldPayAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayAmount(v)
		return nil
	case activitycomponent.FieldRegDays:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegDays(v)
		return nil
	case activitycomponent.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case activitycomponent.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetItemId(v)
		return nil
	case activitycomponent.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case activitycomponent.FieldResId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResId(v)
		return nil
	case activitycomponent.FieldResDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResDays(v)
		return nil
	case activitycomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activitycomponent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activitycomponent.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case activitycomponent.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case activitycomponent.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityComponentMutation) AddedFields() []string {
	var fields []string
	if m.addminConsume != nil {
		fields = append(fields, activitycomponent.FieldMinConsume)
	}
	if m.addmaxConsume != nil {
		fields = append(fields, activitycomponent.FieldMaxConsume)
	}
	if m.addminPayNum != nil {
		fields = append(fields, activitycomponent.FieldMinPayNum)
	}
	if m.addpayTimes != nil {
		fields = append(fields, activitycomponent.FieldPayTimes)
	}
	if m.addpayAmount != nil {
		fields = append(fields, activitycomponent.FieldPayAmount)
	}
	if m.addregDays != nil {
		fields = append(fields, activitycomponent.FieldRegDays)
	}
	if m.addassetItemId != nil {
		fields = append(fields, activitycomponent.FieldAssetItemId)
	}
	if m.addamount != nil {
		fields = append(fields, activitycomponent.FieldAmount)
	}
	if m.addresId != nil {
		fields = append(fields, activitycomponent.FieldResId)
	}
	if m.addresDays != nil {
		fields = append(fields, activitycomponent.FieldResDays)
	}
	if m.addcreateBy != nil {
		fields = append(fields, activitycomponent.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, activitycomponent.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, activitycomponent.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityComponentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activitycomponent.FieldMinConsume:
		return m.AddedMinConsume()
	case activitycomponent.FieldMaxConsume:
		return m.AddedMaxConsume()
	case activitycomponent.FieldMinPayNum:
		return m.AddedMinPayNum()
	case activitycomponent.FieldPayTimes:
		return m.AddedPayTimes()
	case activitycomponent.FieldPayAmount:
		return m.AddedPayAmount()
	case activitycomponent.FieldRegDays:
		return m.AddedRegDays()
	case activitycomponent.FieldAssetItemId:
		return m.AddedAssetItemId()
	case activitycomponent.FieldAmount:
		return m.AddedAmount()
	case activitycomponent.FieldResId:
		return m.AddedResId()
	case activitycomponent.FieldResDays:
		return m.AddedResDays()
	case activitycomponent.FieldCreateBy:
		return m.AddedCreateBy()
	case activitycomponent.FieldUpdateBy:
		return m.AddedUpdateBy()
	case activitycomponent.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activitycomponent.FieldMinConsume:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinConsume(v)
		return nil
	case activitycomponent.FieldMaxConsume:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxConsume(v)
		return nil
	case activitycomponent.FieldMinPayNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinPayNum(v)
		return nil
	case activitycomponent.FieldPayTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayTimes(v)
		return nil
	case activitycomponent.FieldPayAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayAmount(v)
		return nil
	case activitycomponent.FieldRegDays:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegDays(v)
		return nil
	case activitycomponent.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetItemId(v)
		return nil
	case activitycomponent.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case activitycomponent.FieldResId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResId(v)
		return nil
	case activitycomponent.FieldResDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResDays(v)
		return nil
	case activitycomponent.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case activitycomponent.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case activitycomponent.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activitycomponent.FieldActivityCode) {
		fields = append(fields, activitycomponent.FieldActivityCode)
	}
	if m.FieldCleared(activitycomponent.FieldComponentType) {
		fields = append(fields, activitycomponent.FieldComponentType)
	}
	if m.FieldCleared(activitycomponent.FieldPolicy) {
		fields = append(fields, activitycomponent.FieldPolicy)
	}
	if m.FieldCleared(activitycomponent.FieldVipDays) {
		fields = append(fields, activitycomponent.FieldVipDays)
	}
	if m.FieldCleared(activitycomponent.FieldMinConsume) {
		fields = append(fields, activitycomponent.FieldMinConsume)
	}
	if m.FieldCleared(activitycomponent.FieldMaxConsume) {
		fields = append(fields, activitycomponent.FieldMaxConsume)
	}
	if m.FieldCleared(activitycomponent.FieldMinPayNum) {
		fields = append(fields, activitycomponent.FieldMinPayNum)
	}
	if m.FieldCleared(activitycomponent.FieldPayTimes) {
		fields = append(fields, activitycomponent.FieldPayTimes)
	}
	if m.FieldCleared(activitycomponent.FieldPayAmount) {
		fields = append(fields, activitycomponent.FieldPayAmount)
	}
	if m.FieldCleared(activitycomponent.FieldRegDays) {
		fields = append(fields, activitycomponent.FieldRegDays)
	}
	if m.FieldCleared(activitycomponent.FieldSummary) {
		fields = append(fields, activitycomponent.FieldSummary)
	}
	if m.FieldCleared(activitycomponent.FieldAssetItemId) {
		fields = append(fields, activitycomponent.FieldAssetItemId)
	}
	if m.FieldCleared(activitycomponent.FieldAmount) {
		fields = append(fields, activitycomponent.FieldAmount)
	}
	if m.FieldCleared(activitycomponent.FieldResId) {
		fields = append(fields, activitycomponent.FieldResId)
	}
	if m.FieldCleared(activitycomponent.FieldResDays) {
		fields = append(fields, activitycomponent.FieldResDays)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityComponentMutation) ClearField(name string) error {
	switch name {
	case activitycomponent.FieldActivityCode:
		m.ClearActivityCode()
		return nil
	case activitycomponent.FieldComponentType:
		m.ClearComponentType()
		return nil
	case activitycomponent.FieldPolicy:
		m.ClearPolicy()
		return nil
	case activitycomponent.FieldVipDays:
		m.ClearVipDays()
		return nil
	case activitycomponent.FieldMinConsume:
		m.ClearMinConsume()
		return nil
	case activitycomponent.FieldMaxConsume:
		m.ClearMaxConsume()
		return nil
	case activitycomponent.FieldMinPayNum:
		m.ClearMinPayNum()
		return nil
	case activitycomponent.FieldPayTimes:
		m.ClearPayTimes()
		return nil
	case activitycomponent.FieldPayAmount:
		m.ClearPayAmount()
		return nil
	case activitycomponent.FieldRegDays:
		m.ClearRegDays()
		return nil
	case activitycomponent.FieldSummary:
		m.ClearSummary()
		return nil
	case activitycomponent.FieldAssetItemId:
		m.ClearAssetItemId()
		return nil
	case activitycomponent.FieldAmount:
		m.ClearAmount()
		return nil
	case activitycomponent.FieldResId:
		m.ClearResId()
		return nil
	case activitycomponent.FieldResDays:
		m.ClearResDays()
		return nil
	}
	return fmt.Errorf("unknown ActivityComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityComponentMutation) ResetField(name string) error {
	switch name {
	case activitycomponent.FieldActivityCode:
		m.ResetActivityCode()
		return nil
	case activitycomponent.FieldComponentType:
		m.ResetComponentType()
		return nil
	case activitycomponent.FieldPolicy:
		m.ResetPolicy()
		return nil
	case activitycomponent.FieldVipDays:
		m.ResetVipDays()
		return nil
	case activitycomponent.FieldMinConsume:
		m.ResetMinConsume()
		return nil
	case activitycomponent.FieldMaxConsume:
		m.ResetMaxConsume()
		return nil
	case activitycomponent.FieldMinPayNum:
		m.ResetMinPayNum()
		return nil
	case activitycomponent.FieldPayTimes:
		m.ResetPayTimes()
		return nil
	case activitycomponent.FieldPayAmount:
		m.ResetPayAmount()
		return nil
	case activitycomponent.FieldRegDays:
		m.ResetRegDays()
		return nil
	case activitycomponent.FieldSummary:
		m.ResetSummary()
		return nil
	case activitycomponent.FieldAssetItemId:
		m.ResetAssetItemId()
		return nil
	case activitycomponent.FieldAmount:
		m.ResetAmount()
		return nil
	case activitycomponent.FieldResId:
		m.ResetResId()
		return nil
	case activitycomponent.FieldResDays:
		m.ResetResDays()
		return nil
	case activitycomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activitycomponent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activitycomponent.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case activitycomponent.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case activitycomponent.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown ActivityComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityComponentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityComponentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityComponentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityComponentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ActivityComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityComponentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ActivityComponent edge %s", name)
}

// AdChangeLogMutation represents an operation that mutates the AdChangeLog nodes in the graph.
type AdChangeLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	adId          *string
	chId          *int64
	addchId       *int64
	deviceId      *string
	extInfo       *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AdChangeLog, error)
	predicates    []predicate.AdChangeLog
}

var _ ent.Mutation = (*AdChangeLogMutation)(nil)

// adchangelogOption allows management of the mutation configuration using functional options.
type adchangelogOption func(*AdChangeLogMutation)

// newAdChangeLogMutation creates new mutation for the AdChangeLog entity.
func newAdChangeLogMutation(c config, op Op, opts ...adchangelogOption) *AdChangeLogMutation {
	m := &AdChangeLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAdChangeLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdChangeLogID sets the ID field of the mutation.
func withAdChangeLogID(id int64) adchangelogOption {
	return func(m *AdChangeLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AdChangeLog
		)
		m.oldValue = func(ctx context.Context) (*AdChangeLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdChangeLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdChangeLog sets the old AdChangeLog of the mutation.
func withAdChangeLog(node *AdChangeLog) adchangelogOption {
	return func(m *AdChangeLogMutation) {
		m.oldValue = func(context.Context) (*AdChangeLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdChangeLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdChangeLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdChangeLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdChangeLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdChangeLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *AdChangeLogMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *AdChangeLogMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *AdChangeLogMutation) ResetUserId() {
	m.user = nil
}

// SetAdId sets the "adId" field.
func (m *AdChangeLogMutation) SetAdId(s string) {
	m.adId = &s
}

// AdId returns the value of the "adId" field in the mutation.
func (m *AdChangeLogMutation) AdId() (r string, exists bool) {
	v := m.adId
	if v == nil {
		return
	}
	return *v, true
}

// OldAdId returns the old "adId" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldAdId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdId: %w", err)
	}
	return oldValue.AdId, nil
}

// ClearAdId clears the value of the "adId" field.
func (m *AdChangeLogMutation) ClearAdId() {
	m.adId = nil
	m.clearedFields[adchangelog.FieldAdId] = struct{}{}
}

// AdIdCleared returns if the "adId" field was cleared in this mutation.
func (m *AdChangeLogMutation) AdIdCleared() bool {
	_, ok := m.clearedFields[adchangelog.FieldAdId]
	return ok
}

// ResetAdId resets all changes to the "adId" field.
func (m *AdChangeLogMutation) ResetAdId() {
	m.adId = nil
	delete(m.clearedFields, adchangelog.FieldAdId)
}

// SetChId sets the "chId" field.
func (m *AdChangeLogMutation) SetChId(i int64) {
	m.chId = &i
	m.addchId = nil
}

// ChId returns the value of the "chId" field in the mutation.
func (m *AdChangeLogMutation) ChId() (r int64, exists bool) {
	v := m.chId
	if v == nil {
		return
	}
	return *v, true
}

// OldChId returns the old "chId" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldChId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChId: %w", err)
	}
	return oldValue.ChId, nil
}

// AddChId adds i to the "chId" field.
func (m *AdChangeLogMutation) AddChId(i int64) {
	if m.addchId != nil {
		*m.addchId += i
	} else {
		m.addchId = &i
	}
}

// AddedChId returns the value that was added to the "chId" field in this mutation.
func (m *AdChangeLogMutation) AddedChId() (r int64, exists bool) {
	v := m.addchId
	if v == nil {
		return
	}
	return *v, true
}

// ClearChId clears the value of the "chId" field.
func (m *AdChangeLogMutation) ClearChId() {
	m.chId = nil
	m.addchId = nil
	m.clearedFields[adchangelog.FieldChId] = struct{}{}
}

// ChIdCleared returns if the "chId" field was cleared in this mutation.
func (m *AdChangeLogMutation) ChIdCleared() bool {
	_, ok := m.clearedFields[adchangelog.FieldChId]
	return ok
}

// ResetChId resets all changes to the "chId" field.
func (m *AdChangeLogMutation) ResetChId() {
	m.chId = nil
	m.addchId = nil
	delete(m.clearedFields, adchangelog.FieldChId)
}

// SetDeviceId sets the "deviceId" field.
func (m *AdChangeLogMutation) SetDeviceId(s string) {
	m.deviceId = &s
}

// DeviceId returns the value of the "deviceId" field in the mutation.
func (m *AdChangeLogMutation) DeviceId() (r string, exists bool) {
	v := m.deviceId
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceId returns the old "deviceId" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldDeviceId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceId: %w", err)
	}
	return oldValue.DeviceId, nil
}

// ClearDeviceId clears the value of the "deviceId" field.
func (m *AdChangeLogMutation) ClearDeviceId() {
	m.deviceId = nil
	m.clearedFields[adchangelog.FieldDeviceId] = struct{}{}
}

// DeviceIdCleared returns if the "deviceId" field was cleared in this mutation.
func (m *AdChangeLogMutation) DeviceIdCleared() bool {
	_, ok := m.clearedFields[adchangelog.FieldDeviceId]
	return ok
}

// ResetDeviceId resets all changes to the "deviceId" field.
func (m *AdChangeLogMutation) ResetDeviceId() {
	m.deviceId = nil
	delete(m.clearedFields, adchangelog.FieldDeviceId)
}

// SetExtInfo sets the "extInfo" field.
func (m *AdChangeLogMutation) SetExtInfo(s string) {
	m.extInfo = &s
}

// ExtInfo returns the value of the "extInfo" field in the mutation.
func (m *AdChangeLogMutation) ExtInfo() (r string, exists bool) {
	v := m.extInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldExtInfo returns the old "extInfo" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldExtInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtInfo: %w", err)
	}
	return oldValue.ExtInfo, nil
}

// ClearExtInfo clears the value of the "extInfo" field.
func (m *AdChangeLogMutation) ClearExtInfo() {
	m.extInfo = nil
	m.clearedFields[adchangelog.FieldExtInfo] = struct{}{}
}

// ExtInfoCleared returns if the "extInfo" field was cleared in this mutation.
func (m *AdChangeLogMutation) ExtInfoCleared() bool {
	_, ok := m.clearedFields[adchangelog.FieldExtInfo]
	return ok
}

// ResetExtInfo resets all changes to the "extInfo" field.
func (m *AdChangeLogMutation) ResetExtInfo() {
	m.extInfo = nil
	delete(m.clearedFields, adchangelog.FieldExtInfo)
}

// SetCreatedAt sets the "createdAt" field.
func (m *AdChangeLogMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AdChangeLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AdChangeLogMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AdChangeLogMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AdChangeLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AdChangeLogMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AdChangeLogMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AdChangeLogMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AdChangeLogMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AdChangeLogMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AdChangeLogMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AdChangeLogMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AdChangeLogMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AdChangeLogMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AdChangeLogMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AdChangeLogMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AdChangeLogMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AdChangeLogMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AdChangeLog entity.
// If the AdChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChangeLogMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AdChangeLogMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AdChangeLogMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AdChangeLogMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *AdChangeLogMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *AdChangeLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *AdChangeLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AdChangeLogMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AdChangeLogMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AdChangeLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AdChangeLogMutation builder.
func (m *AdChangeLogMutation) Where(ps ...predicate.AdChangeLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdChangeLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdChangeLog).
func (m *AdChangeLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdChangeLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, adchangelog.FieldUserId)
	}
	if m.adId != nil {
		fields = append(fields, adchangelog.FieldAdId)
	}
	if m.chId != nil {
		fields = append(fields, adchangelog.FieldChId)
	}
	if m.deviceId != nil {
		fields = append(fields, adchangelog.FieldDeviceId)
	}
	if m.extInfo != nil {
		fields = append(fields, adchangelog.FieldExtInfo)
	}
	if m.createdAt != nil {
		fields = append(fields, adchangelog.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, adchangelog.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, adchangelog.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, adchangelog.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, adchangelog.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdChangeLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adchangelog.FieldUserId:
		return m.UserId()
	case adchangelog.FieldAdId:
		return m.AdId()
	case adchangelog.FieldChId:
		return m.ChId()
	case adchangelog.FieldDeviceId:
		return m.DeviceId()
	case adchangelog.FieldExtInfo:
		return m.ExtInfo()
	case adchangelog.FieldCreatedAt:
		return m.CreatedAt()
	case adchangelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case adchangelog.FieldCreateBy:
		return m.CreateBy()
	case adchangelog.FieldUpdateBy:
		return m.UpdateBy()
	case adchangelog.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdChangeLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adchangelog.FieldUserId:
		return m.OldUserId(ctx)
	case adchangelog.FieldAdId:
		return m.OldAdId(ctx)
	case adchangelog.FieldChId:
		return m.OldChId(ctx)
	case adchangelog.FieldDeviceId:
		return m.OldDeviceId(ctx)
	case adchangelog.FieldExtInfo:
		return m.OldExtInfo(ctx)
	case adchangelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adchangelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adchangelog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case adchangelog.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case adchangelog.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AdChangeLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdChangeLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adchangelog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case adchangelog.FieldAdId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdId(v)
		return nil
	case adchangelog.FieldChId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChId(v)
		return nil
	case adchangelog.FieldDeviceId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceId(v)
		return nil
	case adchangelog.FieldExtInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtInfo(v)
		return nil
	case adchangelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adchangelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adchangelog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case adchangelog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case adchangelog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AdChangeLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdChangeLogMutation) AddedFields() []string {
	var fields []string
	if m.addchId != nil {
		fields = append(fields, adchangelog.FieldChId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, adchangelog.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, adchangelog.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, adchangelog.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdChangeLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adchangelog.FieldChId:
		return m.AddedChId()
	case adchangelog.FieldCreateBy:
		return m.AddedCreateBy()
	case adchangelog.FieldUpdateBy:
		return m.AddedUpdateBy()
	case adchangelog.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdChangeLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adchangelog.FieldChId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChId(v)
		return nil
	case adchangelog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case adchangelog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case adchangelog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AdChangeLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdChangeLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adchangelog.FieldAdId) {
		fields = append(fields, adchangelog.FieldAdId)
	}
	if m.FieldCleared(adchangelog.FieldChId) {
		fields = append(fields, adchangelog.FieldChId)
	}
	if m.FieldCleared(adchangelog.FieldDeviceId) {
		fields = append(fields, adchangelog.FieldDeviceId)
	}
	if m.FieldCleared(adchangelog.FieldExtInfo) {
		fields = append(fields, adchangelog.FieldExtInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdChangeLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdChangeLogMutation) ClearField(name string) error {
	switch name {
	case adchangelog.FieldAdId:
		m.ClearAdId()
		return nil
	case adchangelog.FieldChId:
		m.ClearChId()
		return nil
	case adchangelog.FieldDeviceId:
		m.ClearDeviceId()
		return nil
	case adchangelog.FieldExtInfo:
		m.ClearExtInfo()
		return nil
	}
	return fmt.Errorf("unknown AdChangeLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdChangeLogMutation) ResetField(name string) error {
	switch name {
	case adchangelog.FieldUserId:
		m.ResetUserId()
		return nil
	case adchangelog.FieldAdId:
		m.ResetAdId()
		return nil
	case adchangelog.FieldChId:
		m.ResetChId()
		return nil
	case adchangelog.FieldDeviceId:
		m.ResetDeviceId()
		return nil
	case adchangelog.FieldExtInfo:
		m.ResetExtInfo()
		return nil
	case adchangelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adchangelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adchangelog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case adchangelog.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case adchangelog.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AdChangeLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdChangeLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, adchangelog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdChangeLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adchangelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdChangeLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdChangeLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdChangeLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, adchangelog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdChangeLogMutation) EdgeCleared(name string) bool {
	switch name {
	case adchangelog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdChangeLogMutation) ClearEdge(name string) error {
	switch name {
	case adchangelog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AdChangeLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdChangeLogMutation) ResetEdge(name string) error {
	switch name {
	case adchangelog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AdChangeLog edge %s", name)
}

// AdChannelMutation represents an operation that mutates the AdChannel nodes in the graph.
type AdChannelMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	channelName   *string
	novelId       *int64
	addnovelId    *int64
	reg           *int64
	addreg        *int64
	pay           *int64
	addpay        *int64
	novelName     *string
	chapterId     *int64
	addchapterId  *int64
	chapterNum    *int32
	addchapterNum *int32
	adType        *string
	img           *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	users         map[int64]struct{}
	removedusers  map[int64]struct{}
	clearedusers  bool
	orders        map[int64]struct{}
	removedorders map[int64]struct{}
	clearedorders bool
	done          bool
	oldValue      func(context.Context) (*AdChannel, error)
	predicates    []predicate.AdChannel
}

var _ ent.Mutation = (*AdChannelMutation)(nil)

// adchannelOption allows management of the mutation configuration using functional options.
type adchannelOption func(*AdChannelMutation)

// newAdChannelMutation creates new mutation for the AdChannel entity.
func newAdChannelMutation(c config, op Op, opts ...adchannelOption) *AdChannelMutation {
	m := &AdChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeAdChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdChannelID sets the ID field of the mutation.
func withAdChannelID(id int64) adchannelOption {
	return func(m *AdChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *AdChannel
		)
		m.oldValue = func(ctx context.Context) (*AdChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdChannel sets the old AdChannel of the mutation.
func withAdChannel(node *AdChannel) adchannelOption {
	return func(m *AdChannelMutation) {
		m.oldValue = func(context.Context) (*AdChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdChannelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdChannelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannelName sets the "channelName" field.
func (m *AdChannelMutation) SetChannelName(s string) {
	m.channelName = &s
}

// ChannelName returns the value of the "channelName" field in the mutation.
func (m *AdChannelMutation) ChannelName() (r string, exists bool) {
	v := m.channelName
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelName returns the old "channelName" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldChannelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelName: %w", err)
	}
	return oldValue.ChannelName, nil
}

// ClearChannelName clears the value of the "channelName" field.
func (m *AdChannelMutation) ClearChannelName() {
	m.channelName = nil
	m.clearedFields[adchannel.FieldChannelName] = struct{}{}
}

// ChannelNameCleared returns if the "channelName" field was cleared in this mutation.
func (m *AdChannelMutation) ChannelNameCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldChannelName]
	return ok
}

// ResetChannelName resets all changes to the "channelName" field.
func (m *AdChannelMutation) ResetChannelName() {
	m.channelName = nil
	delete(m.clearedFields, adchannel.FieldChannelName)
}

// SetNovelId sets the "novelId" field.
func (m *AdChannelMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *AdChannelMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *AdChannelMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *AdChannelMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *AdChannelMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[adchannel.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *AdChannelMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *AdChannelMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, adchannel.FieldNovelId)
}

// SetReg sets the "reg" field.
func (m *AdChannelMutation) SetReg(i int64) {
	m.reg = &i
	m.addreg = nil
}

// Reg returns the value of the "reg" field in the mutation.
func (m *AdChannelMutation) Reg() (r int64, exists bool) {
	v := m.reg
	if v == nil {
		return
	}
	return *v, true
}

// OldReg returns the old "reg" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldReg(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReg: %w", err)
	}
	return oldValue.Reg, nil
}

// AddReg adds i to the "reg" field.
func (m *AdChannelMutation) AddReg(i int64) {
	if m.addreg != nil {
		*m.addreg += i
	} else {
		m.addreg = &i
	}
}

// AddedReg returns the value that was added to the "reg" field in this mutation.
func (m *AdChannelMutation) AddedReg() (r int64, exists bool) {
	v := m.addreg
	if v == nil {
		return
	}
	return *v, true
}

// ClearReg clears the value of the "reg" field.
func (m *AdChannelMutation) ClearReg() {
	m.reg = nil
	m.addreg = nil
	m.clearedFields[adchannel.FieldReg] = struct{}{}
}

// RegCleared returns if the "reg" field was cleared in this mutation.
func (m *AdChannelMutation) RegCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldReg]
	return ok
}

// ResetReg resets all changes to the "reg" field.
func (m *AdChannelMutation) ResetReg() {
	m.reg = nil
	m.addreg = nil
	delete(m.clearedFields, adchannel.FieldReg)
}

// SetPay sets the "pay" field.
func (m *AdChannelMutation) SetPay(i int64) {
	m.pay = &i
	m.addpay = nil
}

// Pay returns the value of the "pay" field in the mutation.
func (m *AdChannelMutation) Pay() (r int64, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old "pay" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldPay(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// AddPay adds i to the "pay" field.
func (m *AdChannelMutation) AddPay(i int64) {
	if m.addpay != nil {
		*m.addpay += i
	} else {
		m.addpay = &i
	}
}

// AddedPay returns the value that was added to the "pay" field in this mutation.
func (m *AdChannelMutation) AddedPay() (r int64, exists bool) {
	v := m.addpay
	if v == nil {
		return
	}
	return *v, true
}

// ClearPay clears the value of the "pay" field.
func (m *AdChannelMutation) ClearPay() {
	m.pay = nil
	m.addpay = nil
	m.clearedFields[adchannel.FieldPay] = struct{}{}
}

// PayCleared returns if the "pay" field was cleared in this mutation.
func (m *AdChannelMutation) PayCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldPay]
	return ok
}

// ResetPay resets all changes to the "pay" field.
func (m *AdChannelMutation) ResetPay() {
	m.pay = nil
	m.addpay = nil
	delete(m.clearedFields, adchannel.FieldPay)
}

// SetNovelName sets the "novelName" field.
func (m *AdChannelMutation) SetNovelName(s string) {
	m.novelName = &s
}

// NovelName returns the value of the "novelName" field in the mutation.
func (m *AdChannelMutation) NovelName() (r string, exists bool) {
	v := m.novelName
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelName returns the old "novelName" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldNovelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelName: %w", err)
	}
	return oldValue.NovelName, nil
}

// ClearNovelName clears the value of the "novelName" field.
func (m *AdChannelMutation) ClearNovelName() {
	m.novelName = nil
	m.clearedFields[adchannel.FieldNovelName] = struct{}{}
}

// NovelNameCleared returns if the "novelName" field was cleared in this mutation.
func (m *AdChannelMutation) NovelNameCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldNovelName]
	return ok
}

// ResetNovelName resets all changes to the "novelName" field.
func (m *AdChannelMutation) ResetNovelName() {
	m.novelName = nil
	delete(m.clearedFields, adchannel.FieldNovelName)
}

// SetChapterId sets the "chapterId" field.
func (m *AdChannelMutation) SetChapterId(i int64) {
	m.chapterId = &i
	m.addchapterId = nil
}

// ChapterId returns the value of the "chapterId" field in the mutation.
func (m *AdChannelMutation) ChapterId() (r int64, exists bool) {
	v := m.chapterId
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterId returns the old "chapterId" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldChapterId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterId: %w", err)
	}
	return oldValue.ChapterId, nil
}

// AddChapterId adds i to the "chapterId" field.
func (m *AdChannelMutation) AddChapterId(i int64) {
	if m.addchapterId != nil {
		*m.addchapterId += i
	} else {
		m.addchapterId = &i
	}
}

// AddedChapterId returns the value that was added to the "chapterId" field in this mutation.
func (m *AdChannelMutation) AddedChapterId() (r int64, exists bool) {
	v := m.addchapterId
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterId clears the value of the "chapterId" field.
func (m *AdChannelMutation) ClearChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
	m.clearedFields[adchannel.FieldChapterId] = struct{}{}
}

// ChapterIdCleared returns if the "chapterId" field was cleared in this mutation.
func (m *AdChannelMutation) ChapterIdCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldChapterId]
	return ok
}

// ResetChapterId resets all changes to the "chapterId" field.
func (m *AdChannelMutation) ResetChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
	delete(m.clearedFields, adchannel.FieldChapterId)
}

// SetChapterNum sets the "chapterNum" field.
func (m *AdChannelMutation) SetChapterNum(i int32) {
	m.chapterNum = &i
	m.addchapterNum = nil
}

// ChapterNum returns the value of the "chapterNum" field in the mutation.
func (m *AdChannelMutation) ChapterNum() (r int32, exists bool) {
	v := m.chapterNum
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterNum returns the old "chapterNum" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldChapterNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterNum: %w", err)
	}
	return oldValue.ChapterNum, nil
}

// AddChapterNum adds i to the "chapterNum" field.
func (m *AdChannelMutation) AddChapterNum(i int32) {
	if m.addchapterNum != nil {
		*m.addchapterNum += i
	} else {
		m.addchapterNum = &i
	}
}

// AddedChapterNum returns the value that was added to the "chapterNum" field in this mutation.
func (m *AdChannelMutation) AddedChapterNum() (r int32, exists bool) {
	v := m.addchapterNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterNum clears the value of the "chapterNum" field.
func (m *AdChannelMutation) ClearChapterNum() {
	m.chapterNum = nil
	m.addchapterNum = nil
	m.clearedFields[adchannel.FieldChapterNum] = struct{}{}
}

// ChapterNumCleared returns if the "chapterNum" field was cleared in this mutation.
func (m *AdChannelMutation) ChapterNumCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldChapterNum]
	return ok
}

// ResetChapterNum resets all changes to the "chapterNum" field.
func (m *AdChannelMutation) ResetChapterNum() {
	m.chapterNum = nil
	m.addchapterNum = nil
	delete(m.clearedFields, adchannel.FieldChapterNum)
}

// SetAdType sets the "adType" field.
func (m *AdChannelMutation) SetAdType(s string) {
	m.adType = &s
}

// AdType returns the value of the "adType" field in the mutation.
func (m *AdChannelMutation) AdType() (r string, exists bool) {
	v := m.adType
	if v == nil {
		return
	}
	return *v, true
}

// OldAdType returns the old "adType" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldAdType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdType: %w", err)
	}
	return oldValue.AdType, nil
}

// ClearAdType clears the value of the "adType" field.
func (m *AdChannelMutation) ClearAdType() {
	m.adType = nil
	m.clearedFields[adchannel.FieldAdType] = struct{}{}
}

// AdTypeCleared returns if the "adType" field was cleared in this mutation.
func (m *AdChannelMutation) AdTypeCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldAdType]
	return ok
}

// ResetAdType resets all changes to the "adType" field.
func (m *AdChannelMutation) ResetAdType() {
	m.adType = nil
	delete(m.clearedFields, adchannel.FieldAdType)
}

// SetImg sets the "img" field.
func (m *AdChannelMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *AdChannelMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ClearImg clears the value of the "img" field.
func (m *AdChannelMutation) ClearImg() {
	m.img = nil
	m.clearedFields[adchannel.FieldImg] = struct{}{}
}

// ImgCleared returns if the "img" field was cleared in this mutation.
func (m *AdChannelMutation) ImgCleared() bool {
	_, ok := m.clearedFields[adchannel.FieldImg]
	return ok
}

// ResetImg resets all changes to the "img" field.
func (m *AdChannelMutation) ResetImg() {
	m.img = nil
	delete(m.clearedFields, adchannel.FieldImg)
}

// SetCreatedAt sets the "createdAt" field.
func (m *AdChannelMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AdChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AdChannelMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AdChannelMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AdChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AdChannelMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AdChannelMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AdChannelMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AdChannelMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AdChannelMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AdChannelMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AdChannelMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AdChannelMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AdChannelMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AdChannelMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AdChannelMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AdChannelMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AdChannelMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AdChannel entity.
// If the AdChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdChannelMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AdChannelMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AdChannelMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AdChannelMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// AddUserIDs adds the "users" edge to the SocialUser entity by ids.
func (m *AdChannelMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the SocialUser entity.
func (m *AdChannelMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the SocialUser entity was cleared.
func (m *AdChannelMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the SocialUser entity by IDs.
func (m *AdChannelMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the SocialUser entity.
func (m *AdChannelMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AdChannelMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AdChannelMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddOrderIDs adds the "orders" edge to the PayOrder entity by ids.
func (m *AdChannelMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the PayOrder entity.
func (m *AdChannelMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the PayOrder entity was cleared.
func (m *AdChannelMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the PayOrder entity by IDs.
func (m *AdChannelMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the PayOrder entity.
func (m *AdChannelMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AdChannelMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AdChannelMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the AdChannelMutation builder.
func (m *AdChannelMutation) Where(ps ...predicate.AdChannel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdChannelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdChannel).
func (m *AdChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdChannelMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.channelName != nil {
		fields = append(fields, adchannel.FieldChannelName)
	}
	if m.novelId != nil {
		fields = append(fields, adchannel.FieldNovelId)
	}
	if m.reg != nil {
		fields = append(fields, adchannel.FieldReg)
	}
	if m.pay != nil {
		fields = append(fields, adchannel.FieldPay)
	}
	if m.novelName != nil {
		fields = append(fields, adchannel.FieldNovelName)
	}
	if m.chapterId != nil {
		fields = append(fields, adchannel.FieldChapterId)
	}
	if m.chapterNum != nil {
		fields = append(fields, adchannel.FieldChapterNum)
	}
	if m.adType != nil {
		fields = append(fields, adchannel.FieldAdType)
	}
	if m.img != nil {
		fields = append(fields, adchannel.FieldImg)
	}
	if m.createdAt != nil {
		fields = append(fields, adchannel.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, adchannel.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, adchannel.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, adchannel.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, adchannel.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adchannel.FieldChannelName:
		return m.ChannelName()
	case adchannel.FieldNovelId:
		return m.NovelId()
	case adchannel.FieldReg:
		return m.Reg()
	case adchannel.FieldPay:
		return m.Pay()
	case adchannel.FieldNovelName:
		return m.NovelName()
	case adchannel.FieldChapterId:
		return m.ChapterId()
	case adchannel.FieldChapterNum:
		return m.ChapterNum()
	case adchannel.FieldAdType:
		return m.AdType()
	case adchannel.FieldImg:
		return m.Img()
	case adchannel.FieldCreatedAt:
		return m.CreatedAt()
	case adchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case adchannel.FieldCreateBy:
		return m.CreateBy()
	case adchannel.FieldUpdateBy:
		return m.UpdateBy()
	case adchannel.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adchannel.FieldChannelName:
		return m.OldChannelName(ctx)
	case adchannel.FieldNovelId:
		return m.OldNovelId(ctx)
	case adchannel.FieldReg:
		return m.OldReg(ctx)
	case adchannel.FieldPay:
		return m.OldPay(ctx)
	case adchannel.FieldNovelName:
		return m.OldNovelName(ctx)
	case adchannel.FieldChapterId:
		return m.OldChapterId(ctx)
	case adchannel.FieldChapterNum:
		return m.OldChapterNum(ctx)
	case adchannel.FieldAdType:
		return m.OldAdType(ctx)
	case adchannel.FieldImg:
		return m.OldImg(ctx)
	case adchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adchannel.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case adchannel.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case adchannel.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AdChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adchannel.FieldChannelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelName(v)
		return nil
	case adchannel.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case adchannel.FieldReg:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReg(v)
		return nil
	case adchannel.FieldPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	case adchannel.FieldNovelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelName(v)
		return nil
	case adchannel.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterId(v)
		return nil
	case adchannel.FieldChapterNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterNum(v)
		return nil
	case adchannel.FieldAdType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdType(v)
		return nil
	case adchannel.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case adchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adchannel.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case adchannel.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case adchannel.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AdChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdChannelMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, adchannel.FieldNovelId)
	}
	if m.addreg != nil {
		fields = append(fields, adchannel.FieldReg)
	}
	if m.addpay != nil {
		fields = append(fields, adchannel.FieldPay)
	}
	if m.addchapterId != nil {
		fields = append(fields, adchannel.FieldChapterId)
	}
	if m.addchapterNum != nil {
		fields = append(fields, adchannel.FieldChapterNum)
	}
	if m.addcreateBy != nil {
		fields = append(fields, adchannel.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, adchannel.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, adchannel.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adchannel.FieldNovelId:
		return m.AddedNovelId()
	case adchannel.FieldReg:
		return m.AddedReg()
	case adchannel.FieldPay:
		return m.AddedPay()
	case adchannel.FieldChapterId:
		return m.AddedChapterId()
	case adchannel.FieldChapterNum:
		return m.AddedChapterNum()
	case adchannel.FieldCreateBy:
		return m.AddedCreateBy()
	case adchannel.FieldUpdateBy:
		return m.AddedUpdateBy()
	case adchannel.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adchannel.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case adchannel.FieldReg:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReg(v)
		return nil
	case adchannel.FieldPay:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPay(v)
		return nil
	case adchannel.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterId(v)
		return nil
	case adchannel.FieldChapterNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterNum(v)
		return nil
	case adchannel.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case adchannel.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case adchannel.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AdChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adchannel.FieldChannelName) {
		fields = append(fields, adchannel.FieldChannelName)
	}
	if m.FieldCleared(adchannel.FieldNovelId) {
		fields = append(fields, adchannel.FieldNovelId)
	}
	if m.FieldCleared(adchannel.FieldReg) {
		fields = append(fields, adchannel.FieldReg)
	}
	if m.FieldCleared(adchannel.FieldPay) {
		fields = append(fields, adchannel.FieldPay)
	}
	if m.FieldCleared(adchannel.FieldNovelName) {
		fields = append(fields, adchannel.FieldNovelName)
	}
	if m.FieldCleared(adchannel.FieldChapterId) {
		fields = append(fields, adchannel.FieldChapterId)
	}
	if m.FieldCleared(adchannel.FieldChapterNum) {
		fields = append(fields, adchannel.FieldChapterNum)
	}
	if m.FieldCleared(adchannel.FieldAdType) {
		fields = append(fields, adchannel.FieldAdType)
	}
	if m.FieldCleared(adchannel.FieldImg) {
		fields = append(fields, adchannel.FieldImg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdChannelMutation) ClearField(name string) error {
	switch name {
	case adchannel.FieldChannelName:
		m.ClearChannelName()
		return nil
	case adchannel.FieldNovelId:
		m.ClearNovelId()
		return nil
	case adchannel.FieldReg:
		m.ClearReg()
		return nil
	case adchannel.FieldPay:
		m.ClearPay()
		return nil
	case adchannel.FieldNovelName:
		m.ClearNovelName()
		return nil
	case adchannel.FieldChapterId:
		m.ClearChapterId()
		return nil
	case adchannel.FieldChapterNum:
		m.ClearChapterNum()
		return nil
	case adchannel.FieldAdType:
		m.ClearAdType()
		return nil
	case adchannel.FieldImg:
		m.ClearImg()
		return nil
	}
	return fmt.Errorf("unknown AdChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdChannelMutation) ResetField(name string) error {
	switch name {
	case adchannel.FieldChannelName:
		m.ResetChannelName()
		return nil
	case adchannel.FieldNovelId:
		m.ResetNovelId()
		return nil
	case adchannel.FieldReg:
		m.ResetReg()
		return nil
	case adchannel.FieldPay:
		m.ResetPay()
		return nil
	case adchannel.FieldNovelName:
		m.ResetNovelName()
		return nil
	case adchannel.FieldChapterId:
		m.ResetChapterId()
		return nil
	case adchannel.FieldChapterNum:
		m.ResetChapterNum()
		return nil
	case adchannel.FieldAdType:
		m.ResetAdType()
		return nil
	case adchannel.FieldImg:
		m.ResetImg()
		return nil
	case adchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adchannel.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case adchannel.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case adchannel.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AdChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, adchannel.EdgeUsers)
	}
	if m.orders != nil {
		edges = append(edges, adchannel.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adchannel.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case adchannel.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, adchannel.EdgeUsers)
	}
	if m.removedorders != nil {
		edges = append(edges, adchannel.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adchannel.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case adchannel.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, adchannel.EdgeUsers)
	}
	if m.clearedorders {
		edges = append(edges, adchannel.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case adchannel.EdgeUsers:
		return m.clearedusers
	case adchannel.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AdChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdChannelMutation) ResetEdge(name string) error {
	switch name {
	case adchannel.EdgeUsers:
		m.ResetUsers()
		return nil
	case adchannel.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown AdChannel edge %s", name)
}

// AgreementLogMutation represents an operation that mutates the AgreementLog nodes in the graph.
type AgreementLogMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	outerAgreementNo *string
	orderId          *string
	userId           *int64
	adduserId        *int64
	chId             *int64
	addchId          *int64
	userName         *string
	paymentName      *string
	paymentId        *int64
	addpaymentId     *int64
	state            *int32
	addstate         *int32
	payment          *int64
	addpayment       *int64
	agreementType    *agreementlog.AgreementType
	vipType          *int64
	addvipType       *int64
	times            *int64
	addtimes         *int64
	cycleDays        *int32
	addcycleDays     *int32
	nextExecTime     *time.Time
	remark           *string
	createdAt        *time.Time
	updatedAt        *time.Time
	createBy         *int64
	addcreateBy      *int64
	updateBy         *int64
	addupdateBy      *int64
	tenantId         *int64
	addtenantId      *int64
	clearedFields    map[string]struct{}
	orders           map[int64]struct{}
	removedorders    map[int64]struct{}
	clearedorders    bool
	done             bool
	oldValue         func(context.Context) (*AgreementLog, error)
	predicates       []predicate.AgreementLog
}

var _ ent.Mutation = (*AgreementLogMutation)(nil)

// agreementlogOption allows management of the mutation configuration using functional options.
type agreementlogOption func(*AgreementLogMutation)

// newAgreementLogMutation creates new mutation for the AgreementLog entity.
func newAgreementLogMutation(c config, op Op, opts ...agreementlogOption) *AgreementLogMutation {
	m := &AgreementLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAgreementLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgreementLogID sets the ID field of the mutation.
func withAgreementLogID(id int64) agreementlogOption {
	return func(m *AgreementLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AgreementLog
		)
		m.oldValue = func(ctx context.Context) (*AgreementLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgreementLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgreementLog sets the old AgreementLog of the mutation.
func withAgreementLog(node *AgreementLog) agreementlogOption {
	return func(m *AgreementLogMutation) {
		m.oldValue = func(context.Context) (*AgreementLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgreementLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgreementLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgreementLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgreementLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgreementLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOuterAgreementNo sets the "outerAgreementNo" field.
func (m *AgreementLogMutation) SetOuterAgreementNo(s string) {
	m.outerAgreementNo = &s
}

// OuterAgreementNo returns the value of the "outerAgreementNo" field in the mutation.
func (m *AgreementLogMutation) OuterAgreementNo() (r string, exists bool) {
	v := m.outerAgreementNo
	if v == nil {
		return
	}
	return *v, true
}

// OldOuterAgreementNo returns the old "outerAgreementNo" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldOuterAgreementNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOuterAgreementNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOuterAgreementNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOuterAgreementNo: %w", err)
	}
	return oldValue.OuterAgreementNo, nil
}

// ClearOuterAgreementNo clears the value of the "outerAgreementNo" field.
func (m *AgreementLogMutation) ClearOuterAgreementNo() {
	m.outerAgreementNo = nil
	m.clearedFields[agreementlog.FieldOuterAgreementNo] = struct{}{}
}

// OuterAgreementNoCleared returns if the "outerAgreementNo" field was cleared in this mutation.
func (m *AgreementLogMutation) OuterAgreementNoCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldOuterAgreementNo]
	return ok
}

// ResetOuterAgreementNo resets all changes to the "outerAgreementNo" field.
func (m *AgreementLogMutation) ResetOuterAgreementNo() {
	m.outerAgreementNo = nil
	delete(m.clearedFields, agreementlog.FieldOuterAgreementNo)
}

// SetOrderId sets the "orderId" field.
func (m *AgreementLogMutation) SetOrderId(s string) {
	m.orderId = &s
}

// OrderId returns the value of the "orderId" field in the mutation.
func (m *AgreementLogMutation) OrderId() (r string, exists bool) {
	v := m.orderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderId returns the old "orderId" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldOrderId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderId: %w", err)
	}
	return oldValue.OrderId, nil
}

// ClearOrderId clears the value of the "orderId" field.
func (m *AgreementLogMutation) ClearOrderId() {
	m.orderId = nil
	m.clearedFields[agreementlog.FieldOrderId] = struct{}{}
}

// OrderIdCleared returns if the "orderId" field was cleared in this mutation.
func (m *AgreementLogMutation) OrderIdCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldOrderId]
	return ok
}

// ResetOrderId resets all changes to the "orderId" field.
func (m *AgreementLogMutation) ResetOrderId() {
	m.orderId = nil
	delete(m.clearedFields, agreementlog.FieldOrderId)
}

// SetUserId sets the "userId" field.
func (m *AgreementLogMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *AgreementLogMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *AgreementLogMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *AgreementLogMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserId clears the value of the "userId" field.
func (m *AgreementLogMutation) ClearUserId() {
	m.userId = nil
	m.adduserId = nil
	m.clearedFields[agreementlog.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *AgreementLogMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *AgreementLogMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
	delete(m.clearedFields, agreementlog.FieldUserId)
}

// SetChId sets the "chId" field.
func (m *AgreementLogMutation) SetChId(i int64) {
	m.chId = &i
	m.addchId = nil
}

// ChId returns the value of the "chId" field in the mutation.
func (m *AgreementLogMutation) ChId() (r int64, exists bool) {
	v := m.chId
	if v == nil {
		return
	}
	return *v, true
}

// OldChId returns the old "chId" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldChId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChId: %w", err)
	}
	return oldValue.ChId, nil
}

// AddChId adds i to the "chId" field.
func (m *AgreementLogMutation) AddChId(i int64) {
	if m.addchId != nil {
		*m.addchId += i
	} else {
		m.addchId = &i
	}
}

// AddedChId returns the value that was added to the "chId" field in this mutation.
func (m *AgreementLogMutation) AddedChId() (r int64, exists bool) {
	v := m.addchId
	if v == nil {
		return
	}
	return *v, true
}

// ClearChId clears the value of the "chId" field.
func (m *AgreementLogMutation) ClearChId() {
	m.chId = nil
	m.addchId = nil
	m.clearedFields[agreementlog.FieldChId] = struct{}{}
}

// ChIdCleared returns if the "chId" field was cleared in this mutation.
func (m *AgreementLogMutation) ChIdCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldChId]
	return ok
}

// ResetChId resets all changes to the "chId" field.
func (m *AgreementLogMutation) ResetChId() {
	m.chId = nil
	m.addchId = nil
	delete(m.clearedFields, agreementlog.FieldChId)
}

// SetUserName sets the "userName" field.
func (m *AgreementLogMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *AgreementLogMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *AgreementLogMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[agreementlog.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *AgreementLogMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *AgreementLogMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, agreementlog.FieldUserName)
}

// SetPaymentName sets the "paymentName" field.
func (m *AgreementLogMutation) SetPaymentName(s string) {
	m.paymentName = &s
}

// PaymentName returns the value of the "paymentName" field in the mutation.
func (m *AgreementLogMutation) PaymentName() (r string, exists bool) {
	v := m.paymentName
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentName returns the old "paymentName" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldPaymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentName: %w", err)
	}
	return oldValue.PaymentName, nil
}

// ClearPaymentName clears the value of the "paymentName" field.
func (m *AgreementLogMutation) ClearPaymentName() {
	m.paymentName = nil
	m.clearedFields[agreementlog.FieldPaymentName] = struct{}{}
}

// PaymentNameCleared returns if the "paymentName" field was cleared in this mutation.
func (m *AgreementLogMutation) PaymentNameCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldPaymentName]
	return ok
}

// ResetPaymentName resets all changes to the "paymentName" field.
func (m *AgreementLogMutation) ResetPaymentName() {
	m.paymentName = nil
	delete(m.clearedFields, agreementlog.FieldPaymentName)
}

// SetPaymentId sets the "paymentId" field.
func (m *AgreementLogMutation) SetPaymentId(i int64) {
	m.paymentId = &i
	m.addpaymentId = nil
}

// PaymentId returns the value of the "paymentId" field in the mutation.
func (m *AgreementLogMutation) PaymentId() (r int64, exists bool) {
	v := m.paymentId
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentId returns the old "paymentId" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldPaymentId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentId: %w", err)
	}
	return oldValue.PaymentId, nil
}

// AddPaymentId adds i to the "paymentId" field.
func (m *AgreementLogMutation) AddPaymentId(i int64) {
	if m.addpaymentId != nil {
		*m.addpaymentId += i
	} else {
		m.addpaymentId = &i
	}
}

// AddedPaymentId returns the value that was added to the "paymentId" field in this mutation.
func (m *AgreementLogMutation) AddedPaymentId() (r int64, exists bool) {
	v := m.addpaymentId
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentId clears the value of the "paymentId" field.
func (m *AgreementLogMutation) ClearPaymentId() {
	m.paymentId = nil
	m.addpaymentId = nil
	m.clearedFields[agreementlog.FieldPaymentId] = struct{}{}
}

// PaymentIdCleared returns if the "paymentId" field was cleared in this mutation.
func (m *AgreementLogMutation) PaymentIdCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldPaymentId]
	return ok
}

// ResetPaymentId resets all changes to the "paymentId" field.
func (m *AgreementLogMutation) ResetPaymentId() {
	m.paymentId = nil
	m.addpaymentId = nil
	delete(m.clearedFields, agreementlog.FieldPaymentId)
}

// SetState sets the "state" field.
func (m *AgreementLogMutation) SetState(i int32) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *AgreementLogMutation) State() (r int32, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldState(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *AgreementLogMutation) AddState(i int32) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *AgreementLogMutation) AddedState() (r int32, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ClearState clears the value of the "state" field.
func (m *AgreementLogMutation) ClearState() {
	m.state = nil
	m.addstate = nil
	m.clearedFields[agreementlog.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *AgreementLogMutation) StateCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *AgreementLogMutation) ResetState() {
	m.state = nil
	m.addstate = nil
	delete(m.clearedFields, agreementlog.FieldState)
}

// SetPayment sets the "payment" field.
func (m *AgreementLogMutation) SetPayment(i int64) {
	m.payment = &i
	m.addpayment = nil
}

// Payment returns the value of the "payment" field in the mutation.
func (m *AgreementLogMutation) Payment() (r int64, exists bool) {
	v := m.payment
	if v == nil {
		return
	}
	return *v, true
}

// OldPayment returns the old "payment" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayment: %w", err)
	}
	return oldValue.Payment, nil
}

// AddPayment adds i to the "payment" field.
func (m *AgreementLogMutation) AddPayment(i int64) {
	if m.addpayment != nil {
		*m.addpayment += i
	} else {
		m.addpayment = &i
	}
}

// AddedPayment returns the value that was added to the "payment" field in this mutation.
func (m *AgreementLogMutation) AddedPayment() (r int64, exists bool) {
	v := m.addpayment
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayment clears the value of the "payment" field.
func (m *AgreementLogMutation) ClearPayment() {
	m.payment = nil
	m.addpayment = nil
	m.clearedFields[agreementlog.FieldPayment] = struct{}{}
}

// PaymentCleared returns if the "payment" field was cleared in this mutation.
func (m *AgreementLogMutation) PaymentCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldPayment]
	return ok
}

// ResetPayment resets all changes to the "payment" field.
func (m *AgreementLogMutation) ResetPayment() {
	m.payment = nil
	m.addpayment = nil
	delete(m.clearedFields, agreementlog.FieldPayment)
}

// SetAgreementType sets the "agreementType" field.
func (m *AgreementLogMutation) SetAgreementType(at agreementlog.AgreementType) {
	m.agreementType = &at
}

// AgreementType returns the value of the "agreementType" field in the mutation.
func (m *AgreementLogMutation) AgreementType() (r agreementlog.AgreementType, exists bool) {
	v := m.agreementType
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementType returns the old "agreementType" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldAgreementType(ctx context.Context) (v agreementlog.AgreementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementType: %w", err)
	}
	return oldValue.AgreementType, nil
}

// ClearAgreementType clears the value of the "agreementType" field.
func (m *AgreementLogMutation) ClearAgreementType() {
	m.agreementType = nil
	m.clearedFields[agreementlog.FieldAgreementType] = struct{}{}
}

// AgreementTypeCleared returns if the "agreementType" field was cleared in this mutation.
func (m *AgreementLogMutation) AgreementTypeCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldAgreementType]
	return ok
}

// ResetAgreementType resets all changes to the "agreementType" field.
func (m *AgreementLogMutation) ResetAgreementType() {
	m.agreementType = nil
	delete(m.clearedFields, agreementlog.FieldAgreementType)
}

// SetVipType sets the "vipType" field.
func (m *AgreementLogMutation) SetVipType(i int64) {
	m.vipType = &i
	m.addvipType = nil
}

// VipType returns the value of the "vipType" field in the mutation.
func (m *AgreementLogMutation) VipType() (r int64, exists bool) {
	v := m.vipType
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vipType" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldVipType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vipType" field.
func (m *AgreementLogMutation) AddVipType(i int64) {
	if m.addvipType != nil {
		*m.addvipType += i
	} else {
		m.addvipType = &i
	}
}

// AddedVipType returns the value that was added to the "vipType" field in this mutation.
func (m *AgreementLogMutation) AddedVipType() (r int64, exists bool) {
	v := m.addvipType
	if v == nil {
		return
	}
	return *v, true
}

// ClearVipType clears the value of the "vipType" field.
func (m *AgreementLogMutation) ClearVipType() {
	m.vipType = nil
	m.addvipType = nil
	m.clearedFields[agreementlog.FieldVipType] = struct{}{}
}

// VipTypeCleared returns if the "vipType" field was cleared in this mutation.
func (m *AgreementLogMutation) VipTypeCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldVipType]
	return ok
}

// ResetVipType resets all changes to the "vipType" field.
func (m *AgreementLogMutation) ResetVipType() {
	m.vipType = nil
	m.addvipType = nil
	delete(m.clearedFields, agreementlog.FieldVipType)
}

// SetTimes sets the "times" field.
func (m *AgreementLogMutation) SetTimes(i int64) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the value of the "times" field in the mutation.
func (m *AgreementLogMutation) Times() (r int64, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old "times" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to the "times" field.
func (m *AgreementLogMutation) AddTimes(i int64) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the "times" field in this mutation.
func (m *AgreementLogMutation) AddedTimes() (r int64, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimes clears the value of the "times" field.
func (m *AgreementLogMutation) ClearTimes() {
	m.times = nil
	m.addtimes = nil
	m.clearedFields[agreementlog.FieldTimes] = struct{}{}
}

// TimesCleared returns if the "times" field was cleared in this mutation.
func (m *AgreementLogMutation) TimesCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldTimes]
	return ok
}

// ResetTimes resets all changes to the "times" field.
func (m *AgreementLogMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
	delete(m.clearedFields, agreementlog.FieldTimes)
}

// SetCycleDays sets the "cycleDays" field.
func (m *AgreementLogMutation) SetCycleDays(i int32) {
	m.cycleDays = &i
	m.addcycleDays = nil
}

// CycleDays returns the value of the "cycleDays" field in the mutation.
func (m *AgreementLogMutation) CycleDays() (r int32, exists bool) {
	v := m.cycleDays
	if v == nil {
		return
	}
	return *v, true
}

// OldCycleDays returns the old "cycleDays" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldCycleDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycleDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycleDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycleDays: %w", err)
	}
	return oldValue.CycleDays, nil
}

// AddCycleDays adds i to the "cycleDays" field.
func (m *AgreementLogMutation) AddCycleDays(i int32) {
	if m.addcycleDays != nil {
		*m.addcycleDays += i
	} else {
		m.addcycleDays = &i
	}
}

// AddedCycleDays returns the value that was added to the "cycleDays" field in this mutation.
func (m *AgreementLogMutation) AddedCycleDays() (r int32, exists bool) {
	v := m.addcycleDays
	if v == nil {
		return
	}
	return *v, true
}

// ClearCycleDays clears the value of the "cycleDays" field.
func (m *AgreementLogMutation) ClearCycleDays() {
	m.cycleDays = nil
	m.addcycleDays = nil
	m.clearedFields[agreementlog.FieldCycleDays] = struct{}{}
}

// CycleDaysCleared returns if the "cycleDays" field was cleared in this mutation.
func (m *AgreementLogMutation) CycleDaysCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldCycleDays]
	return ok
}

// ResetCycleDays resets all changes to the "cycleDays" field.
func (m *AgreementLogMutation) ResetCycleDays() {
	m.cycleDays = nil
	m.addcycleDays = nil
	delete(m.clearedFields, agreementlog.FieldCycleDays)
}

// SetNextExecTime sets the "nextExecTime" field.
func (m *AgreementLogMutation) SetNextExecTime(t time.Time) {
	m.nextExecTime = &t
}

// NextExecTime returns the value of the "nextExecTime" field in the mutation.
func (m *AgreementLogMutation) NextExecTime() (r time.Time, exists bool) {
	v := m.nextExecTime
	if v == nil {
		return
	}
	return *v, true
}

// OldNextExecTime returns the old "nextExecTime" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldNextExecTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextExecTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextExecTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextExecTime: %w", err)
	}
	return oldValue.NextExecTime, nil
}

// ClearNextExecTime clears the value of the "nextExecTime" field.
func (m *AgreementLogMutation) ClearNextExecTime() {
	m.nextExecTime = nil
	m.clearedFields[agreementlog.FieldNextExecTime] = struct{}{}
}

// NextExecTimeCleared returns if the "nextExecTime" field was cleared in this mutation.
func (m *AgreementLogMutation) NextExecTimeCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldNextExecTime]
	return ok
}

// ResetNextExecTime resets all changes to the "nextExecTime" field.
func (m *AgreementLogMutation) ResetNextExecTime() {
	m.nextExecTime = nil
	delete(m.clearedFields, agreementlog.FieldNextExecTime)
}

// SetRemark sets the "remark" field.
func (m *AgreementLogMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AgreementLogMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AgreementLogMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[agreementlog.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AgreementLogMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[agreementlog.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AgreementLogMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, agreementlog.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *AgreementLogMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AgreementLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AgreementLogMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AgreementLogMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AgreementLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AgreementLogMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AgreementLogMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AgreementLogMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AgreementLogMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AgreementLogMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AgreementLogMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AgreementLogMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AgreementLogMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AgreementLogMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AgreementLogMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AgreementLogMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AgreementLogMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AgreementLogMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AgreementLog entity.
// If the AgreementLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgreementLogMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AgreementLogMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AgreementLogMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AgreementLogMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// AddOrderIDs adds the "orders" edge to the PayOrder entity by ids.
func (m *AgreementLogMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the PayOrder entity.
func (m *AgreementLogMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the PayOrder entity was cleared.
func (m *AgreementLogMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the PayOrder entity by IDs.
func (m *AgreementLogMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the PayOrder entity.
func (m *AgreementLogMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AgreementLogMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AgreementLogMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the AgreementLogMutation builder.
func (m *AgreementLogMutation) Where(ps ...predicate.AgreementLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgreementLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AgreementLog).
func (m *AgreementLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgreementLogMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.outerAgreementNo != nil {
		fields = append(fields, agreementlog.FieldOuterAgreementNo)
	}
	if m.orderId != nil {
		fields = append(fields, agreementlog.FieldOrderId)
	}
	if m.userId != nil {
		fields = append(fields, agreementlog.FieldUserId)
	}
	if m.chId != nil {
		fields = append(fields, agreementlog.FieldChId)
	}
	if m.userName != nil {
		fields = append(fields, agreementlog.FieldUserName)
	}
	if m.paymentName != nil {
		fields = append(fields, agreementlog.FieldPaymentName)
	}
	if m.paymentId != nil {
		fields = append(fields, agreementlog.FieldPaymentId)
	}
	if m.state != nil {
		fields = append(fields, agreementlog.FieldState)
	}
	if m.payment != nil {
		fields = append(fields, agreementlog.FieldPayment)
	}
	if m.agreementType != nil {
		fields = append(fields, agreementlog.FieldAgreementType)
	}
	if m.vipType != nil {
		fields = append(fields, agreementlog.FieldVipType)
	}
	if m.times != nil {
		fields = append(fields, agreementlog.FieldTimes)
	}
	if m.cycleDays != nil {
		fields = append(fields, agreementlog.FieldCycleDays)
	}
	if m.nextExecTime != nil {
		fields = append(fields, agreementlog.FieldNextExecTime)
	}
	if m.remark != nil {
		fields = append(fields, agreementlog.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, agreementlog.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, agreementlog.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, agreementlog.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, agreementlog.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, agreementlog.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgreementLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agreementlog.FieldOuterAgreementNo:
		return m.OuterAgreementNo()
	case agreementlog.FieldOrderId:
		return m.OrderId()
	case agreementlog.FieldUserId:
		return m.UserId()
	case agreementlog.FieldChId:
		return m.ChId()
	case agreementlog.FieldUserName:
		return m.UserName()
	case agreementlog.FieldPaymentName:
		return m.PaymentName()
	case agreementlog.FieldPaymentId:
		return m.PaymentId()
	case agreementlog.FieldState:
		return m.State()
	case agreementlog.FieldPayment:
		return m.Payment()
	case agreementlog.FieldAgreementType:
		return m.AgreementType()
	case agreementlog.FieldVipType:
		return m.VipType()
	case agreementlog.FieldTimes:
		return m.Times()
	case agreementlog.FieldCycleDays:
		return m.CycleDays()
	case agreementlog.FieldNextExecTime:
		return m.NextExecTime()
	case agreementlog.FieldRemark:
		return m.Remark()
	case agreementlog.FieldCreatedAt:
		return m.CreatedAt()
	case agreementlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case agreementlog.FieldCreateBy:
		return m.CreateBy()
	case agreementlog.FieldUpdateBy:
		return m.UpdateBy()
	case agreementlog.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgreementLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agreementlog.FieldOuterAgreementNo:
		return m.OldOuterAgreementNo(ctx)
	case agreementlog.FieldOrderId:
		return m.OldOrderId(ctx)
	case agreementlog.FieldUserId:
		return m.OldUserId(ctx)
	case agreementlog.FieldChId:
		return m.OldChId(ctx)
	case agreementlog.FieldUserName:
		return m.OldUserName(ctx)
	case agreementlog.FieldPaymentName:
		return m.OldPaymentName(ctx)
	case agreementlog.FieldPaymentId:
		return m.OldPaymentId(ctx)
	case agreementlog.FieldState:
		return m.OldState(ctx)
	case agreementlog.FieldPayment:
		return m.OldPayment(ctx)
	case agreementlog.FieldAgreementType:
		return m.OldAgreementType(ctx)
	case agreementlog.FieldVipType:
		return m.OldVipType(ctx)
	case agreementlog.FieldTimes:
		return m.OldTimes(ctx)
	case agreementlog.FieldCycleDays:
		return m.OldCycleDays(ctx)
	case agreementlog.FieldNextExecTime:
		return m.OldNextExecTime(ctx)
	case agreementlog.FieldRemark:
		return m.OldRemark(ctx)
	case agreementlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agreementlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agreementlog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case agreementlog.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case agreementlog.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AgreementLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgreementLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agreementlog.FieldOuterAgreementNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOuterAgreementNo(v)
		return nil
	case agreementlog.FieldOrderId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderId(v)
		return nil
	case agreementlog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case agreementlog.FieldChId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChId(v)
		return nil
	case agreementlog.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case agreementlog.FieldPaymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentName(v)
		return nil
	case agreementlog.FieldPaymentId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentId(v)
		return nil
	case agreementlog.FieldState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case agreementlog.FieldPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayment(v)
		return nil
	case agreementlog.FieldAgreementType:
		v, ok := value.(agreementlog.AgreementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementType(v)
		return nil
	case agreementlog.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case agreementlog.FieldTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case agreementlog.FieldCycleDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycleDays(v)
		return nil
	case agreementlog.FieldNextExecTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextExecTime(v)
		return nil
	case agreementlog.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case agreementlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agreementlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agreementlog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case agreementlog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case agreementlog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AgreementLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgreementLogMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, agreementlog.FieldUserId)
	}
	if m.addchId != nil {
		fields = append(fields, agreementlog.FieldChId)
	}
	if m.addpaymentId != nil {
		fields = append(fields, agreementlog.FieldPaymentId)
	}
	if m.addstate != nil {
		fields = append(fields, agreementlog.FieldState)
	}
	if m.addpayment != nil {
		fields = append(fields, agreementlog.FieldPayment)
	}
	if m.addvipType != nil {
		fields = append(fields, agreementlog.FieldVipType)
	}
	if m.addtimes != nil {
		fields = append(fields, agreementlog.FieldTimes)
	}
	if m.addcycleDays != nil {
		fields = append(fields, agreementlog.FieldCycleDays)
	}
	if m.addcreateBy != nil {
		fields = append(fields, agreementlog.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, agreementlog.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, agreementlog.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgreementLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agreementlog.FieldUserId:
		return m.AddedUserId()
	case agreementlog.FieldChId:
		return m.AddedChId()
	case agreementlog.FieldPaymentId:
		return m.AddedPaymentId()
	case agreementlog.FieldState:
		return m.AddedState()
	case agreementlog.FieldPayment:
		return m.AddedPayment()
	case agreementlog.FieldVipType:
		return m.AddedVipType()
	case agreementlog.FieldTimes:
		return m.AddedTimes()
	case agreementlog.FieldCycleDays:
		return m.AddedCycleDays()
	case agreementlog.FieldCreateBy:
		return m.AddedCreateBy()
	case agreementlog.FieldUpdateBy:
		return m.AddedUpdateBy()
	case agreementlog.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgreementLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agreementlog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case agreementlog.FieldChId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChId(v)
		return nil
	case agreementlog.FieldPaymentId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentId(v)
		return nil
	case agreementlog.FieldState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case agreementlog.FieldPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayment(v)
		return nil
	case agreementlog.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	case agreementlog.FieldTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case agreementlog.FieldCycleDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCycleDays(v)
		return nil
	case agreementlog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case agreementlog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case agreementlog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AgreementLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgreementLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agreementlog.FieldOuterAgreementNo) {
		fields = append(fields, agreementlog.FieldOuterAgreementNo)
	}
	if m.FieldCleared(agreementlog.FieldOrderId) {
		fields = append(fields, agreementlog.FieldOrderId)
	}
	if m.FieldCleared(agreementlog.FieldUserId) {
		fields = append(fields, agreementlog.FieldUserId)
	}
	if m.FieldCleared(agreementlog.FieldChId) {
		fields = append(fields, agreementlog.FieldChId)
	}
	if m.FieldCleared(agreementlog.FieldUserName) {
		fields = append(fields, agreementlog.FieldUserName)
	}
	if m.FieldCleared(agreementlog.FieldPaymentName) {
		fields = append(fields, agreementlog.FieldPaymentName)
	}
	if m.FieldCleared(agreementlog.FieldPaymentId) {
		fields = append(fields, agreementlog.FieldPaymentId)
	}
	if m.FieldCleared(agreementlog.FieldState) {
		fields = append(fields, agreementlog.FieldState)
	}
	if m.FieldCleared(agreementlog.FieldPayment) {
		fields = append(fields, agreementlog.FieldPayment)
	}
	if m.FieldCleared(agreementlog.FieldAgreementType) {
		fields = append(fields, agreementlog.FieldAgreementType)
	}
	if m.FieldCleared(agreementlog.FieldVipType) {
		fields = append(fields, agreementlog.FieldVipType)
	}
	if m.FieldCleared(agreementlog.FieldTimes) {
		fields = append(fields, agreementlog.FieldTimes)
	}
	if m.FieldCleared(agreementlog.FieldCycleDays) {
		fields = append(fields, agreementlog.FieldCycleDays)
	}
	if m.FieldCleared(agreementlog.FieldNextExecTime) {
		fields = append(fields, agreementlog.FieldNextExecTime)
	}
	if m.FieldCleared(agreementlog.FieldRemark) {
		fields = append(fields, agreementlog.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgreementLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgreementLogMutation) ClearField(name string) error {
	switch name {
	case agreementlog.FieldOuterAgreementNo:
		m.ClearOuterAgreementNo()
		return nil
	case agreementlog.FieldOrderId:
		m.ClearOrderId()
		return nil
	case agreementlog.FieldUserId:
		m.ClearUserId()
		return nil
	case agreementlog.FieldChId:
		m.ClearChId()
		return nil
	case agreementlog.FieldUserName:
		m.ClearUserName()
		return nil
	case agreementlog.FieldPaymentName:
		m.ClearPaymentName()
		return nil
	case agreementlog.FieldPaymentId:
		m.ClearPaymentId()
		return nil
	case agreementlog.FieldState:
		m.ClearState()
		return nil
	case agreementlog.FieldPayment:
		m.ClearPayment()
		return nil
	case agreementlog.FieldAgreementType:
		m.ClearAgreementType()
		return nil
	case agreementlog.FieldVipType:
		m.ClearVipType()
		return nil
	case agreementlog.FieldTimes:
		m.ClearTimes()
		return nil
	case agreementlog.FieldCycleDays:
		m.ClearCycleDays()
		return nil
	case agreementlog.FieldNextExecTime:
		m.ClearNextExecTime()
		return nil
	case agreementlog.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown AgreementLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgreementLogMutation) ResetField(name string) error {
	switch name {
	case agreementlog.FieldOuterAgreementNo:
		m.ResetOuterAgreementNo()
		return nil
	case agreementlog.FieldOrderId:
		m.ResetOrderId()
		return nil
	case agreementlog.FieldUserId:
		m.ResetUserId()
		return nil
	case agreementlog.FieldChId:
		m.ResetChId()
		return nil
	case agreementlog.FieldUserName:
		m.ResetUserName()
		return nil
	case agreementlog.FieldPaymentName:
		m.ResetPaymentName()
		return nil
	case agreementlog.FieldPaymentId:
		m.ResetPaymentId()
		return nil
	case agreementlog.FieldState:
		m.ResetState()
		return nil
	case agreementlog.FieldPayment:
		m.ResetPayment()
		return nil
	case agreementlog.FieldAgreementType:
		m.ResetAgreementType()
		return nil
	case agreementlog.FieldVipType:
		m.ResetVipType()
		return nil
	case agreementlog.FieldTimes:
		m.ResetTimes()
		return nil
	case agreementlog.FieldCycleDays:
		m.ResetCycleDays()
		return nil
	case agreementlog.FieldNextExecTime:
		m.ResetNextExecTime()
		return nil
	case agreementlog.FieldRemark:
		m.ResetRemark()
		return nil
	case agreementlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agreementlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agreementlog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case agreementlog.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case agreementlog.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AgreementLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgreementLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, agreementlog.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgreementLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agreementlog.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgreementLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorders != nil {
		edges = append(edges, agreementlog.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgreementLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agreementlog.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgreementLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorders {
		edges = append(edges, agreementlog.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgreementLogMutation) EdgeCleared(name string) bool {
	switch name {
	case agreementlog.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgreementLogMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AgreementLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgreementLogMutation) ResetEdge(name string) error {
	switch name {
	case agreementlog.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown AgreementLog edge %s", name)
}

// AmBalanceMutation represents an operation that mutates the AmBalance nodes in the graph.
type AmBalanceMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	orderId        *string
	eventId        *int64
	addeventId     *int64
	cashTag        *int32
	addcashTag     *int32
	assetItemId    *int32
	addassetItemId *int32
	amount         *int64
	addamount      *int64
	balance        *int64
	addbalance     *int64
	remark         *string
	effectTime     *time.Time
	expiredTime    *time.Time
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*AmBalance, error)
	predicates     []predicate.AmBalance
}

var _ ent.Mutation = (*AmBalanceMutation)(nil)

// ambalanceOption allows management of the mutation configuration using functional options.
type ambalanceOption func(*AmBalanceMutation)

// newAmBalanceMutation creates new mutation for the AmBalance entity.
func newAmBalanceMutation(c config, op Op, opts ...ambalanceOption) *AmBalanceMutation {
	m := &AmBalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAmBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmBalanceID sets the ID field of the mutation.
func withAmBalanceID(id int64) ambalanceOption {
	return func(m *AmBalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *AmBalance
		)
		m.oldValue = func(ctx context.Context) (*AmBalance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AmBalance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmBalance sets the old AmBalance of the mutation.
func withAmBalance(node *AmBalance) ambalanceOption {
	return func(m *AmBalanceMutation) {
		m.oldValue = func(context.Context) (*AmBalance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmBalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmBalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmBalanceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmBalanceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AmBalance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *AmBalanceMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *AmBalanceMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *AmBalanceMutation) ResetUserId() {
	m.user = nil
}

// SetOrderId sets the "orderId" field.
func (m *AmBalanceMutation) SetOrderId(s string) {
	m.orderId = &s
}

// OrderId returns the value of the "orderId" field in the mutation.
func (m *AmBalanceMutation) OrderId() (r string, exists bool) {
	v := m.orderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderId returns the old "orderId" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldOrderId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderId: %w", err)
	}
	return oldValue.OrderId, nil
}

// ClearOrderId clears the value of the "orderId" field.
func (m *AmBalanceMutation) ClearOrderId() {
	m.orderId = nil
	m.clearedFields[ambalance.FieldOrderId] = struct{}{}
}

// OrderIdCleared returns if the "orderId" field was cleared in this mutation.
func (m *AmBalanceMutation) OrderIdCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldOrderId]
	return ok
}

// ResetOrderId resets all changes to the "orderId" field.
func (m *AmBalanceMutation) ResetOrderId() {
	m.orderId = nil
	delete(m.clearedFields, ambalance.FieldOrderId)
}

// SetEventId sets the "eventId" field.
func (m *AmBalanceMutation) SetEventId(i int64) {
	m.eventId = &i
	m.addeventId = nil
}

// EventId returns the value of the "eventId" field in the mutation.
func (m *AmBalanceMutation) EventId() (r int64, exists bool) {
	v := m.eventId
	if v == nil {
		return
	}
	return *v, true
}

// OldEventId returns the old "eventId" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldEventId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventId: %w", err)
	}
	return oldValue.EventId, nil
}

// AddEventId adds i to the "eventId" field.
func (m *AmBalanceMutation) AddEventId(i int64) {
	if m.addeventId != nil {
		*m.addeventId += i
	} else {
		m.addeventId = &i
	}
}

// AddedEventId returns the value that was added to the "eventId" field in this mutation.
func (m *AmBalanceMutation) AddedEventId() (r int64, exists bool) {
	v := m.addeventId
	if v == nil {
		return
	}
	return *v, true
}

// ClearEventId clears the value of the "eventId" field.
func (m *AmBalanceMutation) ClearEventId() {
	m.eventId = nil
	m.addeventId = nil
	m.clearedFields[ambalance.FieldEventId] = struct{}{}
}

// EventIdCleared returns if the "eventId" field was cleared in this mutation.
func (m *AmBalanceMutation) EventIdCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldEventId]
	return ok
}

// ResetEventId resets all changes to the "eventId" field.
func (m *AmBalanceMutation) ResetEventId() {
	m.eventId = nil
	m.addeventId = nil
	delete(m.clearedFields, ambalance.FieldEventId)
}

// SetCashTag sets the "cashTag" field.
func (m *AmBalanceMutation) SetCashTag(i int32) {
	m.cashTag = &i
	m.addcashTag = nil
}

// CashTag returns the value of the "cashTag" field in the mutation.
func (m *AmBalanceMutation) CashTag() (r int32, exists bool) {
	v := m.cashTag
	if v == nil {
		return
	}
	return *v, true
}

// OldCashTag returns the old "cashTag" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldCashTag(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashTag: %w", err)
	}
	return oldValue.CashTag, nil
}

// AddCashTag adds i to the "cashTag" field.
func (m *AmBalanceMutation) AddCashTag(i int32) {
	if m.addcashTag != nil {
		*m.addcashTag += i
	} else {
		m.addcashTag = &i
	}
}

// AddedCashTag returns the value that was added to the "cashTag" field in this mutation.
func (m *AmBalanceMutation) AddedCashTag() (r int32, exists bool) {
	v := m.addcashTag
	if v == nil {
		return
	}
	return *v, true
}

// ClearCashTag clears the value of the "cashTag" field.
func (m *AmBalanceMutation) ClearCashTag() {
	m.cashTag = nil
	m.addcashTag = nil
	m.clearedFields[ambalance.FieldCashTag] = struct{}{}
}

// CashTagCleared returns if the "cashTag" field was cleared in this mutation.
func (m *AmBalanceMutation) CashTagCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldCashTag]
	return ok
}

// ResetCashTag resets all changes to the "cashTag" field.
func (m *AmBalanceMutation) ResetCashTag() {
	m.cashTag = nil
	m.addcashTag = nil
	delete(m.clearedFields, ambalance.FieldCashTag)
}

// SetAssetItemId sets the "assetItemId" field.
func (m *AmBalanceMutation) SetAssetItemId(i int32) {
	m.assetItemId = &i
	m.addassetItemId = nil
}

// AssetItemId returns the value of the "assetItemId" field in the mutation.
func (m *AmBalanceMutation) AssetItemId() (r int32, exists bool) {
	v := m.assetItemId
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetItemId returns the old "assetItemId" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldAssetItemId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetItemId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetItemId: %w", err)
	}
	return oldValue.AssetItemId, nil
}

// AddAssetItemId adds i to the "assetItemId" field.
func (m *AmBalanceMutation) AddAssetItemId(i int32) {
	if m.addassetItemId != nil {
		*m.addassetItemId += i
	} else {
		m.addassetItemId = &i
	}
}

// AddedAssetItemId returns the value that was added to the "assetItemId" field in this mutation.
func (m *AmBalanceMutation) AddedAssetItemId() (r int32, exists bool) {
	v := m.addassetItemId
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssetItemId clears the value of the "assetItemId" field.
func (m *AmBalanceMutation) ClearAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
	m.clearedFields[ambalance.FieldAssetItemId] = struct{}{}
}

// AssetItemIdCleared returns if the "assetItemId" field was cleared in this mutation.
func (m *AmBalanceMutation) AssetItemIdCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldAssetItemId]
	return ok
}

// ResetAssetItemId resets all changes to the "assetItemId" field.
func (m *AmBalanceMutation) ResetAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
	delete(m.clearedFields, ambalance.FieldAssetItemId)
}

// SetAmount sets the "amount" field.
func (m *AmBalanceMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AmBalanceMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *AmBalanceMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AmBalanceMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *AmBalanceMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[ambalance.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *AmBalanceMutation) AmountCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *AmBalanceMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, ambalance.FieldAmount)
}

// SetBalance sets the "balance" field.
func (m *AmBalanceMutation) SetBalance(i int64) {
	m.balance = &i
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AmBalanceMutation) Balance() (r int64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds i to the "balance" field.
func (m *AmBalanceMutation) AddBalance(i int64) {
	if m.addbalance != nil {
		*m.addbalance += i
	} else {
		m.addbalance = &i
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AmBalanceMutation) AddedBalance() (r int64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "balance" field.
func (m *AmBalanceMutation) ClearBalance() {
	m.balance = nil
	m.addbalance = nil
	m.clearedFields[ambalance.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "balance" field was cleared in this mutation.
func (m *AmBalanceMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "balance" field.
func (m *AmBalanceMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
	delete(m.clearedFields, ambalance.FieldBalance)
}

// SetRemark sets the "remark" field.
func (m *AmBalanceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AmBalanceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AmBalanceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[ambalance.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AmBalanceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[ambalance.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AmBalanceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, ambalance.FieldRemark)
}

// SetEffectTime sets the "effectTime" field.
func (m *AmBalanceMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *AmBalanceMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *AmBalanceMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *AmBalanceMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *AmBalanceMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *AmBalanceMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *AmBalanceMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AmBalanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AmBalanceMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AmBalanceMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AmBalanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AmBalanceMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AmBalanceMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AmBalanceMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AmBalanceMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AmBalanceMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AmBalanceMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AmBalanceMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AmBalanceMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AmBalanceMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AmBalanceMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AmBalanceMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AmBalanceMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AmBalanceMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AmBalance entity.
// If the AmBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmBalanceMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AmBalanceMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AmBalanceMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AmBalanceMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *AmBalanceMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *AmBalanceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *AmBalanceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AmBalanceMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AmBalanceMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AmBalanceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AmBalanceMutation builder.
func (m *AmBalanceMutation) Where(ps ...predicate.AmBalance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AmBalanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AmBalance).
func (m *AmBalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmBalanceMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.user != nil {
		fields = append(fields, ambalance.FieldUserId)
	}
	if m.orderId != nil {
		fields = append(fields, ambalance.FieldOrderId)
	}
	if m.eventId != nil {
		fields = append(fields, ambalance.FieldEventId)
	}
	if m.cashTag != nil {
		fields = append(fields, ambalance.FieldCashTag)
	}
	if m.assetItemId != nil {
		fields = append(fields, ambalance.FieldAssetItemId)
	}
	if m.amount != nil {
		fields = append(fields, ambalance.FieldAmount)
	}
	if m.balance != nil {
		fields = append(fields, ambalance.FieldBalance)
	}
	if m.remark != nil {
		fields = append(fields, ambalance.FieldRemark)
	}
	if m.effectTime != nil {
		fields = append(fields, ambalance.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, ambalance.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, ambalance.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, ambalance.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, ambalance.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, ambalance.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, ambalance.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmBalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ambalance.FieldUserId:
		return m.UserId()
	case ambalance.FieldOrderId:
		return m.OrderId()
	case ambalance.FieldEventId:
		return m.EventId()
	case ambalance.FieldCashTag:
		return m.CashTag()
	case ambalance.FieldAssetItemId:
		return m.AssetItemId()
	case ambalance.FieldAmount:
		return m.Amount()
	case ambalance.FieldBalance:
		return m.Balance()
	case ambalance.FieldRemark:
		return m.Remark()
	case ambalance.FieldEffectTime:
		return m.EffectTime()
	case ambalance.FieldExpiredTime:
		return m.ExpiredTime()
	case ambalance.FieldCreatedAt:
		return m.CreatedAt()
	case ambalance.FieldUpdatedAt:
		return m.UpdatedAt()
	case ambalance.FieldCreateBy:
		return m.CreateBy()
	case ambalance.FieldUpdateBy:
		return m.UpdateBy()
	case ambalance.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmBalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ambalance.FieldUserId:
		return m.OldUserId(ctx)
	case ambalance.FieldOrderId:
		return m.OldOrderId(ctx)
	case ambalance.FieldEventId:
		return m.OldEventId(ctx)
	case ambalance.FieldCashTag:
		return m.OldCashTag(ctx)
	case ambalance.FieldAssetItemId:
		return m.OldAssetItemId(ctx)
	case ambalance.FieldAmount:
		return m.OldAmount(ctx)
	case ambalance.FieldBalance:
		return m.OldBalance(ctx)
	case ambalance.FieldRemark:
		return m.OldRemark(ctx)
	case ambalance.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case ambalance.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case ambalance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ambalance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ambalance.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case ambalance.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case ambalance.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AmBalance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmBalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ambalance.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case ambalance.FieldOrderId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderId(v)
		return nil
	case ambalance.FieldEventId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventId(v)
		return nil
	case ambalance.FieldCashTag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashTag(v)
		return nil
	case ambalance.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetItemId(v)
		return nil
	case ambalance.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case ambalance.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case ambalance.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case ambalance.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case ambalance.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case ambalance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ambalance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ambalance.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case ambalance.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case ambalance.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AmBalance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmBalanceMutation) AddedFields() []string {
	var fields []string
	if m.addeventId != nil {
		fields = append(fields, ambalance.FieldEventId)
	}
	if m.addcashTag != nil {
		fields = append(fields, ambalance.FieldCashTag)
	}
	if m.addassetItemId != nil {
		fields = append(fields, ambalance.FieldAssetItemId)
	}
	if m.addamount != nil {
		fields = append(fields, ambalance.FieldAmount)
	}
	if m.addbalance != nil {
		fields = append(fields, ambalance.FieldBalance)
	}
	if m.addcreateBy != nil {
		fields = append(fields, ambalance.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, ambalance.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, ambalance.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmBalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ambalance.FieldEventId:
		return m.AddedEventId()
	case ambalance.FieldCashTag:
		return m.AddedCashTag()
	case ambalance.FieldAssetItemId:
		return m.AddedAssetItemId()
	case ambalance.FieldAmount:
		return m.AddedAmount()
	case ambalance.FieldBalance:
		return m.AddedBalance()
	case ambalance.FieldCreateBy:
		return m.AddedCreateBy()
	case ambalance.FieldUpdateBy:
		return m.AddedUpdateBy()
	case ambalance.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmBalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ambalance.FieldEventId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventId(v)
		return nil
	case ambalance.FieldCashTag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCashTag(v)
		return nil
	case ambalance.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetItemId(v)
		return nil
	case ambalance.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case ambalance.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case ambalance.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case ambalance.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case ambalance.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AmBalance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmBalanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ambalance.FieldOrderId) {
		fields = append(fields, ambalance.FieldOrderId)
	}
	if m.FieldCleared(ambalance.FieldEventId) {
		fields = append(fields, ambalance.FieldEventId)
	}
	if m.FieldCleared(ambalance.FieldCashTag) {
		fields = append(fields, ambalance.FieldCashTag)
	}
	if m.FieldCleared(ambalance.FieldAssetItemId) {
		fields = append(fields, ambalance.FieldAssetItemId)
	}
	if m.FieldCleared(ambalance.FieldAmount) {
		fields = append(fields, ambalance.FieldAmount)
	}
	if m.FieldCleared(ambalance.FieldBalance) {
		fields = append(fields, ambalance.FieldBalance)
	}
	if m.FieldCleared(ambalance.FieldRemark) {
		fields = append(fields, ambalance.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmBalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmBalanceMutation) ClearField(name string) error {
	switch name {
	case ambalance.FieldOrderId:
		m.ClearOrderId()
		return nil
	case ambalance.FieldEventId:
		m.ClearEventId()
		return nil
	case ambalance.FieldCashTag:
		m.ClearCashTag()
		return nil
	case ambalance.FieldAssetItemId:
		m.ClearAssetItemId()
		return nil
	case ambalance.FieldAmount:
		m.ClearAmount()
		return nil
	case ambalance.FieldBalance:
		m.ClearBalance()
		return nil
	case ambalance.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown AmBalance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmBalanceMutation) ResetField(name string) error {
	switch name {
	case ambalance.FieldUserId:
		m.ResetUserId()
		return nil
	case ambalance.FieldOrderId:
		m.ResetOrderId()
		return nil
	case ambalance.FieldEventId:
		m.ResetEventId()
		return nil
	case ambalance.FieldCashTag:
		m.ResetCashTag()
		return nil
	case ambalance.FieldAssetItemId:
		m.ResetAssetItemId()
		return nil
	case ambalance.FieldAmount:
		m.ResetAmount()
		return nil
	case ambalance.FieldBalance:
		m.ResetBalance()
		return nil
	case ambalance.FieldRemark:
		m.ResetRemark()
		return nil
	case ambalance.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case ambalance.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case ambalance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ambalance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ambalance.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case ambalance.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case ambalance.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AmBalance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmBalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, ambalance.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmBalanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ambalance.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmBalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmBalanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmBalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, ambalance.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmBalanceMutation) EdgeCleared(name string) bool {
	switch name {
	case ambalance.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmBalanceMutation) ClearEdge(name string) error {
	switch name {
	case ambalance.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AmBalance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmBalanceMutation) ResetEdge(name string) error {
	switch name {
	case ambalance.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AmBalance edge %s", name)
}

// AppVersionMutation represents an operation that mutates the AppVersion nodes in the graph.
type AppVersionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	title         *string
	version       *int32
	addversion    *int32
	updateInfo    *string
	downloadUrl   *string
	platform      *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppVersion, error)
	predicates    []predicate.AppVersion
}

var _ ent.Mutation = (*AppVersionMutation)(nil)

// appversionOption allows management of the mutation configuration using functional options.
type appversionOption func(*AppVersionMutation)

// newAppVersionMutation creates new mutation for the AppVersion entity.
func newAppVersionMutation(c config, op Op, opts ...appversionOption) *AppVersionMutation {
	m := &AppVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppVersionID sets the ID field of the mutation.
func withAppVersionID(id int64) appversionOption {
	return func(m *AppVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppVersion
		)
		m.oldValue = func(ctx context.Context) (*AppVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppVersion sets the old AppVersion of the mutation.
func withAppVersion(node *AppVersion) appversionOption {
	return func(m *AppVersionMutation) {
		m.oldValue = func(context.Context) (*AppVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppVersionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppVersionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *AppVersionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AppVersionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *AppVersionMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[appversion.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *AppVersionMutation) TitleCleared() bool {
	_, ok := m.clearedFields[appversion.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *AppVersionMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, appversion.FieldTitle)
}

// SetVersion sets the "version" field.
func (m *AppVersionMutation) SetVersion(i int32) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *AppVersionMutation) Version() (r int32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *AppVersionMutation) AddVersion(i int32) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *AppVersionMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *AppVersionMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[appversion.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *AppVersionMutation) VersionCleared() bool {
	_, ok := m.clearedFields[appversion.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *AppVersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, appversion.FieldVersion)
}

// SetUpdateInfo sets the "updateInfo" field.
func (m *AppVersionMutation) SetUpdateInfo(s string) {
	m.updateInfo = &s
}

// UpdateInfo returns the value of the "updateInfo" field in the mutation.
func (m *AppVersionMutation) UpdateInfo() (r string, exists bool) {
	v := m.updateInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateInfo returns the old "updateInfo" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldUpdateInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateInfo: %w", err)
	}
	return oldValue.UpdateInfo, nil
}

// ClearUpdateInfo clears the value of the "updateInfo" field.
func (m *AppVersionMutation) ClearUpdateInfo() {
	m.updateInfo = nil
	m.clearedFields[appversion.FieldUpdateInfo] = struct{}{}
}

// UpdateInfoCleared returns if the "updateInfo" field was cleared in this mutation.
func (m *AppVersionMutation) UpdateInfoCleared() bool {
	_, ok := m.clearedFields[appversion.FieldUpdateInfo]
	return ok
}

// ResetUpdateInfo resets all changes to the "updateInfo" field.
func (m *AppVersionMutation) ResetUpdateInfo() {
	m.updateInfo = nil
	delete(m.clearedFields, appversion.FieldUpdateInfo)
}

// SetDownloadUrl sets the "downloadUrl" field.
func (m *AppVersionMutation) SetDownloadUrl(s string) {
	m.downloadUrl = &s
}

// DownloadUrl returns the value of the "downloadUrl" field in the mutation.
func (m *AppVersionMutation) DownloadUrl() (r string, exists bool) {
	v := m.downloadUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadUrl returns the old "downloadUrl" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldDownloadUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadUrl: %w", err)
	}
	return oldValue.DownloadUrl, nil
}

// ClearDownloadUrl clears the value of the "downloadUrl" field.
func (m *AppVersionMutation) ClearDownloadUrl() {
	m.downloadUrl = nil
	m.clearedFields[appversion.FieldDownloadUrl] = struct{}{}
}

// DownloadUrlCleared returns if the "downloadUrl" field was cleared in this mutation.
func (m *AppVersionMutation) DownloadUrlCleared() bool {
	_, ok := m.clearedFields[appversion.FieldDownloadUrl]
	return ok
}

// ResetDownloadUrl resets all changes to the "downloadUrl" field.
func (m *AppVersionMutation) ResetDownloadUrl() {
	m.downloadUrl = nil
	delete(m.clearedFields, appversion.FieldDownloadUrl)
}

// SetPlatform sets the "platform" field.
func (m *AppVersionMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AppVersionMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *AppVersionMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[appversion.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *AppVersionMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[appversion.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AppVersionMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, appversion.FieldPlatform)
}

// SetCreatedAt sets the "createdAt" field.
func (m *AppVersionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AppVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AppVersionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AppVersionMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AppVersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AppVersionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AppVersionMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AppVersionMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AppVersionMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AppVersionMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AppVersionMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AppVersionMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AppVersionMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AppVersionMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AppVersionMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AppVersionMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AppVersionMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AppVersionMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AppVersionMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AppVersionMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AppVersionMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the AppVersionMutation builder.
func (m *AppVersionMutation) Where(ps ...predicate.AppVersion) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppVersionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppVersion).
func (m *AppVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppVersionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, appversion.FieldTitle)
	}
	if m.version != nil {
		fields = append(fields, appversion.FieldVersion)
	}
	if m.updateInfo != nil {
		fields = append(fields, appversion.FieldUpdateInfo)
	}
	if m.downloadUrl != nil {
		fields = append(fields, appversion.FieldDownloadUrl)
	}
	if m.platform != nil {
		fields = append(fields, appversion.FieldPlatform)
	}
	if m.createdAt != nil {
		fields = append(fields, appversion.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, appversion.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, appversion.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, appversion.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, appversion.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appversion.FieldTitle:
		return m.Title()
	case appversion.FieldVersion:
		return m.Version()
	case appversion.FieldUpdateInfo:
		return m.UpdateInfo()
	case appversion.FieldDownloadUrl:
		return m.DownloadUrl()
	case appversion.FieldPlatform:
		return m.Platform()
	case appversion.FieldCreatedAt:
		return m.CreatedAt()
	case appversion.FieldUpdatedAt:
		return m.UpdatedAt()
	case appversion.FieldCreateBy:
		return m.CreateBy()
	case appversion.FieldUpdateBy:
		return m.UpdateBy()
	case appversion.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appversion.FieldTitle:
		return m.OldTitle(ctx)
	case appversion.FieldVersion:
		return m.OldVersion(ctx)
	case appversion.FieldUpdateInfo:
		return m.OldUpdateInfo(ctx)
	case appversion.FieldDownloadUrl:
		return m.OldDownloadUrl(ctx)
	case appversion.FieldPlatform:
		return m.OldPlatform(ctx)
	case appversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appversion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appversion.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case appversion.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case appversion.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AppVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appversion.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case appversion.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case appversion.FieldUpdateInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateInfo(v)
		return nil
	case appversion.FieldDownloadUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadUrl(v)
		return nil
	case appversion.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case appversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appversion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appversion.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case appversion.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case appversion.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AppVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, appversion.FieldVersion)
	}
	if m.addcreateBy != nil {
		fields = append(fields, appversion.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, appversion.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, appversion.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appversion.FieldVersion:
		return m.AddedVersion()
	case appversion.FieldCreateBy:
		return m.AddedCreateBy()
	case appversion.FieldUpdateBy:
		return m.AddedUpdateBy()
	case appversion.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appversion.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case appversion.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case appversion.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case appversion.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AppVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appversion.FieldTitle) {
		fields = append(fields, appversion.FieldTitle)
	}
	if m.FieldCleared(appversion.FieldVersion) {
		fields = append(fields, appversion.FieldVersion)
	}
	if m.FieldCleared(appversion.FieldUpdateInfo) {
		fields = append(fields, appversion.FieldUpdateInfo)
	}
	if m.FieldCleared(appversion.FieldDownloadUrl) {
		fields = append(fields, appversion.FieldDownloadUrl)
	}
	if m.FieldCleared(appversion.FieldPlatform) {
		fields = append(fields, appversion.FieldPlatform)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppVersionMutation) ClearField(name string) error {
	switch name {
	case appversion.FieldTitle:
		m.ClearTitle()
		return nil
	case appversion.FieldVersion:
		m.ClearVersion()
		return nil
	case appversion.FieldUpdateInfo:
		m.ClearUpdateInfo()
		return nil
	case appversion.FieldDownloadUrl:
		m.ClearDownloadUrl()
		return nil
	case appversion.FieldPlatform:
		m.ClearPlatform()
		return nil
	}
	return fmt.Errorf("unknown AppVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppVersionMutation) ResetField(name string) error {
	switch name {
	case appversion.FieldTitle:
		m.ResetTitle()
		return nil
	case appversion.FieldVersion:
		m.ResetVersion()
		return nil
	case appversion.FieldUpdateInfo:
		m.ResetUpdateInfo()
		return nil
	case appversion.FieldDownloadUrl:
		m.ResetDownloadUrl()
		return nil
	case appversion.FieldPlatform:
		m.ResetPlatform()
		return nil
	case appversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appversion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appversion.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case appversion.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case appversion.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AppVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppVersion edge %s", name)
}

// AssetChangeLogMutation represents an operation that mutates the AssetChangeLog nodes in the graph.
type AssetChangeLogMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	orderId        *string
	balanceId      *int64
	addbalanceId   *int64
	eventId        *int64
	addeventId     *int64
	assetItemId    *int32
	addassetItemId *int32
	amount         *int64
	addamount      *int64
	oldBalance     *int64
	addoldBalance  *int64
	newBalance     *int64
	addnewBalance  *int64
	remark         *string
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*AssetChangeLog, error)
	predicates     []predicate.AssetChangeLog
}

var _ ent.Mutation = (*AssetChangeLogMutation)(nil)

// assetchangelogOption allows management of the mutation configuration using functional options.
type assetchangelogOption func(*AssetChangeLogMutation)

// newAssetChangeLogMutation creates new mutation for the AssetChangeLog entity.
func newAssetChangeLogMutation(c config, op Op, opts ...assetchangelogOption) *AssetChangeLogMutation {
	m := &AssetChangeLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetChangeLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetChangeLogID sets the ID field of the mutation.
func withAssetChangeLogID(id int64) assetchangelogOption {
	return func(m *AssetChangeLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetChangeLog
		)
		m.oldValue = func(ctx context.Context) (*AssetChangeLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetChangeLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetChangeLog sets the old AssetChangeLog of the mutation.
func withAssetChangeLog(node *AssetChangeLog) assetchangelogOption {
	return func(m *AssetChangeLogMutation) {
		m.oldValue = func(context.Context) (*AssetChangeLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetChangeLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetChangeLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetChangeLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetChangeLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetChangeLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderId sets the "orderId" field.
func (m *AssetChangeLogMutation) SetOrderId(s string) {
	m.orderId = &s
}

// OrderId returns the value of the "orderId" field in the mutation.
func (m *AssetChangeLogMutation) OrderId() (r string, exists bool) {
	v := m.orderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderId returns the old "orderId" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldOrderId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderId: %w", err)
	}
	return oldValue.OrderId, nil
}

// ClearOrderId clears the value of the "orderId" field.
func (m *AssetChangeLogMutation) ClearOrderId() {
	m.orderId = nil
	m.clearedFields[assetchangelog.FieldOrderId] = struct{}{}
}

// OrderIdCleared returns if the "orderId" field was cleared in this mutation.
func (m *AssetChangeLogMutation) OrderIdCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldOrderId]
	return ok
}

// ResetOrderId resets all changes to the "orderId" field.
func (m *AssetChangeLogMutation) ResetOrderId() {
	m.orderId = nil
	delete(m.clearedFields, assetchangelog.FieldOrderId)
}

// SetBalanceId sets the "balanceId" field.
func (m *AssetChangeLogMutation) SetBalanceId(i int64) {
	m.balanceId = &i
	m.addbalanceId = nil
}

// BalanceId returns the value of the "balanceId" field in the mutation.
func (m *AssetChangeLogMutation) BalanceId() (r int64, exists bool) {
	v := m.balanceId
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceId returns the old "balanceId" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldBalanceId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceId: %w", err)
	}
	return oldValue.BalanceId, nil
}

// AddBalanceId adds i to the "balanceId" field.
func (m *AssetChangeLogMutation) AddBalanceId(i int64) {
	if m.addbalanceId != nil {
		*m.addbalanceId += i
	} else {
		m.addbalanceId = &i
	}
}

// AddedBalanceId returns the value that was added to the "balanceId" field in this mutation.
func (m *AssetChangeLogMutation) AddedBalanceId() (r int64, exists bool) {
	v := m.addbalanceId
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalanceId clears the value of the "balanceId" field.
func (m *AssetChangeLogMutation) ClearBalanceId() {
	m.balanceId = nil
	m.addbalanceId = nil
	m.clearedFields[assetchangelog.FieldBalanceId] = struct{}{}
}

// BalanceIdCleared returns if the "balanceId" field was cleared in this mutation.
func (m *AssetChangeLogMutation) BalanceIdCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldBalanceId]
	return ok
}

// ResetBalanceId resets all changes to the "balanceId" field.
func (m *AssetChangeLogMutation) ResetBalanceId() {
	m.balanceId = nil
	m.addbalanceId = nil
	delete(m.clearedFields, assetchangelog.FieldBalanceId)
}

// SetEventId sets the "eventId" field.
func (m *AssetChangeLogMutation) SetEventId(i int64) {
	m.eventId = &i
	m.addeventId = nil
}

// EventId returns the value of the "eventId" field in the mutation.
func (m *AssetChangeLogMutation) EventId() (r int64, exists bool) {
	v := m.eventId
	if v == nil {
		return
	}
	return *v, true
}

// OldEventId returns the old "eventId" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldEventId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventId: %w", err)
	}
	return oldValue.EventId, nil
}

// AddEventId adds i to the "eventId" field.
func (m *AssetChangeLogMutation) AddEventId(i int64) {
	if m.addeventId != nil {
		*m.addeventId += i
	} else {
		m.addeventId = &i
	}
}

// AddedEventId returns the value that was added to the "eventId" field in this mutation.
func (m *AssetChangeLogMutation) AddedEventId() (r int64, exists bool) {
	v := m.addeventId
	if v == nil {
		return
	}
	return *v, true
}

// ClearEventId clears the value of the "eventId" field.
func (m *AssetChangeLogMutation) ClearEventId() {
	m.eventId = nil
	m.addeventId = nil
	m.clearedFields[assetchangelog.FieldEventId] = struct{}{}
}

// EventIdCleared returns if the "eventId" field was cleared in this mutation.
func (m *AssetChangeLogMutation) EventIdCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldEventId]
	return ok
}

// ResetEventId resets all changes to the "eventId" field.
func (m *AssetChangeLogMutation) ResetEventId() {
	m.eventId = nil
	m.addeventId = nil
	delete(m.clearedFields, assetchangelog.FieldEventId)
}

// SetUserId sets the "userId" field.
func (m *AssetChangeLogMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *AssetChangeLogMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *AssetChangeLogMutation) ResetUserId() {
	m.user = nil
}

// SetAssetItemId sets the "assetItemId" field.
func (m *AssetChangeLogMutation) SetAssetItemId(i int32) {
	m.assetItemId = &i
	m.addassetItemId = nil
}

// AssetItemId returns the value of the "assetItemId" field in the mutation.
func (m *AssetChangeLogMutation) AssetItemId() (r int32, exists bool) {
	v := m.assetItemId
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetItemId returns the old "assetItemId" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldAssetItemId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetItemId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetItemId: %w", err)
	}
	return oldValue.AssetItemId, nil
}

// AddAssetItemId adds i to the "assetItemId" field.
func (m *AssetChangeLogMutation) AddAssetItemId(i int32) {
	if m.addassetItemId != nil {
		*m.addassetItemId += i
	} else {
		m.addassetItemId = &i
	}
}

// AddedAssetItemId returns the value that was added to the "assetItemId" field in this mutation.
func (m *AssetChangeLogMutation) AddedAssetItemId() (r int32, exists bool) {
	v := m.addassetItemId
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssetItemId clears the value of the "assetItemId" field.
func (m *AssetChangeLogMutation) ClearAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
	m.clearedFields[assetchangelog.FieldAssetItemId] = struct{}{}
}

// AssetItemIdCleared returns if the "assetItemId" field was cleared in this mutation.
func (m *AssetChangeLogMutation) AssetItemIdCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldAssetItemId]
	return ok
}

// ResetAssetItemId resets all changes to the "assetItemId" field.
func (m *AssetChangeLogMutation) ResetAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
	delete(m.clearedFields, assetchangelog.FieldAssetItemId)
}

// SetAmount sets the "amount" field.
func (m *AssetChangeLogMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AssetChangeLogMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *AssetChangeLogMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AssetChangeLogMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *AssetChangeLogMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[assetchangelog.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *AssetChangeLogMutation) AmountCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *AssetChangeLogMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, assetchangelog.FieldAmount)
}

// SetOldBalance sets the "oldBalance" field.
func (m *AssetChangeLogMutation) SetOldBalance(i int64) {
	m.oldBalance = &i
	m.addoldBalance = nil
}

// OldBalance returns the value of the "oldBalance" field in the mutation.
func (m *AssetChangeLogMutation) OldBalance() (r int64, exists bool) {
	v := m.oldBalance
	if v == nil {
		return
	}
	return *v, true
}

// OldOldBalance returns the old "oldBalance" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldOldBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldBalance: %w", err)
	}
	return oldValue.OldBalance, nil
}

// AddOldBalance adds i to the "oldBalance" field.
func (m *AssetChangeLogMutation) AddOldBalance(i int64) {
	if m.addoldBalance != nil {
		*m.addoldBalance += i
	} else {
		m.addoldBalance = &i
	}
}

// AddedOldBalance returns the value that was added to the "oldBalance" field in this mutation.
func (m *AssetChangeLogMutation) AddedOldBalance() (r int64, exists bool) {
	v := m.addoldBalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearOldBalance clears the value of the "oldBalance" field.
func (m *AssetChangeLogMutation) ClearOldBalance() {
	m.oldBalance = nil
	m.addoldBalance = nil
	m.clearedFields[assetchangelog.FieldOldBalance] = struct{}{}
}

// OldBalanceCleared returns if the "oldBalance" field was cleared in this mutation.
func (m *AssetChangeLogMutation) OldBalanceCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldOldBalance]
	return ok
}

// ResetOldBalance resets all changes to the "oldBalance" field.
func (m *AssetChangeLogMutation) ResetOldBalance() {
	m.oldBalance = nil
	m.addoldBalance = nil
	delete(m.clearedFields, assetchangelog.FieldOldBalance)
}

// SetNewBalance sets the "newBalance" field.
func (m *AssetChangeLogMutation) SetNewBalance(i int64) {
	m.newBalance = &i
	m.addnewBalance = nil
}

// NewBalance returns the value of the "newBalance" field in the mutation.
func (m *AssetChangeLogMutation) NewBalance() (r int64, exists bool) {
	v := m.newBalance
	if v == nil {
		return
	}
	return *v, true
}

// OldNewBalance returns the old "newBalance" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldNewBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewBalance: %w", err)
	}
	return oldValue.NewBalance, nil
}

// AddNewBalance adds i to the "newBalance" field.
func (m *AssetChangeLogMutation) AddNewBalance(i int64) {
	if m.addnewBalance != nil {
		*m.addnewBalance += i
	} else {
		m.addnewBalance = &i
	}
}

// AddedNewBalance returns the value that was added to the "newBalance" field in this mutation.
func (m *AssetChangeLogMutation) AddedNewBalance() (r int64, exists bool) {
	v := m.addnewBalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearNewBalance clears the value of the "newBalance" field.
func (m *AssetChangeLogMutation) ClearNewBalance() {
	m.newBalance = nil
	m.addnewBalance = nil
	m.clearedFields[assetchangelog.FieldNewBalance] = struct{}{}
}

// NewBalanceCleared returns if the "newBalance" field was cleared in this mutation.
func (m *AssetChangeLogMutation) NewBalanceCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldNewBalance]
	return ok
}

// ResetNewBalance resets all changes to the "newBalance" field.
func (m *AssetChangeLogMutation) ResetNewBalance() {
	m.newBalance = nil
	m.addnewBalance = nil
	delete(m.clearedFields, assetchangelog.FieldNewBalance)
}

// SetRemark sets the "remark" field.
func (m *AssetChangeLogMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AssetChangeLogMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AssetChangeLogMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[assetchangelog.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AssetChangeLogMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[assetchangelog.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AssetChangeLogMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, assetchangelog.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *AssetChangeLogMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AssetChangeLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AssetChangeLogMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AssetChangeLogMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AssetChangeLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AssetChangeLogMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AssetChangeLogMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AssetChangeLogMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AssetChangeLogMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AssetChangeLogMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AssetChangeLogMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AssetChangeLogMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AssetChangeLogMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AssetChangeLogMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AssetChangeLogMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AssetChangeLogMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AssetChangeLogMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AssetChangeLogMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AssetChangeLog entity.
// If the AssetChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetChangeLogMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AssetChangeLogMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AssetChangeLogMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AssetChangeLogMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *AssetChangeLogMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *AssetChangeLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *AssetChangeLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AssetChangeLogMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AssetChangeLogMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AssetChangeLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AssetChangeLogMutation builder.
func (m *AssetChangeLogMutation) Where(ps ...predicate.AssetChangeLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetChangeLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AssetChangeLog).
func (m *AssetChangeLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetChangeLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.orderId != nil {
		fields = append(fields, assetchangelog.FieldOrderId)
	}
	if m.balanceId != nil {
		fields = append(fields, assetchangelog.FieldBalanceId)
	}
	if m.eventId != nil {
		fields = append(fields, assetchangelog.FieldEventId)
	}
	if m.user != nil {
		fields = append(fields, assetchangelog.FieldUserId)
	}
	if m.assetItemId != nil {
		fields = append(fields, assetchangelog.FieldAssetItemId)
	}
	if m.amount != nil {
		fields = append(fields, assetchangelog.FieldAmount)
	}
	if m.oldBalance != nil {
		fields = append(fields, assetchangelog.FieldOldBalance)
	}
	if m.newBalance != nil {
		fields = append(fields, assetchangelog.FieldNewBalance)
	}
	if m.remark != nil {
		fields = append(fields, assetchangelog.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, assetchangelog.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, assetchangelog.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, assetchangelog.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, assetchangelog.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, assetchangelog.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetChangeLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetchangelog.FieldOrderId:
		return m.OrderId()
	case assetchangelog.FieldBalanceId:
		return m.BalanceId()
	case assetchangelog.FieldEventId:
		return m.EventId()
	case assetchangelog.FieldUserId:
		return m.UserId()
	case assetchangelog.FieldAssetItemId:
		return m.AssetItemId()
	case assetchangelog.FieldAmount:
		return m.Amount()
	case assetchangelog.FieldOldBalance:
		return m.OldBalance()
	case assetchangelog.FieldNewBalance:
		return m.NewBalance()
	case assetchangelog.FieldRemark:
		return m.Remark()
	case assetchangelog.FieldCreatedAt:
		return m.CreatedAt()
	case assetchangelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case assetchangelog.FieldCreateBy:
		return m.CreateBy()
	case assetchangelog.FieldUpdateBy:
		return m.UpdateBy()
	case assetchangelog.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetChangeLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetchangelog.FieldOrderId:
		return m.OldOrderId(ctx)
	case assetchangelog.FieldBalanceId:
		return m.OldBalanceId(ctx)
	case assetchangelog.FieldEventId:
		return m.OldEventId(ctx)
	case assetchangelog.FieldUserId:
		return m.OldUserId(ctx)
	case assetchangelog.FieldAssetItemId:
		return m.OldAssetItemId(ctx)
	case assetchangelog.FieldAmount:
		return m.OldAmount(ctx)
	case assetchangelog.FieldOldBalance:
		return m.OldOldBalance(ctx)
	case assetchangelog.FieldNewBalance:
		return m.OldNewBalance(ctx)
	case assetchangelog.FieldRemark:
		return m.OldRemark(ctx)
	case assetchangelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assetchangelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assetchangelog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case assetchangelog.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case assetchangelog.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AssetChangeLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetChangeLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetchangelog.FieldOrderId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderId(v)
		return nil
	case assetchangelog.FieldBalanceId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceId(v)
		return nil
	case assetchangelog.FieldEventId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventId(v)
		return nil
	case assetchangelog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case assetchangelog.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetItemId(v)
		return nil
	case assetchangelog.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case assetchangelog.FieldOldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldBalance(v)
		return nil
	case assetchangelog.FieldNewBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewBalance(v)
		return nil
	case assetchangelog.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case assetchangelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assetchangelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assetchangelog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case assetchangelog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case assetchangelog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AssetChangeLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetChangeLogMutation) AddedFields() []string {
	var fields []string
	if m.addbalanceId != nil {
		fields = append(fields, assetchangelog.FieldBalanceId)
	}
	if m.addeventId != nil {
		fields = append(fields, assetchangelog.FieldEventId)
	}
	if m.addassetItemId != nil {
		fields = append(fields, assetchangelog.FieldAssetItemId)
	}
	if m.addamount != nil {
		fields = append(fields, assetchangelog.FieldAmount)
	}
	if m.addoldBalance != nil {
		fields = append(fields, assetchangelog.FieldOldBalance)
	}
	if m.addnewBalance != nil {
		fields = append(fields, assetchangelog.FieldNewBalance)
	}
	if m.addcreateBy != nil {
		fields = append(fields, assetchangelog.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, assetchangelog.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, assetchangelog.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetChangeLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assetchangelog.FieldBalanceId:
		return m.AddedBalanceId()
	case assetchangelog.FieldEventId:
		return m.AddedEventId()
	case assetchangelog.FieldAssetItemId:
		return m.AddedAssetItemId()
	case assetchangelog.FieldAmount:
		return m.AddedAmount()
	case assetchangelog.FieldOldBalance:
		return m.AddedOldBalance()
	case assetchangelog.FieldNewBalance:
		return m.AddedNewBalance()
	case assetchangelog.FieldCreateBy:
		return m.AddedCreateBy()
	case assetchangelog.FieldUpdateBy:
		return m.AddedUpdateBy()
	case assetchangelog.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetChangeLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assetchangelog.FieldBalanceId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceId(v)
		return nil
	case assetchangelog.FieldEventId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventId(v)
		return nil
	case assetchangelog.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetItemId(v)
		return nil
	case assetchangelog.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case assetchangelog.FieldOldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOldBalance(v)
		return nil
	case assetchangelog.FieldNewBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNewBalance(v)
		return nil
	case assetchangelog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case assetchangelog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case assetchangelog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AssetChangeLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetChangeLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assetchangelog.FieldOrderId) {
		fields = append(fields, assetchangelog.FieldOrderId)
	}
	if m.FieldCleared(assetchangelog.FieldBalanceId) {
		fields = append(fields, assetchangelog.FieldBalanceId)
	}
	if m.FieldCleared(assetchangelog.FieldEventId) {
		fields = append(fields, assetchangelog.FieldEventId)
	}
	if m.FieldCleared(assetchangelog.FieldAssetItemId) {
		fields = append(fields, assetchangelog.FieldAssetItemId)
	}
	if m.FieldCleared(assetchangelog.FieldAmount) {
		fields = append(fields, assetchangelog.FieldAmount)
	}
	if m.FieldCleared(assetchangelog.FieldOldBalance) {
		fields = append(fields, assetchangelog.FieldOldBalance)
	}
	if m.FieldCleared(assetchangelog.FieldNewBalance) {
		fields = append(fields, assetchangelog.FieldNewBalance)
	}
	if m.FieldCleared(assetchangelog.FieldRemark) {
		fields = append(fields, assetchangelog.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetChangeLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetChangeLogMutation) ClearField(name string) error {
	switch name {
	case assetchangelog.FieldOrderId:
		m.ClearOrderId()
		return nil
	case assetchangelog.FieldBalanceId:
		m.ClearBalanceId()
		return nil
	case assetchangelog.FieldEventId:
		m.ClearEventId()
		return nil
	case assetchangelog.FieldAssetItemId:
		m.ClearAssetItemId()
		return nil
	case assetchangelog.FieldAmount:
		m.ClearAmount()
		return nil
	case assetchangelog.FieldOldBalance:
		m.ClearOldBalance()
		return nil
	case assetchangelog.FieldNewBalance:
		m.ClearNewBalance()
		return nil
	case assetchangelog.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown AssetChangeLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetChangeLogMutation) ResetField(name string) error {
	switch name {
	case assetchangelog.FieldOrderId:
		m.ResetOrderId()
		return nil
	case assetchangelog.FieldBalanceId:
		m.ResetBalanceId()
		return nil
	case assetchangelog.FieldEventId:
		m.ResetEventId()
		return nil
	case assetchangelog.FieldUserId:
		m.ResetUserId()
		return nil
	case assetchangelog.FieldAssetItemId:
		m.ResetAssetItemId()
		return nil
	case assetchangelog.FieldAmount:
		m.ResetAmount()
		return nil
	case assetchangelog.FieldOldBalance:
		m.ResetOldBalance()
		return nil
	case assetchangelog.FieldNewBalance:
		m.ResetNewBalance()
		return nil
	case assetchangelog.FieldRemark:
		m.ResetRemark()
		return nil
	case assetchangelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assetchangelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assetchangelog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case assetchangelog.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case assetchangelog.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AssetChangeLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetChangeLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, assetchangelog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetChangeLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetchangelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetChangeLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetChangeLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetChangeLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, assetchangelog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetChangeLogMutation) EdgeCleared(name string) bool {
	switch name {
	case assetchangelog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetChangeLogMutation) ClearEdge(name string) error {
	switch name {
	case assetchangelog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AssetChangeLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetChangeLogMutation) ResetEdge(name string) error {
	switch name {
	case assetchangelog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AssetChangeLog edge %s", name)
}

// AssetItemMutation represents an operation that mutates the AssetItem nodes in the graph.
type AssetItemMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	assetItemId    *int32
	addassetItemId *int32
	assetName      *string
	cashTag        *int32
	addcashTag     *int32
	validDays      *int32
	addvalidDays   *int32
	effectTime     *time.Time
	expiredTime    *time.Time
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AssetItem, error)
	predicates     []predicate.AssetItem
}

var _ ent.Mutation = (*AssetItemMutation)(nil)

// assetitemOption allows management of the mutation configuration using functional options.
type assetitemOption func(*AssetItemMutation)

// newAssetItemMutation creates new mutation for the AssetItem entity.
func newAssetItemMutation(c config, op Op, opts ...assetitemOption) *AssetItemMutation {
	m := &AssetItemMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetItemID sets the ID field of the mutation.
func withAssetItemID(id int64) assetitemOption {
	return func(m *AssetItemMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetItem
		)
		m.oldValue = func(ctx context.Context) (*AssetItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetItem sets the old AssetItem of the mutation.
func withAssetItem(node *AssetItem) assetitemOption {
	return func(m *AssetItemMutation) {
		m.oldValue = func(context.Context) (*AssetItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssetItemId sets the "assetItemId" field.
func (m *AssetItemMutation) SetAssetItemId(i int32) {
	m.assetItemId = &i
	m.addassetItemId = nil
}

// AssetItemId returns the value of the "assetItemId" field in the mutation.
func (m *AssetItemMutation) AssetItemId() (r int32, exists bool) {
	v := m.assetItemId
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetItemId returns the old "assetItemId" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldAssetItemId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetItemId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetItemId: %w", err)
	}
	return oldValue.AssetItemId, nil
}

// AddAssetItemId adds i to the "assetItemId" field.
func (m *AssetItemMutation) AddAssetItemId(i int32) {
	if m.addassetItemId != nil {
		*m.addassetItemId += i
	} else {
		m.addassetItemId = &i
	}
}

// AddedAssetItemId returns the value that was added to the "assetItemId" field in this mutation.
func (m *AssetItemMutation) AddedAssetItemId() (r int32, exists bool) {
	v := m.addassetItemId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssetItemId resets all changes to the "assetItemId" field.
func (m *AssetItemMutation) ResetAssetItemId() {
	m.assetItemId = nil
	m.addassetItemId = nil
}

// SetAssetName sets the "assetName" field.
func (m *AssetItemMutation) SetAssetName(s string) {
	m.assetName = &s
}

// AssetName returns the value of the "assetName" field in the mutation.
func (m *AssetItemMutation) AssetName() (r string, exists bool) {
	v := m.assetName
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetName returns the old "assetName" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldAssetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetName: %w", err)
	}
	return oldValue.AssetName, nil
}

// ClearAssetName clears the value of the "assetName" field.
func (m *AssetItemMutation) ClearAssetName() {
	m.assetName = nil
	m.clearedFields[assetitem.FieldAssetName] = struct{}{}
}

// AssetNameCleared returns if the "assetName" field was cleared in this mutation.
func (m *AssetItemMutation) AssetNameCleared() bool {
	_, ok := m.clearedFields[assetitem.FieldAssetName]
	return ok
}

// ResetAssetName resets all changes to the "assetName" field.
func (m *AssetItemMutation) ResetAssetName() {
	m.assetName = nil
	delete(m.clearedFields, assetitem.FieldAssetName)
}

// SetCashTag sets the "cashTag" field.
func (m *AssetItemMutation) SetCashTag(i int32) {
	m.cashTag = &i
	m.addcashTag = nil
}

// CashTag returns the value of the "cashTag" field in the mutation.
func (m *AssetItemMutation) CashTag() (r int32, exists bool) {
	v := m.cashTag
	if v == nil {
		return
	}
	return *v, true
}

// OldCashTag returns the old "cashTag" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldCashTag(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashTag: %w", err)
	}
	return oldValue.CashTag, nil
}

// AddCashTag adds i to the "cashTag" field.
func (m *AssetItemMutation) AddCashTag(i int32) {
	if m.addcashTag != nil {
		*m.addcashTag += i
	} else {
		m.addcashTag = &i
	}
}

// AddedCashTag returns the value that was added to the "cashTag" field in this mutation.
func (m *AssetItemMutation) AddedCashTag() (r int32, exists bool) {
	v := m.addcashTag
	if v == nil {
		return
	}
	return *v, true
}

// ClearCashTag clears the value of the "cashTag" field.
func (m *AssetItemMutation) ClearCashTag() {
	m.cashTag = nil
	m.addcashTag = nil
	m.clearedFields[assetitem.FieldCashTag] = struct{}{}
}

// CashTagCleared returns if the "cashTag" field was cleared in this mutation.
func (m *AssetItemMutation) CashTagCleared() bool {
	_, ok := m.clearedFields[assetitem.FieldCashTag]
	return ok
}

// ResetCashTag resets all changes to the "cashTag" field.
func (m *AssetItemMutation) ResetCashTag() {
	m.cashTag = nil
	m.addcashTag = nil
	delete(m.clearedFields, assetitem.FieldCashTag)
}

// SetValidDays sets the "validDays" field.
func (m *AssetItemMutation) SetValidDays(i int32) {
	m.validDays = &i
	m.addvalidDays = nil
}

// ValidDays returns the value of the "validDays" field in the mutation.
func (m *AssetItemMutation) ValidDays() (r int32, exists bool) {
	v := m.validDays
	if v == nil {
		return
	}
	return *v, true
}

// OldValidDays returns the old "validDays" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldValidDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidDays: %w", err)
	}
	return oldValue.ValidDays, nil
}

// AddValidDays adds i to the "validDays" field.
func (m *AssetItemMutation) AddValidDays(i int32) {
	if m.addvalidDays != nil {
		*m.addvalidDays += i
	} else {
		m.addvalidDays = &i
	}
}

// AddedValidDays returns the value that was added to the "validDays" field in this mutation.
func (m *AssetItemMutation) AddedValidDays() (r int32, exists bool) {
	v := m.addvalidDays
	if v == nil {
		return
	}
	return *v, true
}

// ClearValidDays clears the value of the "validDays" field.
func (m *AssetItemMutation) ClearValidDays() {
	m.validDays = nil
	m.addvalidDays = nil
	m.clearedFields[assetitem.FieldValidDays] = struct{}{}
}

// ValidDaysCleared returns if the "validDays" field was cleared in this mutation.
func (m *AssetItemMutation) ValidDaysCleared() bool {
	_, ok := m.clearedFields[assetitem.FieldValidDays]
	return ok
}

// ResetValidDays resets all changes to the "validDays" field.
func (m *AssetItemMutation) ResetValidDays() {
	m.validDays = nil
	m.addvalidDays = nil
	delete(m.clearedFields, assetitem.FieldValidDays)
}

// SetEffectTime sets the "effectTime" field.
func (m *AssetItemMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *AssetItemMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *AssetItemMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *AssetItemMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *AssetItemMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *AssetItemMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *AssetItemMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AssetItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AssetItemMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AssetItemMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AssetItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AssetItemMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *AssetItemMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *AssetItemMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *AssetItemMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *AssetItemMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *AssetItemMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *AssetItemMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *AssetItemMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *AssetItemMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *AssetItemMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *AssetItemMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *AssetItemMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *AssetItemMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the AssetItem entity.
// If the AssetItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetItemMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *AssetItemMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *AssetItemMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *AssetItemMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the AssetItemMutation builder.
func (m *AssetItemMutation) Where(ps ...predicate.AssetItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AssetItem).
func (m *AssetItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.assetItemId != nil {
		fields = append(fields, assetitem.FieldAssetItemId)
	}
	if m.assetName != nil {
		fields = append(fields, assetitem.FieldAssetName)
	}
	if m.cashTag != nil {
		fields = append(fields, assetitem.FieldCashTag)
	}
	if m.validDays != nil {
		fields = append(fields, assetitem.FieldValidDays)
	}
	if m.effectTime != nil {
		fields = append(fields, assetitem.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, assetitem.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, assetitem.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, assetitem.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, assetitem.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, assetitem.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, assetitem.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetitem.FieldAssetItemId:
		return m.AssetItemId()
	case assetitem.FieldAssetName:
		return m.AssetName()
	case assetitem.FieldCashTag:
		return m.CashTag()
	case assetitem.FieldValidDays:
		return m.ValidDays()
	case assetitem.FieldEffectTime:
		return m.EffectTime()
	case assetitem.FieldExpiredTime:
		return m.ExpiredTime()
	case assetitem.FieldCreatedAt:
		return m.CreatedAt()
	case assetitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case assetitem.FieldCreateBy:
		return m.CreateBy()
	case assetitem.FieldUpdateBy:
		return m.UpdateBy()
	case assetitem.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetitem.FieldAssetItemId:
		return m.OldAssetItemId(ctx)
	case assetitem.FieldAssetName:
		return m.OldAssetName(ctx)
	case assetitem.FieldCashTag:
		return m.OldCashTag(ctx)
	case assetitem.FieldValidDays:
		return m.OldValidDays(ctx)
	case assetitem.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case assetitem.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case assetitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assetitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assetitem.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case assetitem.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case assetitem.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown AssetItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetitem.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetItemId(v)
		return nil
	case assetitem.FieldAssetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetName(v)
		return nil
	case assetitem.FieldCashTag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashTag(v)
		return nil
	case assetitem.FieldValidDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidDays(v)
		return nil
	case assetitem.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case assetitem.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case assetitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assetitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assetitem.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case assetitem.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case assetitem.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AssetItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetItemMutation) AddedFields() []string {
	var fields []string
	if m.addassetItemId != nil {
		fields = append(fields, assetitem.FieldAssetItemId)
	}
	if m.addcashTag != nil {
		fields = append(fields, assetitem.FieldCashTag)
	}
	if m.addvalidDays != nil {
		fields = append(fields, assetitem.FieldValidDays)
	}
	if m.addcreateBy != nil {
		fields = append(fields, assetitem.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, assetitem.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, assetitem.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assetitem.FieldAssetItemId:
		return m.AddedAssetItemId()
	case assetitem.FieldCashTag:
		return m.AddedCashTag()
	case assetitem.FieldValidDays:
		return m.AddedValidDays()
	case assetitem.FieldCreateBy:
		return m.AddedCreateBy()
	case assetitem.FieldUpdateBy:
		return m.AddedUpdateBy()
	case assetitem.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assetitem.FieldAssetItemId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetItemId(v)
		return nil
	case assetitem.FieldCashTag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCashTag(v)
		return nil
	case assetitem.FieldValidDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidDays(v)
		return nil
	case assetitem.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case assetitem.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case assetitem.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown AssetItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assetitem.FieldAssetName) {
		fields = append(fields, assetitem.FieldAssetName)
	}
	if m.FieldCleared(assetitem.FieldCashTag) {
		fields = append(fields, assetitem.FieldCashTag)
	}
	if m.FieldCleared(assetitem.FieldValidDays) {
		fields = append(fields, assetitem.FieldValidDays)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetItemMutation) ClearField(name string) error {
	switch name {
	case assetitem.FieldAssetName:
		m.ClearAssetName()
		return nil
	case assetitem.FieldCashTag:
		m.ClearCashTag()
		return nil
	case assetitem.FieldValidDays:
		m.ClearValidDays()
		return nil
	}
	return fmt.Errorf("unknown AssetItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetItemMutation) ResetField(name string) error {
	switch name {
	case assetitem.FieldAssetItemId:
		m.ResetAssetItemId()
		return nil
	case assetitem.FieldAssetName:
		m.ResetAssetName()
		return nil
	case assetitem.FieldCashTag:
		m.ResetCashTag()
		return nil
	case assetitem.FieldValidDays:
		m.ResetValidDays()
		return nil
	case assetitem.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case assetitem.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case assetitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assetitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assetitem.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case assetitem.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case assetitem.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown AssetItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AssetItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AssetItem edge %s", name)
}

// BookPackageMutation represents an operation that mutates the BookPackage nodes in the graph.
type BookPackageMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	activityCode  *string
	packageName   *string
	price         *int64
	addprice      *int64
	dailyPrice    *int64
	adddailyPrice *int64
	effectTime    *time.Time
	expiredTime   *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	books         map[int64]struct{}
	removedbooks  map[int64]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*BookPackage, error)
	predicates    []predicate.BookPackage
}

var _ ent.Mutation = (*BookPackageMutation)(nil)

// bookpackageOption allows management of the mutation configuration using functional options.
type bookpackageOption func(*BookPackageMutation)

// newBookPackageMutation creates new mutation for the BookPackage entity.
func newBookPackageMutation(c config, op Op, opts ...bookpackageOption) *BookPackageMutation {
	m := &BookPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeBookPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookPackageID sets the ID field of the mutation.
func withBookPackageID(id int64) bookpackageOption {
	return func(m *BookPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *BookPackage
		)
		m.oldValue = func(ctx context.Context) (*BookPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookPackage sets the old BookPackage of the mutation.
func withBookPackage(node *BookPackage) bookpackageOption {
	return func(m *BookPackageMutation) {
		m.oldValue = func(context.Context) (*BookPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookPackageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookPackageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityCode sets the "activityCode" field.
func (m *BookPackageMutation) SetActivityCode(s string) {
	m.activityCode = &s
}

// ActivityCode returns the value of the "activityCode" field in the mutation.
func (m *BookPackageMutation) ActivityCode() (r string, exists bool) {
	v := m.activityCode
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityCode returns the old "activityCode" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldActivityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityCode: %w", err)
	}
	return oldValue.ActivityCode, nil
}

// ClearActivityCode clears the value of the "activityCode" field.
func (m *BookPackageMutation) ClearActivityCode() {
	m.activityCode = nil
	m.clearedFields[bookpackage.FieldActivityCode] = struct{}{}
}

// ActivityCodeCleared returns if the "activityCode" field was cleared in this mutation.
func (m *BookPackageMutation) ActivityCodeCleared() bool {
	_, ok := m.clearedFields[bookpackage.FieldActivityCode]
	return ok
}

// ResetActivityCode resets all changes to the "activityCode" field.
func (m *BookPackageMutation) ResetActivityCode() {
	m.activityCode = nil
	delete(m.clearedFields, bookpackage.FieldActivityCode)
}

// SetPackageName sets the "packageName" field.
func (m *BookPackageMutation) SetPackageName(s string) {
	m.packageName = &s
}

// PackageName returns the value of the "packageName" field in the mutation.
func (m *BookPackageMutation) PackageName() (r string, exists bool) {
	v := m.packageName
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageName returns the old "packageName" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldPackageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageName: %w", err)
	}
	return oldValue.PackageName, nil
}

// ClearPackageName clears the value of the "packageName" field.
func (m *BookPackageMutation) ClearPackageName() {
	m.packageName = nil
	m.clearedFields[bookpackage.FieldPackageName] = struct{}{}
}

// PackageNameCleared returns if the "packageName" field was cleared in this mutation.
func (m *BookPackageMutation) PackageNameCleared() bool {
	_, ok := m.clearedFields[bookpackage.FieldPackageName]
	return ok
}

// ResetPackageName resets all changes to the "packageName" field.
func (m *BookPackageMutation) ResetPackageName() {
	m.packageName = nil
	delete(m.clearedFields, bookpackage.FieldPackageName)
}

// SetPrice sets the "price" field.
func (m *BookPackageMutation) SetPrice(i int64) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *BookPackageMutation) Price() (r int64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *BookPackageMutation) AddPrice(i int64) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *BookPackageMutation) AddedPrice() (r int64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *BookPackageMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[bookpackage.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *BookPackageMutation) PriceCleared() bool {
	_, ok := m.clearedFields[bookpackage.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *BookPackageMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, bookpackage.FieldPrice)
}

// SetDailyPrice sets the "dailyPrice" field.
func (m *BookPackageMutation) SetDailyPrice(i int64) {
	m.dailyPrice = &i
	m.adddailyPrice = nil
}

// DailyPrice returns the value of the "dailyPrice" field in the mutation.
func (m *BookPackageMutation) DailyPrice() (r int64, exists bool) {
	v := m.dailyPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyPrice returns the old "dailyPrice" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldDailyPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyPrice: %w", err)
	}
	return oldValue.DailyPrice, nil
}

// AddDailyPrice adds i to the "dailyPrice" field.
func (m *BookPackageMutation) AddDailyPrice(i int64) {
	if m.adddailyPrice != nil {
		*m.adddailyPrice += i
	} else {
		m.adddailyPrice = &i
	}
}

// AddedDailyPrice returns the value that was added to the "dailyPrice" field in this mutation.
func (m *BookPackageMutation) AddedDailyPrice() (r int64, exists bool) {
	v := m.adddailyPrice
	if v == nil {
		return
	}
	return *v, true
}

// ClearDailyPrice clears the value of the "dailyPrice" field.
func (m *BookPackageMutation) ClearDailyPrice() {
	m.dailyPrice = nil
	m.adddailyPrice = nil
	m.clearedFields[bookpackage.FieldDailyPrice] = struct{}{}
}

// DailyPriceCleared returns if the "dailyPrice" field was cleared in this mutation.
func (m *BookPackageMutation) DailyPriceCleared() bool {
	_, ok := m.clearedFields[bookpackage.FieldDailyPrice]
	return ok
}

// ResetDailyPrice resets all changes to the "dailyPrice" field.
func (m *BookPackageMutation) ResetDailyPrice() {
	m.dailyPrice = nil
	m.adddailyPrice = nil
	delete(m.clearedFields, bookpackage.FieldDailyPrice)
}

// SetEffectTime sets the "effectTime" field.
func (m *BookPackageMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *BookPackageMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *BookPackageMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *BookPackageMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *BookPackageMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *BookPackageMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *BookPackageMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *BookPackageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *BookPackageMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *BookPackageMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *BookPackageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *BookPackageMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *BookPackageMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *BookPackageMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *BookPackageMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *BookPackageMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *BookPackageMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *BookPackageMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *BookPackageMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *BookPackageMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *BookPackageMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *BookPackageMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *BookPackageMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *BookPackageMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the BookPackage entity.
// If the BookPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookPackageMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *BookPackageMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *BookPackageMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *BookPackageMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// AddBookIDs adds the "books" edge to the Novel entity by ids.
func (m *BookPackageMutation) AddBookIDs(ids ...int64) {
	if m.books == nil {
		m.books = make(map[int64]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Novel entity.
func (m *BookPackageMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Novel entity was cleared.
func (m *BookPackageMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Novel entity by IDs.
func (m *BookPackageMutation) RemoveBookIDs(ids ...int64) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Novel entity.
func (m *BookPackageMutation) RemovedBooksIDs() (ids []int64) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *BookPackageMutation) BooksIDs() (ids []int64) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *BookPackageMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the BookPackageMutation builder.
func (m *BookPackageMutation) Where(ps ...predicate.BookPackage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BookPackageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BookPackage).
func (m *BookPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookPackageMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.activityCode != nil {
		fields = append(fields, bookpackage.FieldActivityCode)
	}
	if m.packageName != nil {
		fields = append(fields, bookpackage.FieldPackageName)
	}
	if m.price != nil {
		fields = append(fields, bookpackage.FieldPrice)
	}
	if m.dailyPrice != nil {
		fields = append(fields, bookpackage.FieldDailyPrice)
	}
	if m.effectTime != nil {
		fields = append(fields, bookpackage.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, bookpackage.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, bookpackage.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, bookpackage.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, bookpackage.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, bookpackage.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, bookpackage.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookpackage.FieldActivityCode:
		return m.ActivityCode()
	case bookpackage.FieldPackageName:
		return m.PackageName()
	case bookpackage.FieldPrice:
		return m.Price()
	case bookpackage.FieldDailyPrice:
		return m.DailyPrice()
	case bookpackage.FieldEffectTime:
		return m.EffectTime()
	case bookpackage.FieldExpiredTime:
		return m.ExpiredTime()
	case bookpackage.FieldCreatedAt:
		return m.CreatedAt()
	case bookpackage.FieldUpdatedAt:
		return m.UpdatedAt()
	case bookpackage.FieldCreateBy:
		return m.CreateBy()
	case bookpackage.FieldUpdateBy:
		return m.UpdateBy()
	case bookpackage.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookpackage.FieldActivityCode:
		return m.OldActivityCode(ctx)
	case bookpackage.FieldPackageName:
		return m.OldPackageName(ctx)
	case bookpackage.FieldPrice:
		return m.OldPrice(ctx)
	case bookpackage.FieldDailyPrice:
		return m.OldDailyPrice(ctx)
	case bookpackage.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case bookpackage.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case bookpackage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bookpackage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bookpackage.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case bookpackage.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case bookpackage.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown BookPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookpackage.FieldActivityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityCode(v)
		return nil
	case bookpackage.FieldPackageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageName(v)
		return nil
	case bookpackage.FieldPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case bookpackage.FieldDailyPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyPrice(v)
		return nil
	case bookpackage.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case bookpackage.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case bookpackage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bookpackage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bookpackage.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case bookpackage.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case bookpackage.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown BookPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookPackageMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, bookpackage.FieldPrice)
	}
	if m.adddailyPrice != nil {
		fields = append(fields, bookpackage.FieldDailyPrice)
	}
	if m.addcreateBy != nil {
		fields = append(fields, bookpackage.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, bookpackage.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, bookpackage.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookPackageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookpackage.FieldPrice:
		return m.AddedPrice()
	case bookpackage.FieldDailyPrice:
		return m.AddedDailyPrice()
	case bookpackage.FieldCreateBy:
		return m.AddedCreateBy()
	case bookpackage.FieldUpdateBy:
		return m.AddedUpdateBy()
	case bookpackage.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookpackage.FieldPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case bookpackage.FieldDailyPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyPrice(v)
		return nil
	case bookpackage.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case bookpackage.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case bookpackage.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown BookPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookpackage.FieldActivityCode) {
		fields = append(fields, bookpackage.FieldActivityCode)
	}
	if m.FieldCleared(bookpackage.FieldPackageName) {
		fields = append(fields, bookpackage.FieldPackageName)
	}
	if m.FieldCleared(bookpackage.FieldPrice) {
		fields = append(fields, bookpackage.FieldPrice)
	}
	if m.FieldCleared(bookpackage.FieldDailyPrice) {
		fields = append(fields, bookpackage.FieldDailyPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookPackageMutation) ClearField(name string) error {
	switch name {
	case bookpackage.FieldActivityCode:
		m.ClearActivityCode()
		return nil
	case bookpackage.FieldPackageName:
		m.ClearPackageName()
		return nil
	case bookpackage.FieldPrice:
		m.ClearPrice()
		return nil
	case bookpackage.FieldDailyPrice:
		m.ClearDailyPrice()
		return nil
	}
	return fmt.Errorf("unknown BookPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookPackageMutation) ResetField(name string) error {
	switch name {
	case bookpackage.FieldActivityCode:
		m.ResetActivityCode()
		return nil
	case bookpackage.FieldPackageName:
		m.ResetPackageName()
		return nil
	case bookpackage.FieldPrice:
		m.ResetPrice()
		return nil
	case bookpackage.FieldDailyPrice:
		m.ResetDailyPrice()
		return nil
	case bookpackage.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case bookpackage.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case bookpackage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bookpackage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bookpackage.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case bookpackage.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case bookpackage.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown BookPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, bookpackage.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookPackageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookpackage.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, bookpackage.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookPackageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bookpackage.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, bookpackage.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookPackageMutation) EdgeCleared(name string) bool {
	switch name {
	case bookpackage.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookPackageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BookPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookPackageMutation) ResetEdge(name string) error {
	switch name {
	case bookpackage.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown BookPackage edge %s", name)
}

// ClientErrorMutation represents an operation that mutates the ClientError nodes in the graph.
type ClientErrorMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	appVersion    *string
	deviceName    *string
	osName        *string
	errorInfo     *string
	userId        *int64
	adduserId     *int64
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ClientError, error)
	predicates    []predicate.ClientError
}

var _ ent.Mutation = (*ClientErrorMutation)(nil)

// clienterrorOption allows management of the mutation configuration using functional options.
type clienterrorOption func(*ClientErrorMutation)

// newClientErrorMutation creates new mutation for the ClientError entity.
func newClientErrorMutation(c config, op Op, opts ...clienterrorOption) *ClientErrorMutation {
	m := &ClientErrorMutation{
		config:        c,
		op:            op,
		typ:           TypeClientError,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClientErrorID sets the ID field of the mutation.
func withClientErrorID(id int64) clienterrorOption {
	return func(m *ClientErrorMutation) {
		var (
			err   error
			once  sync.Once
			value *ClientError
		)
		m.oldValue = func(ctx context.Context) (*ClientError, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClientError.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClientError sets the old ClientError of the mutation.
func withClientError(node *ClientError) clienterrorOption {
	return func(m *ClientErrorMutation) {
		m.oldValue = func(context.Context) (*ClientError, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClientErrorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClientErrorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClientErrorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClientErrorMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClientError.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppVersion sets the "appVersion" field.
func (m *ClientErrorMutation) SetAppVersion(s string) {
	m.appVersion = &s
}

// AppVersion returns the value of the "appVersion" field in the mutation.
func (m *ClientErrorMutation) AppVersion() (r string, exists bool) {
	v := m.appVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersion returns the old "appVersion" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldAppVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersion: %w", err)
	}
	return oldValue.AppVersion, nil
}

// ClearAppVersion clears the value of the "appVersion" field.
func (m *ClientErrorMutation) ClearAppVersion() {
	m.appVersion = nil
	m.clearedFields[clienterror.FieldAppVersion] = struct{}{}
}

// AppVersionCleared returns if the "appVersion" field was cleared in this mutation.
func (m *ClientErrorMutation) AppVersionCleared() bool {
	_, ok := m.clearedFields[clienterror.FieldAppVersion]
	return ok
}

// ResetAppVersion resets all changes to the "appVersion" field.
func (m *ClientErrorMutation) ResetAppVersion() {
	m.appVersion = nil
	delete(m.clearedFields, clienterror.FieldAppVersion)
}

// SetDeviceName sets the "deviceName" field.
func (m *ClientErrorMutation) SetDeviceName(s string) {
	m.deviceName = &s
}

// DeviceName returns the value of the "deviceName" field in the mutation.
func (m *ClientErrorMutation) DeviceName() (r string, exists bool) {
	v := m.deviceName
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "deviceName" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "deviceName" field.
func (m *ClientErrorMutation) ClearDeviceName() {
	m.deviceName = nil
	m.clearedFields[clienterror.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "deviceName" field was cleared in this mutation.
func (m *ClientErrorMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[clienterror.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "deviceName" field.
func (m *ClientErrorMutation) ResetDeviceName() {
	m.deviceName = nil
	delete(m.clearedFields, clienterror.FieldDeviceName)
}

// SetOsName sets the "osName" field.
func (m *ClientErrorMutation) SetOsName(s string) {
	m.osName = &s
}

// OsName returns the value of the "osName" field in the mutation.
func (m *ClientErrorMutation) OsName() (r string, exists bool) {
	v := m.osName
	if v == nil {
		return
	}
	return *v, true
}

// OldOsName returns the old "osName" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldOsName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsName: %w", err)
	}
	return oldValue.OsName, nil
}

// ClearOsName clears the value of the "osName" field.
func (m *ClientErrorMutation) ClearOsName() {
	m.osName = nil
	m.clearedFields[clienterror.FieldOsName] = struct{}{}
}

// OsNameCleared returns if the "osName" field was cleared in this mutation.
func (m *ClientErrorMutation) OsNameCleared() bool {
	_, ok := m.clearedFields[clienterror.FieldOsName]
	return ok
}

// ResetOsName resets all changes to the "osName" field.
func (m *ClientErrorMutation) ResetOsName() {
	m.osName = nil
	delete(m.clearedFields, clienterror.FieldOsName)
}

// SetErrorInfo sets the "errorInfo" field.
func (m *ClientErrorMutation) SetErrorInfo(s string) {
	m.errorInfo = &s
}

// ErrorInfo returns the value of the "errorInfo" field in the mutation.
func (m *ClientErrorMutation) ErrorInfo() (r string, exists bool) {
	v := m.errorInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorInfo returns the old "errorInfo" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldErrorInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorInfo: %w", err)
	}
	return oldValue.ErrorInfo, nil
}

// ClearErrorInfo clears the value of the "errorInfo" field.
func (m *ClientErrorMutation) ClearErrorInfo() {
	m.errorInfo = nil
	m.clearedFields[clienterror.FieldErrorInfo] = struct{}{}
}

// ErrorInfoCleared returns if the "errorInfo" field was cleared in this mutation.
func (m *ClientErrorMutation) ErrorInfoCleared() bool {
	_, ok := m.clearedFields[clienterror.FieldErrorInfo]
	return ok
}

// ResetErrorInfo resets all changes to the "errorInfo" field.
func (m *ClientErrorMutation) ResetErrorInfo() {
	m.errorInfo = nil
	delete(m.clearedFields, clienterror.FieldErrorInfo)
}

// SetUserId sets the "userId" field.
func (m *ClientErrorMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *ClientErrorMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *ClientErrorMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *ClientErrorMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserId clears the value of the "userId" field.
func (m *ClientErrorMutation) ClearUserId() {
	m.userId = nil
	m.adduserId = nil
	m.clearedFields[clienterror.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *ClientErrorMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[clienterror.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *ClientErrorMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
	delete(m.clearedFields, clienterror.FieldUserId)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ClientErrorMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ClientErrorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ClientErrorMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ClientErrorMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ClientErrorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ClientErrorMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ClientErrorMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ClientErrorMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ClientErrorMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ClientErrorMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ClientErrorMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ClientErrorMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ClientErrorMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ClientErrorMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ClientErrorMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ClientErrorMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ClientErrorMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ClientErrorMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the ClientError entity.
// If the ClientError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientErrorMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ClientErrorMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ClientErrorMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ClientErrorMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the ClientErrorMutation builder.
func (m *ClientErrorMutation) Where(ps ...predicate.ClientError) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClientErrorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClientError).
func (m *ClientErrorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClientErrorMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.appVersion != nil {
		fields = append(fields, clienterror.FieldAppVersion)
	}
	if m.deviceName != nil {
		fields = append(fields, clienterror.FieldDeviceName)
	}
	if m.osName != nil {
		fields = append(fields, clienterror.FieldOsName)
	}
	if m.errorInfo != nil {
		fields = append(fields, clienterror.FieldErrorInfo)
	}
	if m.userId != nil {
		fields = append(fields, clienterror.FieldUserId)
	}
	if m.createdAt != nil {
		fields = append(fields, clienterror.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, clienterror.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, clienterror.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, clienterror.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, clienterror.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClientErrorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clienterror.FieldAppVersion:
		return m.AppVersion()
	case clienterror.FieldDeviceName:
		return m.DeviceName()
	case clienterror.FieldOsName:
		return m.OsName()
	case clienterror.FieldErrorInfo:
		return m.ErrorInfo()
	case clienterror.FieldUserId:
		return m.UserId()
	case clienterror.FieldCreatedAt:
		return m.CreatedAt()
	case clienterror.FieldUpdatedAt:
		return m.UpdatedAt()
	case clienterror.FieldCreateBy:
		return m.CreateBy()
	case clienterror.FieldUpdateBy:
		return m.UpdateBy()
	case clienterror.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClientErrorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clienterror.FieldAppVersion:
		return m.OldAppVersion(ctx)
	case clienterror.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case clienterror.FieldOsName:
		return m.OldOsName(ctx)
	case clienterror.FieldErrorInfo:
		return m.OldErrorInfo(ctx)
	case clienterror.FieldUserId:
		return m.OldUserId(ctx)
	case clienterror.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clienterror.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case clienterror.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case clienterror.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case clienterror.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown ClientError field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientErrorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clienterror.FieldAppVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersion(v)
		return nil
	case clienterror.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case clienterror.FieldOsName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsName(v)
		return nil
	case clienterror.FieldErrorInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorInfo(v)
		return nil
	case clienterror.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case clienterror.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clienterror.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case clienterror.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case clienterror.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case clienterror.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ClientError field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClientErrorMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, clienterror.FieldUserId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, clienterror.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, clienterror.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, clienterror.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClientErrorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case clienterror.FieldUserId:
		return m.AddedUserId()
	case clienterror.FieldCreateBy:
		return m.AddedCreateBy()
	case clienterror.FieldUpdateBy:
		return m.AddedUpdateBy()
	case clienterror.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientErrorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case clienterror.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case clienterror.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case clienterror.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case clienterror.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ClientError numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClientErrorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clienterror.FieldAppVersion) {
		fields = append(fields, clienterror.FieldAppVersion)
	}
	if m.FieldCleared(clienterror.FieldDeviceName) {
		fields = append(fields, clienterror.FieldDeviceName)
	}
	if m.FieldCleared(clienterror.FieldOsName) {
		fields = append(fields, clienterror.FieldOsName)
	}
	if m.FieldCleared(clienterror.FieldErrorInfo) {
		fields = append(fields, clienterror.FieldErrorInfo)
	}
	if m.FieldCleared(clienterror.FieldUserId) {
		fields = append(fields, clienterror.FieldUserId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClientErrorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClientErrorMutation) ClearField(name string) error {
	switch name {
	case clienterror.FieldAppVersion:
		m.ClearAppVersion()
		return nil
	case clienterror.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case clienterror.FieldOsName:
		m.ClearOsName()
		return nil
	case clienterror.FieldErrorInfo:
		m.ClearErrorInfo()
		return nil
	case clienterror.FieldUserId:
		m.ClearUserId()
		return nil
	}
	return fmt.Errorf("unknown ClientError nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClientErrorMutation) ResetField(name string) error {
	switch name {
	case clienterror.FieldAppVersion:
		m.ResetAppVersion()
		return nil
	case clienterror.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case clienterror.FieldOsName:
		m.ResetOsName()
		return nil
	case clienterror.FieldErrorInfo:
		m.ResetErrorInfo()
		return nil
	case clienterror.FieldUserId:
		m.ResetUserId()
		return nil
	case clienterror.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clienterror.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case clienterror.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case clienterror.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case clienterror.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown ClientError field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClientErrorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClientErrorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClientErrorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClientErrorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClientErrorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClientErrorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClientErrorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ClientError unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClientErrorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ClientError edge %s", name)
}

// CustomerNovelConfigMutation represents an operation that mutates the CustomerNovelConfig nodes in the graph.
type CustomerNovelConfigMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	groupCode      *string
	innerGroupCode *string
	groupName      *string
	typeId         *int32
	addtypeId      *int32
	_TypeCode      *string
	typeName       *string
	fieldName      *string
	defaultNum     *int32
	adddefaultNum  *int32
	state          *bool
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CustomerNovelConfig, error)
	predicates     []predicate.CustomerNovelConfig
}

var _ ent.Mutation = (*CustomerNovelConfigMutation)(nil)

// customernovelconfigOption allows management of the mutation configuration using functional options.
type customernovelconfigOption func(*CustomerNovelConfigMutation)

// newCustomerNovelConfigMutation creates new mutation for the CustomerNovelConfig entity.
func newCustomerNovelConfigMutation(c config, op Op, opts ...customernovelconfigOption) *CustomerNovelConfigMutation {
	m := &CustomerNovelConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerNovelConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerNovelConfigID sets the ID field of the mutation.
func withCustomerNovelConfigID(id int64) customernovelconfigOption {
	return func(m *CustomerNovelConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerNovelConfig
		)
		m.oldValue = func(ctx context.Context) (*CustomerNovelConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerNovelConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerNovelConfig sets the old CustomerNovelConfig of the mutation.
func withCustomerNovelConfig(node *CustomerNovelConfig) customernovelconfigOption {
	return func(m *CustomerNovelConfigMutation) {
		m.oldValue = func(context.Context) (*CustomerNovelConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerNovelConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerNovelConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerNovelConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerNovelConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerNovelConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupCode sets the "groupCode" field.
func (m *CustomerNovelConfigMutation) SetGroupCode(s string) {
	m.groupCode = &s
}

// GroupCode returns the value of the "groupCode" field in the mutation.
func (m *CustomerNovelConfigMutation) GroupCode() (r string, exists bool) {
	v := m.groupCode
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupCode returns the old "groupCode" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldGroupCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupCode: %w", err)
	}
	return oldValue.GroupCode, nil
}

// ClearGroupCode clears the value of the "groupCode" field.
func (m *CustomerNovelConfigMutation) ClearGroupCode() {
	m.groupCode = nil
	m.clearedFields[customernovelconfig.FieldGroupCode] = struct{}{}
}

// GroupCodeCleared returns if the "groupCode" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) GroupCodeCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldGroupCode]
	return ok
}

// ResetGroupCode resets all changes to the "groupCode" field.
func (m *CustomerNovelConfigMutation) ResetGroupCode() {
	m.groupCode = nil
	delete(m.clearedFields, customernovelconfig.FieldGroupCode)
}

// SetInnerGroupCode sets the "innerGroupCode" field.
func (m *CustomerNovelConfigMutation) SetInnerGroupCode(s string) {
	m.innerGroupCode = &s
}

// InnerGroupCode returns the value of the "innerGroupCode" field in the mutation.
func (m *CustomerNovelConfigMutation) InnerGroupCode() (r string, exists bool) {
	v := m.innerGroupCode
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerGroupCode returns the old "innerGroupCode" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldInnerGroupCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerGroupCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerGroupCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerGroupCode: %w", err)
	}
	return oldValue.InnerGroupCode, nil
}

// ClearInnerGroupCode clears the value of the "innerGroupCode" field.
func (m *CustomerNovelConfigMutation) ClearInnerGroupCode() {
	m.innerGroupCode = nil
	m.clearedFields[customernovelconfig.FieldInnerGroupCode] = struct{}{}
}

// InnerGroupCodeCleared returns if the "innerGroupCode" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) InnerGroupCodeCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldInnerGroupCode]
	return ok
}

// ResetInnerGroupCode resets all changes to the "innerGroupCode" field.
func (m *CustomerNovelConfigMutation) ResetInnerGroupCode() {
	m.innerGroupCode = nil
	delete(m.clearedFields, customernovelconfig.FieldInnerGroupCode)
}

// SetGroupName sets the "groupName" field.
func (m *CustomerNovelConfigMutation) SetGroupName(s string) {
	m.groupName = &s
}

// GroupName returns the value of the "groupName" field in the mutation.
func (m *CustomerNovelConfigMutation) GroupName() (r string, exists bool) {
	v := m.groupName
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "groupName" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ClearGroupName clears the value of the "groupName" field.
func (m *CustomerNovelConfigMutation) ClearGroupName() {
	m.groupName = nil
	m.clearedFields[customernovelconfig.FieldGroupName] = struct{}{}
}

// GroupNameCleared returns if the "groupName" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) GroupNameCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldGroupName]
	return ok
}

// ResetGroupName resets all changes to the "groupName" field.
func (m *CustomerNovelConfigMutation) ResetGroupName() {
	m.groupName = nil
	delete(m.clearedFields, customernovelconfig.FieldGroupName)
}

// SetTypeId sets the "typeId" field.
func (m *CustomerNovelConfigMutation) SetTypeId(i int32) {
	m.typeId = &i
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *CustomerNovelConfigMutation) TypeId() (r int32, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldTypeId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds i to the "typeId" field.
func (m *CustomerNovelConfigMutation) AddTypeId(i int32) {
	if m.addtypeId != nil {
		*m.addtypeId += i
	} else {
		m.addtypeId = &i
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *CustomerNovelConfigMutation) AddedTypeId() (r int32, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ClearTypeId clears the value of the "typeId" field.
func (m *CustomerNovelConfigMutation) ClearTypeId() {
	m.typeId = nil
	m.addtypeId = nil
	m.clearedFields[customernovelconfig.FieldTypeId] = struct{}{}
}

// TypeIdCleared returns if the "typeId" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) TypeIdCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldTypeId]
	return ok
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *CustomerNovelConfigMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
	delete(m.clearedFields, customernovelconfig.FieldTypeId)
}

// SetTypeCode sets the "TypeCode" field.
func (m *CustomerNovelConfigMutation) SetTypeCode(s string) {
	m._TypeCode = &s
}

// TypeCode returns the value of the "TypeCode" field in the mutation.
func (m *CustomerNovelConfigMutation) TypeCode() (r string, exists bool) {
	v := m._TypeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "TypeCode" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ClearTypeCode clears the value of the "TypeCode" field.
func (m *CustomerNovelConfigMutation) ClearTypeCode() {
	m._TypeCode = nil
	m.clearedFields[customernovelconfig.FieldTypeCode] = struct{}{}
}

// TypeCodeCleared returns if the "TypeCode" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) TypeCodeCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldTypeCode]
	return ok
}

// ResetTypeCode resets all changes to the "TypeCode" field.
func (m *CustomerNovelConfigMutation) ResetTypeCode() {
	m._TypeCode = nil
	delete(m.clearedFields, customernovelconfig.FieldTypeCode)
}

// SetTypeName sets the "typeName" field.
func (m *CustomerNovelConfigMutation) SetTypeName(s string) {
	m.typeName = &s
}

// TypeName returns the value of the "typeName" field in the mutation.
func (m *CustomerNovelConfigMutation) TypeName() (r string, exists bool) {
	v := m.typeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "typeName" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ClearTypeName clears the value of the "typeName" field.
func (m *CustomerNovelConfigMutation) ClearTypeName() {
	m.typeName = nil
	m.clearedFields[customernovelconfig.FieldTypeName] = struct{}{}
}

// TypeNameCleared returns if the "typeName" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) TypeNameCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldTypeName]
	return ok
}

// ResetTypeName resets all changes to the "typeName" field.
func (m *CustomerNovelConfigMutation) ResetTypeName() {
	m.typeName = nil
	delete(m.clearedFields, customernovelconfig.FieldTypeName)
}

// SetFieldName sets the "fieldName" field.
func (m *CustomerNovelConfigMutation) SetFieldName(s string) {
	m.fieldName = &s
}

// FieldName returns the value of the "fieldName" field in the mutation.
func (m *CustomerNovelConfigMutation) FieldName() (r string, exists bool) {
	v := m.fieldName
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldName returns the old "fieldName" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldFieldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldName: %w", err)
	}
	return oldValue.FieldName, nil
}

// ClearFieldName clears the value of the "fieldName" field.
func (m *CustomerNovelConfigMutation) ClearFieldName() {
	m.fieldName = nil
	m.clearedFields[customernovelconfig.FieldFieldName] = struct{}{}
}

// FieldNameCleared returns if the "fieldName" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) FieldNameCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldFieldName]
	return ok
}

// ResetFieldName resets all changes to the "fieldName" field.
func (m *CustomerNovelConfigMutation) ResetFieldName() {
	m.fieldName = nil
	delete(m.clearedFields, customernovelconfig.FieldFieldName)
}

// SetDefaultNum sets the "defaultNum" field.
func (m *CustomerNovelConfigMutation) SetDefaultNum(i int32) {
	m.defaultNum = &i
	m.adddefaultNum = nil
}

// DefaultNum returns the value of the "defaultNum" field in the mutation.
func (m *CustomerNovelConfigMutation) DefaultNum() (r int32, exists bool) {
	v := m.defaultNum
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultNum returns the old "defaultNum" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldDefaultNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultNum: %w", err)
	}
	return oldValue.DefaultNum, nil
}

// AddDefaultNum adds i to the "defaultNum" field.
func (m *CustomerNovelConfigMutation) AddDefaultNum(i int32) {
	if m.adddefaultNum != nil {
		*m.adddefaultNum += i
	} else {
		m.adddefaultNum = &i
	}
}

// AddedDefaultNum returns the value that was added to the "defaultNum" field in this mutation.
func (m *CustomerNovelConfigMutation) AddedDefaultNum() (r int32, exists bool) {
	v := m.adddefaultNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultNum clears the value of the "defaultNum" field.
func (m *CustomerNovelConfigMutation) ClearDefaultNum() {
	m.defaultNum = nil
	m.adddefaultNum = nil
	m.clearedFields[customernovelconfig.FieldDefaultNum] = struct{}{}
}

// DefaultNumCleared returns if the "defaultNum" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) DefaultNumCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldDefaultNum]
	return ok
}

// ResetDefaultNum resets all changes to the "defaultNum" field.
func (m *CustomerNovelConfigMutation) ResetDefaultNum() {
	m.defaultNum = nil
	m.adddefaultNum = nil
	delete(m.clearedFields, customernovelconfig.FieldDefaultNum)
}

// SetState sets the "state" field.
func (m *CustomerNovelConfigMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *CustomerNovelConfigMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *CustomerNovelConfigMutation) ClearState() {
	m.state = nil
	m.clearedFields[customernovelconfig.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *CustomerNovelConfigMutation) StateCleared() bool {
	_, ok := m.clearedFields[customernovelconfig.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *CustomerNovelConfigMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, customernovelconfig.FieldState)
}

// SetCreatedAt sets the "createdAt" field.
func (m *CustomerNovelConfigMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CustomerNovelConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CustomerNovelConfigMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CustomerNovelConfigMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CustomerNovelConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CustomerNovelConfigMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *CustomerNovelConfigMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *CustomerNovelConfigMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *CustomerNovelConfigMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *CustomerNovelConfigMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *CustomerNovelConfigMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *CustomerNovelConfigMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *CustomerNovelConfigMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *CustomerNovelConfigMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *CustomerNovelConfigMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *CustomerNovelConfigMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *CustomerNovelConfigMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *CustomerNovelConfigMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the CustomerNovelConfig entity.
// If the CustomerNovelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelConfigMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *CustomerNovelConfigMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *CustomerNovelConfigMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *CustomerNovelConfigMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the CustomerNovelConfigMutation builder.
func (m *CustomerNovelConfigMutation) Where(ps ...predicate.CustomerNovelConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CustomerNovelConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CustomerNovelConfig).
func (m *CustomerNovelConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerNovelConfigMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.groupCode != nil {
		fields = append(fields, customernovelconfig.FieldGroupCode)
	}
	if m.innerGroupCode != nil {
		fields = append(fields, customernovelconfig.FieldInnerGroupCode)
	}
	if m.groupName != nil {
		fields = append(fields, customernovelconfig.FieldGroupName)
	}
	if m.typeId != nil {
		fields = append(fields, customernovelconfig.FieldTypeId)
	}
	if m._TypeCode != nil {
		fields = append(fields, customernovelconfig.FieldTypeCode)
	}
	if m.typeName != nil {
		fields = append(fields, customernovelconfig.FieldTypeName)
	}
	if m.fieldName != nil {
		fields = append(fields, customernovelconfig.FieldFieldName)
	}
	if m.defaultNum != nil {
		fields = append(fields, customernovelconfig.FieldDefaultNum)
	}
	if m.state != nil {
		fields = append(fields, customernovelconfig.FieldState)
	}
	if m.createdAt != nil {
		fields = append(fields, customernovelconfig.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, customernovelconfig.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, customernovelconfig.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, customernovelconfig.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, customernovelconfig.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerNovelConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customernovelconfig.FieldGroupCode:
		return m.GroupCode()
	case customernovelconfig.FieldInnerGroupCode:
		return m.InnerGroupCode()
	case customernovelconfig.FieldGroupName:
		return m.GroupName()
	case customernovelconfig.FieldTypeId:
		return m.TypeId()
	case customernovelconfig.FieldTypeCode:
		return m.TypeCode()
	case customernovelconfig.FieldTypeName:
		return m.TypeName()
	case customernovelconfig.FieldFieldName:
		return m.FieldName()
	case customernovelconfig.FieldDefaultNum:
		return m.DefaultNum()
	case customernovelconfig.FieldState:
		return m.State()
	case customernovelconfig.FieldCreatedAt:
		return m.CreatedAt()
	case customernovelconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case customernovelconfig.FieldCreateBy:
		return m.CreateBy()
	case customernovelconfig.FieldUpdateBy:
		return m.UpdateBy()
	case customernovelconfig.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerNovelConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customernovelconfig.FieldGroupCode:
		return m.OldGroupCode(ctx)
	case customernovelconfig.FieldInnerGroupCode:
		return m.OldInnerGroupCode(ctx)
	case customernovelconfig.FieldGroupName:
		return m.OldGroupName(ctx)
	case customernovelconfig.FieldTypeId:
		return m.OldTypeId(ctx)
	case customernovelconfig.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case customernovelconfig.FieldTypeName:
		return m.OldTypeName(ctx)
	case customernovelconfig.FieldFieldName:
		return m.OldFieldName(ctx)
	case customernovelconfig.FieldDefaultNum:
		return m.OldDefaultNum(ctx)
	case customernovelconfig.FieldState:
		return m.OldState(ctx)
	case customernovelconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customernovelconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customernovelconfig.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case customernovelconfig.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case customernovelconfig.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerNovelConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerNovelConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customernovelconfig.FieldGroupCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupCode(v)
		return nil
	case customernovelconfig.FieldInnerGroupCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerGroupCode(v)
		return nil
	case customernovelconfig.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case customernovelconfig.FieldTypeId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case customernovelconfig.FieldTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case customernovelconfig.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case customernovelconfig.FieldFieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldName(v)
		return nil
	case customernovelconfig.FieldDefaultNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultNum(v)
		return nil
	case customernovelconfig.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case customernovelconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customernovelconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customernovelconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case customernovelconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case customernovelconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerNovelConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerNovelConfigMutation) AddedFields() []string {
	var fields []string
	if m.addtypeId != nil {
		fields = append(fields, customernovelconfig.FieldTypeId)
	}
	if m.adddefaultNum != nil {
		fields = append(fields, customernovelconfig.FieldDefaultNum)
	}
	if m.addcreateBy != nil {
		fields = append(fields, customernovelconfig.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, customernovelconfig.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, customernovelconfig.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerNovelConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customernovelconfig.FieldTypeId:
		return m.AddedTypeId()
	case customernovelconfig.FieldDefaultNum:
		return m.AddedDefaultNum()
	case customernovelconfig.FieldCreateBy:
		return m.AddedCreateBy()
	case customernovelconfig.FieldUpdateBy:
		return m.AddedUpdateBy()
	case customernovelconfig.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerNovelConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customernovelconfig.FieldTypeId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case customernovelconfig.FieldDefaultNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultNum(v)
		return nil
	case customernovelconfig.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case customernovelconfig.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case customernovelconfig.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerNovelConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerNovelConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customernovelconfig.FieldGroupCode) {
		fields = append(fields, customernovelconfig.FieldGroupCode)
	}
	if m.FieldCleared(customernovelconfig.FieldInnerGroupCode) {
		fields = append(fields, customernovelconfig.FieldInnerGroupCode)
	}
	if m.FieldCleared(customernovelconfig.FieldGroupName) {
		fields = append(fields, customernovelconfig.FieldGroupName)
	}
	if m.FieldCleared(customernovelconfig.FieldTypeId) {
		fields = append(fields, customernovelconfig.FieldTypeId)
	}
	if m.FieldCleared(customernovelconfig.FieldTypeCode) {
		fields = append(fields, customernovelconfig.FieldTypeCode)
	}
	if m.FieldCleared(customernovelconfig.FieldTypeName) {
		fields = append(fields, customernovelconfig.FieldTypeName)
	}
	if m.FieldCleared(customernovelconfig.FieldFieldName) {
		fields = append(fields, customernovelconfig.FieldFieldName)
	}
	if m.FieldCleared(customernovelconfig.FieldDefaultNum) {
		fields = append(fields, customernovelconfig.FieldDefaultNum)
	}
	if m.FieldCleared(customernovelconfig.FieldState) {
		fields = append(fields, customernovelconfig.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerNovelConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerNovelConfigMutation) ClearField(name string) error {
	switch name {
	case customernovelconfig.FieldGroupCode:
		m.ClearGroupCode()
		return nil
	case customernovelconfig.FieldInnerGroupCode:
		m.ClearInnerGroupCode()
		return nil
	case customernovelconfig.FieldGroupName:
		m.ClearGroupName()
		return nil
	case customernovelconfig.FieldTypeId:
		m.ClearTypeId()
		return nil
	case customernovelconfig.FieldTypeCode:
		m.ClearTypeCode()
		return nil
	case customernovelconfig.FieldTypeName:
		m.ClearTypeName()
		return nil
	case customernovelconfig.FieldFieldName:
		m.ClearFieldName()
		return nil
	case customernovelconfig.FieldDefaultNum:
		m.ClearDefaultNum()
		return nil
	case customernovelconfig.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown CustomerNovelConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerNovelConfigMutation) ResetField(name string) error {
	switch name {
	case customernovelconfig.FieldGroupCode:
		m.ResetGroupCode()
		return nil
	case customernovelconfig.FieldInnerGroupCode:
		m.ResetInnerGroupCode()
		return nil
	case customernovelconfig.FieldGroupName:
		m.ResetGroupName()
		return nil
	case customernovelconfig.FieldTypeId:
		m.ResetTypeId()
		return nil
	case customernovelconfig.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case customernovelconfig.FieldTypeName:
		m.ResetTypeName()
		return nil
	case customernovelconfig.FieldFieldName:
		m.ResetFieldName()
		return nil
	case customernovelconfig.FieldDefaultNum:
		m.ResetDefaultNum()
		return nil
	case customernovelconfig.FieldState:
		m.ResetState()
		return nil
	case customernovelconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customernovelconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customernovelconfig.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case customernovelconfig.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case customernovelconfig.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown CustomerNovelConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerNovelConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerNovelConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerNovelConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerNovelConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerNovelConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerNovelConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerNovelConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CustomerNovelConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerNovelConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CustomerNovelConfig edge %s", name)
}

// CustomerNovelsMutation represents an operation that mutates the CustomerNovels nodes in the graph.
type CustomerNovelsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	novelId       *int64
	addnovelId    *int64
	typeId        *int32
	addtypeId     *int32
	typeCode      *string
	groupCode     *string
	fieldName     *string
	cover         *string
	orderNum      *int32
	addorderNum   *int32
	remark        *string
	effectTime    *time.Time
	expiredTime   *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CustomerNovels, error)
	predicates    []predicate.CustomerNovels
}

var _ ent.Mutation = (*CustomerNovelsMutation)(nil)

// customernovelsOption allows management of the mutation configuration using functional options.
type customernovelsOption func(*CustomerNovelsMutation)

// newCustomerNovelsMutation creates new mutation for the CustomerNovels entity.
func newCustomerNovelsMutation(c config, op Op, opts ...customernovelsOption) *CustomerNovelsMutation {
	m := &CustomerNovelsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerNovels,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerNovelsID sets the ID field of the mutation.
func withCustomerNovelsID(id int64) customernovelsOption {
	return func(m *CustomerNovelsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerNovels
		)
		m.oldValue = func(ctx context.Context) (*CustomerNovels, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerNovels.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerNovels sets the old CustomerNovels of the mutation.
func withCustomerNovels(node *CustomerNovels) customernovelsOption {
	return func(m *CustomerNovelsMutation) {
		m.oldValue = func(context.Context) (*CustomerNovels, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerNovelsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerNovelsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerNovelsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerNovelsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerNovels.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNovelId sets the "novelId" field.
func (m *CustomerNovelsMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *CustomerNovelsMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *CustomerNovelsMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *CustomerNovelsMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *CustomerNovelsMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[customernovels.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *CustomerNovelsMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *CustomerNovelsMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, customernovels.FieldNovelId)
}

// SetTypeId sets the "typeId" field.
func (m *CustomerNovelsMutation) SetTypeId(i int32) {
	m.typeId = &i
	m.addtypeId = nil
}

// TypeId returns the value of the "typeId" field in the mutation.
func (m *CustomerNovelsMutation) TypeId() (r int32, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old "typeId" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldTypeId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds i to the "typeId" field.
func (m *CustomerNovelsMutation) AddTypeId(i int32) {
	if m.addtypeId != nil {
		*m.addtypeId += i
	} else {
		m.addtypeId = &i
	}
}

// AddedTypeId returns the value that was added to the "typeId" field in this mutation.
func (m *CustomerNovelsMutation) AddedTypeId() (r int32, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ClearTypeId clears the value of the "typeId" field.
func (m *CustomerNovelsMutation) ClearTypeId() {
	m.typeId = nil
	m.addtypeId = nil
	m.clearedFields[customernovels.FieldTypeId] = struct{}{}
}

// TypeIdCleared returns if the "typeId" field was cleared in this mutation.
func (m *CustomerNovelsMutation) TypeIdCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldTypeId]
	return ok
}

// ResetTypeId resets all changes to the "typeId" field.
func (m *CustomerNovelsMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
	delete(m.clearedFields, customernovels.FieldTypeId)
}

// SetTypeCode sets the "typeCode" field.
func (m *CustomerNovelsMutation) SetTypeCode(s string) {
	m.typeCode = &s
}

// TypeCode returns the value of the "typeCode" field in the mutation.
func (m *CustomerNovelsMutation) TypeCode() (r string, exists bool) {
	v := m.typeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "typeCode" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ClearTypeCode clears the value of the "typeCode" field.
func (m *CustomerNovelsMutation) ClearTypeCode() {
	m.typeCode = nil
	m.clearedFields[customernovels.FieldTypeCode] = struct{}{}
}

// TypeCodeCleared returns if the "typeCode" field was cleared in this mutation.
func (m *CustomerNovelsMutation) TypeCodeCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldTypeCode]
	return ok
}

// ResetTypeCode resets all changes to the "typeCode" field.
func (m *CustomerNovelsMutation) ResetTypeCode() {
	m.typeCode = nil
	delete(m.clearedFields, customernovels.FieldTypeCode)
}

// SetGroupCode sets the "groupCode" field.
func (m *CustomerNovelsMutation) SetGroupCode(s string) {
	m.groupCode = &s
}

// GroupCode returns the value of the "groupCode" field in the mutation.
func (m *CustomerNovelsMutation) GroupCode() (r string, exists bool) {
	v := m.groupCode
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupCode returns the old "groupCode" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldGroupCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupCode: %w", err)
	}
	return oldValue.GroupCode, nil
}

// ClearGroupCode clears the value of the "groupCode" field.
func (m *CustomerNovelsMutation) ClearGroupCode() {
	m.groupCode = nil
	m.clearedFields[customernovels.FieldGroupCode] = struct{}{}
}

// GroupCodeCleared returns if the "groupCode" field was cleared in this mutation.
func (m *CustomerNovelsMutation) GroupCodeCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldGroupCode]
	return ok
}

// ResetGroupCode resets all changes to the "groupCode" field.
func (m *CustomerNovelsMutation) ResetGroupCode() {
	m.groupCode = nil
	delete(m.clearedFields, customernovels.FieldGroupCode)
}

// SetFieldName sets the "fieldName" field.
func (m *CustomerNovelsMutation) SetFieldName(s string) {
	m.fieldName = &s
}

// FieldName returns the value of the "fieldName" field in the mutation.
func (m *CustomerNovelsMutation) FieldName() (r string, exists bool) {
	v := m.fieldName
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldName returns the old "fieldName" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldFieldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldName: %w", err)
	}
	return oldValue.FieldName, nil
}

// ClearFieldName clears the value of the "fieldName" field.
func (m *CustomerNovelsMutation) ClearFieldName() {
	m.fieldName = nil
	m.clearedFields[customernovels.FieldFieldName] = struct{}{}
}

// FieldNameCleared returns if the "fieldName" field was cleared in this mutation.
func (m *CustomerNovelsMutation) FieldNameCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldFieldName]
	return ok
}

// ResetFieldName resets all changes to the "fieldName" field.
func (m *CustomerNovelsMutation) ResetFieldName() {
	m.fieldName = nil
	delete(m.clearedFields, customernovels.FieldFieldName)
}

// SetCover sets the "cover" field.
func (m *CustomerNovelsMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *CustomerNovelsMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ClearCover clears the value of the "cover" field.
func (m *CustomerNovelsMutation) ClearCover() {
	m.cover = nil
	m.clearedFields[customernovels.FieldCover] = struct{}{}
}

// CoverCleared returns if the "cover" field was cleared in this mutation.
func (m *CustomerNovelsMutation) CoverCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldCover]
	return ok
}

// ResetCover resets all changes to the "cover" field.
func (m *CustomerNovelsMutation) ResetCover() {
	m.cover = nil
	delete(m.clearedFields, customernovels.FieldCover)
}

// SetOrderNum sets the "orderNum" field.
func (m *CustomerNovelsMutation) SetOrderNum(i int32) {
	m.orderNum = &i
	m.addorderNum = nil
}

// OrderNum returns the value of the "orderNum" field in the mutation.
func (m *CustomerNovelsMutation) OrderNum() (r int32, exists bool) {
	v := m.orderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNum returns the old "orderNum" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldOrderNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNum: %w", err)
	}
	return oldValue.OrderNum, nil
}

// AddOrderNum adds i to the "orderNum" field.
func (m *CustomerNovelsMutation) AddOrderNum(i int32) {
	if m.addorderNum != nil {
		*m.addorderNum += i
	} else {
		m.addorderNum = &i
	}
}

// AddedOrderNum returns the value that was added to the "orderNum" field in this mutation.
func (m *CustomerNovelsMutation) AddedOrderNum() (r int32, exists bool) {
	v := m.addorderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderNum clears the value of the "orderNum" field.
func (m *CustomerNovelsMutation) ClearOrderNum() {
	m.orderNum = nil
	m.addorderNum = nil
	m.clearedFields[customernovels.FieldOrderNum] = struct{}{}
}

// OrderNumCleared returns if the "orderNum" field was cleared in this mutation.
func (m *CustomerNovelsMutation) OrderNumCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldOrderNum]
	return ok
}

// ResetOrderNum resets all changes to the "orderNum" field.
func (m *CustomerNovelsMutation) ResetOrderNum() {
	m.orderNum = nil
	m.addorderNum = nil
	delete(m.clearedFields, customernovels.FieldOrderNum)
}

// SetRemark sets the "remark" field.
func (m *CustomerNovelsMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CustomerNovelsMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CustomerNovelsMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[customernovels.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CustomerNovelsMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[customernovels.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CustomerNovelsMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, customernovels.FieldRemark)
}

// SetEffectTime sets the "effectTime" field.
func (m *CustomerNovelsMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *CustomerNovelsMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *CustomerNovelsMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *CustomerNovelsMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *CustomerNovelsMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *CustomerNovelsMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *CustomerNovelsMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CustomerNovelsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CustomerNovelsMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CustomerNovelsMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CustomerNovelsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CustomerNovelsMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *CustomerNovelsMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *CustomerNovelsMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *CustomerNovelsMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *CustomerNovelsMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *CustomerNovelsMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *CustomerNovelsMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *CustomerNovelsMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *CustomerNovelsMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *CustomerNovelsMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *CustomerNovelsMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *CustomerNovelsMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *CustomerNovelsMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the CustomerNovels entity.
// If the CustomerNovels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerNovelsMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *CustomerNovelsMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *CustomerNovelsMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *CustomerNovelsMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the CustomerNovelsMutation builder.
func (m *CustomerNovelsMutation) Where(ps ...predicate.CustomerNovels) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CustomerNovelsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CustomerNovels).
func (m *CustomerNovelsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerNovelsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.novelId != nil {
		fields = append(fields, customernovels.FieldNovelId)
	}
	if m.typeId != nil {
		fields = append(fields, customernovels.FieldTypeId)
	}
	if m.typeCode != nil {
		fields = append(fields, customernovels.FieldTypeCode)
	}
	if m.groupCode != nil {
		fields = append(fields, customernovels.FieldGroupCode)
	}
	if m.fieldName != nil {
		fields = append(fields, customernovels.FieldFieldName)
	}
	if m.cover != nil {
		fields = append(fields, customernovels.FieldCover)
	}
	if m.orderNum != nil {
		fields = append(fields, customernovels.FieldOrderNum)
	}
	if m.remark != nil {
		fields = append(fields, customernovels.FieldRemark)
	}
	if m.effectTime != nil {
		fields = append(fields, customernovels.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, customernovels.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, customernovels.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, customernovels.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, customernovels.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, customernovels.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, customernovels.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerNovelsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customernovels.FieldNovelId:
		return m.NovelId()
	case customernovels.FieldTypeId:
		return m.TypeId()
	case customernovels.FieldTypeCode:
		return m.TypeCode()
	case customernovels.FieldGroupCode:
		return m.GroupCode()
	case customernovels.FieldFieldName:
		return m.FieldName()
	case customernovels.FieldCover:
		return m.Cover()
	case customernovels.FieldOrderNum:
		return m.OrderNum()
	case customernovels.FieldRemark:
		return m.Remark()
	case customernovels.FieldEffectTime:
		return m.EffectTime()
	case customernovels.FieldExpiredTime:
		return m.ExpiredTime()
	case customernovels.FieldCreatedAt:
		return m.CreatedAt()
	case customernovels.FieldUpdatedAt:
		return m.UpdatedAt()
	case customernovels.FieldCreateBy:
		return m.CreateBy()
	case customernovels.FieldUpdateBy:
		return m.UpdateBy()
	case customernovels.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerNovelsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customernovels.FieldNovelId:
		return m.OldNovelId(ctx)
	case customernovels.FieldTypeId:
		return m.OldTypeId(ctx)
	case customernovels.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case customernovels.FieldGroupCode:
		return m.OldGroupCode(ctx)
	case customernovels.FieldFieldName:
		return m.OldFieldName(ctx)
	case customernovels.FieldCover:
		return m.OldCover(ctx)
	case customernovels.FieldOrderNum:
		return m.OldOrderNum(ctx)
	case customernovels.FieldRemark:
		return m.OldRemark(ctx)
	case customernovels.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case customernovels.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case customernovels.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customernovels.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customernovels.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case customernovels.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case customernovels.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerNovels field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerNovelsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customernovels.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case customernovels.FieldTypeId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case customernovels.FieldTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case customernovels.FieldGroupCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupCode(v)
		return nil
	case customernovels.FieldFieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldName(v)
		return nil
	case customernovels.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case customernovels.FieldOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNum(v)
		return nil
	case customernovels.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case customernovels.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case customernovels.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case customernovels.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customernovels.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customernovels.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case customernovels.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case customernovels.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerNovels field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerNovelsMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, customernovels.FieldNovelId)
	}
	if m.addtypeId != nil {
		fields = append(fields, customernovels.FieldTypeId)
	}
	if m.addorderNum != nil {
		fields = append(fields, customernovels.FieldOrderNum)
	}
	if m.addcreateBy != nil {
		fields = append(fields, customernovels.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, customernovels.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, customernovels.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerNovelsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customernovels.FieldNovelId:
		return m.AddedNovelId()
	case customernovels.FieldTypeId:
		return m.AddedTypeId()
	case customernovels.FieldOrderNum:
		return m.AddedOrderNum()
	case customernovels.FieldCreateBy:
		return m.AddedCreateBy()
	case customernovels.FieldUpdateBy:
		return m.AddedUpdateBy()
	case customernovels.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerNovelsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customernovels.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case customernovels.FieldTypeId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case customernovels.FieldOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNum(v)
		return nil
	case customernovels.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case customernovels.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case customernovels.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerNovels numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerNovelsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customernovels.FieldNovelId) {
		fields = append(fields, customernovels.FieldNovelId)
	}
	if m.FieldCleared(customernovels.FieldTypeId) {
		fields = append(fields, customernovels.FieldTypeId)
	}
	if m.FieldCleared(customernovels.FieldTypeCode) {
		fields = append(fields, customernovels.FieldTypeCode)
	}
	if m.FieldCleared(customernovels.FieldGroupCode) {
		fields = append(fields, customernovels.FieldGroupCode)
	}
	if m.FieldCleared(customernovels.FieldFieldName) {
		fields = append(fields, customernovels.FieldFieldName)
	}
	if m.FieldCleared(customernovels.FieldCover) {
		fields = append(fields, customernovels.FieldCover)
	}
	if m.FieldCleared(customernovels.FieldOrderNum) {
		fields = append(fields, customernovels.FieldOrderNum)
	}
	if m.FieldCleared(customernovels.FieldRemark) {
		fields = append(fields, customernovels.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerNovelsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerNovelsMutation) ClearField(name string) error {
	switch name {
	case customernovels.FieldNovelId:
		m.ClearNovelId()
		return nil
	case customernovels.FieldTypeId:
		m.ClearTypeId()
		return nil
	case customernovels.FieldTypeCode:
		m.ClearTypeCode()
		return nil
	case customernovels.FieldGroupCode:
		m.ClearGroupCode()
		return nil
	case customernovels.FieldFieldName:
		m.ClearFieldName()
		return nil
	case customernovels.FieldCover:
		m.ClearCover()
		return nil
	case customernovels.FieldOrderNum:
		m.ClearOrderNum()
		return nil
	case customernovels.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown CustomerNovels nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerNovelsMutation) ResetField(name string) error {
	switch name {
	case customernovels.FieldNovelId:
		m.ResetNovelId()
		return nil
	case customernovels.FieldTypeId:
		m.ResetTypeId()
		return nil
	case customernovels.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case customernovels.FieldGroupCode:
		m.ResetGroupCode()
		return nil
	case customernovels.FieldFieldName:
		m.ResetFieldName()
		return nil
	case customernovels.FieldCover:
		m.ResetCover()
		return nil
	case customernovels.FieldOrderNum:
		m.ResetOrderNum()
		return nil
	case customernovels.FieldRemark:
		m.ResetRemark()
		return nil
	case customernovels.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case customernovels.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case customernovels.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customernovels.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customernovels.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case customernovels.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case customernovels.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown CustomerNovels field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerNovelsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerNovelsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerNovelsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerNovelsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerNovelsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerNovelsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerNovelsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CustomerNovels unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerNovelsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CustomerNovels edge %s", name)
}

// DataSourceMutation represents an operation that mutates the DataSource nodes in the graph.
type DataSourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	dbName             *string
	host               *string
	port               *int32
	addport            *int32
	database           *string
	userName           *string
	pwd                *string
	status             *bool
	dbType             *datasource.DbType
	connMaxIdleTime    *int32
	addconnMaxIdleTime *int32
	connMaxLifeTime    *int32
	addconnMaxLifeTime *int32
	maxIdleConns       *int32
	addmaxIdleConns    *int32
	maxOpenConns       *int32
	addmaxOpenConns    *int32
	remark             *string
	createdAt          *time.Time
	updatedAt          *time.Time
	createBy           *int64
	addcreateBy        *int64
	updateBy           *int64
	addupdateBy        *int64
	tenantId           *int64
	addtenantId        *int64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*DataSource, error)
	predicates         []predicate.DataSource
}

var _ ent.Mutation = (*DataSourceMutation)(nil)

// datasourceOption allows management of the mutation configuration using functional options.
type datasourceOption func(*DataSourceMutation)

// newDataSourceMutation creates new mutation for the DataSource entity.
func newDataSourceMutation(c config, op Op, opts ...datasourceOption) *DataSourceMutation {
	m := &DataSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeDataSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataSourceID sets the ID field of the mutation.
func withDataSourceID(id int64) datasourceOption {
	return func(m *DataSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *DataSource
		)
		m.oldValue = func(ctx context.Context) (*DataSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataSource sets the old DataSource of the mutation.
func withDataSource(node *DataSource) datasourceOption {
	return func(m *DataSourceMutation) {
		m.oldValue = func(context.Context) (*DataSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataSourceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataSourceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDbName sets the "dbName" field.
func (m *DataSourceMutation) SetDbName(s string) {
	m.dbName = &s
}

// DbName returns the value of the "dbName" field in the mutation.
func (m *DataSourceMutation) DbName() (r string, exists bool) {
	v := m.dbName
	if v == nil {
		return
	}
	return *v, true
}

// OldDbName returns the old "dbName" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldDbName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbName: %w", err)
	}
	return oldValue.DbName, nil
}

// ClearDbName clears the value of the "dbName" field.
func (m *DataSourceMutation) ClearDbName() {
	m.dbName = nil
	m.clearedFields[datasource.FieldDbName] = struct{}{}
}

// DbNameCleared returns if the "dbName" field was cleared in this mutation.
func (m *DataSourceMutation) DbNameCleared() bool {
	_, ok := m.clearedFields[datasource.FieldDbName]
	return ok
}

// ResetDbName resets all changes to the "dbName" field.
func (m *DataSourceMutation) ResetDbName() {
	m.dbName = nil
	delete(m.clearedFields, datasource.FieldDbName)
}

// SetHost sets the "host" field.
func (m *DataSourceMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *DataSourceMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *DataSourceMutation) ClearHost() {
	m.host = nil
	m.clearedFields[datasource.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *DataSourceMutation) HostCleared() bool {
	_, ok := m.clearedFields[datasource.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *DataSourceMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, datasource.FieldHost)
}

// SetPort sets the "port" field.
func (m *DataSourceMutation) SetPort(i int32) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *DataSourceMutation) Port() (r int32, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldPort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *DataSourceMutation) AddPort(i int32) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *DataSourceMutation) AddedPort() (r int32, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *DataSourceMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[datasource.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *DataSourceMutation) PortCleared() bool {
	_, ok := m.clearedFields[datasource.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *DataSourceMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, datasource.FieldPort)
}

// SetDatabase sets the "database" field.
func (m *DataSourceMutation) SetDatabase(s string) {
	m.database = &s
}

// Database returns the value of the "database" field in the mutation.
func (m *DataSourceMutation) Database() (r string, exists bool) {
	v := m.database
	if v == nil {
		return
	}
	return *v, true
}

// OldDatabase returns the old "database" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldDatabase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatabase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatabase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatabase: %w", err)
	}
	return oldValue.Database, nil
}

// ClearDatabase clears the value of the "database" field.
func (m *DataSourceMutation) ClearDatabase() {
	m.database = nil
	m.clearedFields[datasource.FieldDatabase] = struct{}{}
}

// DatabaseCleared returns if the "database" field was cleared in this mutation.
func (m *DataSourceMutation) DatabaseCleared() bool {
	_, ok := m.clearedFields[datasource.FieldDatabase]
	return ok
}

// ResetDatabase resets all changes to the "database" field.
func (m *DataSourceMutation) ResetDatabase() {
	m.database = nil
	delete(m.clearedFields, datasource.FieldDatabase)
}

// SetUserName sets the "userName" field.
func (m *DataSourceMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *DataSourceMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *DataSourceMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[datasource.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *DataSourceMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[datasource.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *DataSourceMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, datasource.FieldUserName)
}

// SetPwd sets the "pwd" field.
func (m *DataSourceMutation) SetPwd(s string) {
	m.pwd = &s
}

// Pwd returns the value of the "pwd" field in the mutation.
func (m *DataSourceMutation) Pwd() (r string, exists bool) {
	v := m.pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPwd returns the old "pwd" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPwd: %w", err)
	}
	return oldValue.Pwd, nil
}

// ClearPwd clears the value of the "pwd" field.
func (m *DataSourceMutation) ClearPwd() {
	m.pwd = nil
	m.clearedFields[datasource.FieldPwd] = struct{}{}
}

// PwdCleared returns if the "pwd" field was cleared in this mutation.
func (m *DataSourceMutation) PwdCleared() bool {
	_, ok := m.clearedFields[datasource.FieldPwd]
	return ok
}

// ResetPwd resets all changes to the "pwd" field.
func (m *DataSourceMutation) ResetPwd() {
	m.pwd = nil
	delete(m.clearedFields, datasource.FieldPwd)
}

// SetStatus sets the "status" field.
func (m *DataSourceMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *DataSourceMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DataSourceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[datasource.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DataSourceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[datasource.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DataSourceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, datasource.FieldStatus)
}

// SetDbType sets the "dbType" field.
func (m *DataSourceMutation) SetDbType(dt datasource.DbType) {
	m.dbType = &dt
}

// DbType returns the value of the "dbType" field in the mutation.
func (m *DataSourceMutation) DbType() (r datasource.DbType, exists bool) {
	v := m.dbType
	if v == nil {
		return
	}
	return *v, true
}

// OldDbType returns the old "dbType" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldDbType(ctx context.Context) (v datasource.DbType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbType: %w", err)
	}
	return oldValue.DbType, nil
}

// ClearDbType clears the value of the "dbType" field.
func (m *DataSourceMutation) ClearDbType() {
	m.dbType = nil
	m.clearedFields[datasource.FieldDbType] = struct{}{}
}

// DbTypeCleared returns if the "dbType" field was cleared in this mutation.
func (m *DataSourceMutation) DbTypeCleared() bool {
	_, ok := m.clearedFields[datasource.FieldDbType]
	return ok
}

// ResetDbType resets all changes to the "dbType" field.
func (m *DataSourceMutation) ResetDbType() {
	m.dbType = nil
	delete(m.clearedFields, datasource.FieldDbType)
}

// SetConnMaxIdleTime sets the "connMaxIdleTime" field.
func (m *DataSourceMutation) SetConnMaxIdleTime(i int32) {
	m.connMaxIdleTime = &i
	m.addconnMaxIdleTime = nil
}

// ConnMaxIdleTime returns the value of the "connMaxIdleTime" field in the mutation.
func (m *DataSourceMutation) ConnMaxIdleTime() (r int32, exists bool) {
	v := m.connMaxIdleTime
	if v == nil {
		return
	}
	return *v, true
}

// OldConnMaxIdleTime returns the old "connMaxIdleTime" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldConnMaxIdleTime(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnMaxIdleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnMaxIdleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnMaxIdleTime: %w", err)
	}
	return oldValue.ConnMaxIdleTime, nil
}

// AddConnMaxIdleTime adds i to the "connMaxIdleTime" field.
func (m *DataSourceMutation) AddConnMaxIdleTime(i int32) {
	if m.addconnMaxIdleTime != nil {
		*m.addconnMaxIdleTime += i
	} else {
		m.addconnMaxIdleTime = &i
	}
}

// AddedConnMaxIdleTime returns the value that was added to the "connMaxIdleTime" field in this mutation.
func (m *DataSourceMutation) AddedConnMaxIdleTime() (r int32, exists bool) {
	v := m.addconnMaxIdleTime
	if v == nil {
		return
	}
	return *v, true
}

// ClearConnMaxIdleTime clears the value of the "connMaxIdleTime" field.
func (m *DataSourceMutation) ClearConnMaxIdleTime() {
	m.connMaxIdleTime = nil
	m.addconnMaxIdleTime = nil
	m.clearedFields[datasource.FieldConnMaxIdleTime] = struct{}{}
}

// ConnMaxIdleTimeCleared returns if the "connMaxIdleTime" field was cleared in this mutation.
func (m *DataSourceMutation) ConnMaxIdleTimeCleared() bool {
	_, ok := m.clearedFields[datasource.FieldConnMaxIdleTime]
	return ok
}

// ResetConnMaxIdleTime resets all changes to the "connMaxIdleTime" field.
func (m *DataSourceMutation) ResetConnMaxIdleTime() {
	m.connMaxIdleTime = nil
	m.addconnMaxIdleTime = nil
	delete(m.clearedFields, datasource.FieldConnMaxIdleTime)
}

// SetConnMaxLifeTime sets the "connMaxLifeTime" field.
func (m *DataSourceMutation) SetConnMaxLifeTime(i int32) {
	m.connMaxLifeTime = &i
	m.addconnMaxLifeTime = nil
}

// ConnMaxLifeTime returns the value of the "connMaxLifeTime" field in the mutation.
func (m *DataSourceMutation) ConnMaxLifeTime() (r int32, exists bool) {
	v := m.connMaxLifeTime
	if v == nil {
		return
	}
	return *v, true
}

// OldConnMaxLifeTime returns the old "connMaxLifeTime" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldConnMaxLifeTime(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnMaxLifeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnMaxLifeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnMaxLifeTime: %w", err)
	}
	return oldValue.ConnMaxLifeTime, nil
}

// AddConnMaxLifeTime adds i to the "connMaxLifeTime" field.
func (m *DataSourceMutation) AddConnMaxLifeTime(i int32) {
	if m.addconnMaxLifeTime != nil {
		*m.addconnMaxLifeTime += i
	} else {
		m.addconnMaxLifeTime = &i
	}
}

// AddedConnMaxLifeTime returns the value that was added to the "connMaxLifeTime" field in this mutation.
func (m *DataSourceMutation) AddedConnMaxLifeTime() (r int32, exists bool) {
	v := m.addconnMaxLifeTime
	if v == nil {
		return
	}
	return *v, true
}

// ClearConnMaxLifeTime clears the value of the "connMaxLifeTime" field.
func (m *DataSourceMutation) ClearConnMaxLifeTime() {
	m.connMaxLifeTime = nil
	m.addconnMaxLifeTime = nil
	m.clearedFields[datasource.FieldConnMaxLifeTime] = struct{}{}
}

// ConnMaxLifeTimeCleared returns if the "connMaxLifeTime" field was cleared in this mutation.
func (m *DataSourceMutation) ConnMaxLifeTimeCleared() bool {
	_, ok := m.clearedFields[datasource.FieldConnMaxLifeTime]
	return ok
}

// ResetConnMaxLifeTime resets all changes to the "connMaxLifeTime" field.
func (m *DataSourceMutation) ResetConnMaxLifeTime() {
	m.connMaxLifeTime = nil
	m.addconnMaxLifeTime = nil
	delete(m.clearedFields, datasource.FieldConnMaxLifeTime)
}

// SetMaxIdleConns sets the "maxIdleConns" field.
func (m *DataSourceMutation) SetMaxIdleConns(i int32) {
	m.maxIdleConns = &i
	m.addmaxIdleConns = nil
}

// MaxIdleConns returns the value of the "maxIdleConns" field in the mutation.
func (m *DataSourceMutation) MaxIdleConns() (r int32, exists bool) {
	v := m.maxIdleConns
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxIdleConns returns the old "maxIdleConns" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldMaxIdleConns(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxIdleConns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxIdleConns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxIdleConns: %w", err)
	}
	return oldValue.MaxIdleConns, nil
}

// AddMaxIdleConns adds i to the "maxIdleConns" field.
func (m *DataSourceMutation) AddMaxIdleConns(i int32) {
	if m.addmaxIdleConns != nil {
		*m.addmaxIdleConns += i
	} else {
		m.addmaxIdleConns = &i
	}
}

// AddedMaxIdleConns returns the value that was added to the "maxIdleConns" field in this mutation.
func (m *DataSourceMutation) AddedMaxIdleConns() (r int32, exists bool) {
	v := m.addmaxIdleConns
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxIdleConns clears the value of the "maxIdleConns" field.
func (m *DataSourceMutation) ClearMaxIdleConns() {
	m.maxIdleConns = nil
	m.addmaxIdleConns = nil
	m.clearedFields[datasource.FieldMaxIdleConns] = struct{}{}
}

// MaxIdleConnsCleared returns if the "maxIdleConns" field was cleared in this mutation.
func (m *DataSourceMutation) MaxIdleConnsCleared() bool {
	_, ok := m.clearedFields[datasource.FieldMaxIdleConns]
	return ok
}

// ResetMaxIdleConns resets all changes to the "maxIdleConns" field.
func (m *DataSourceMutation) ResetMaxIdleConns() {
	m.maxIdleConns = nil
	m.addmaxIdleConns = nil
	delete(m.clearedFields, datasource.FieldMaxIdleConns)
}

// SetMaxOpenConns sets the "maxOpenConns" field.
func (m *DataSourceMutation) SetMaxOpenConns(i int32) {
	m.maxOpenConns = &i
	m.addmaxOpenConns = nil
}

// MaxOpenConns returns the value of the "maxOpenConns" field in the mutation.
func (m *DataSourceMutation) MaxOpenConns() (r int32, exists bool) {
	v := m.maxOpenConns
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxOpenConns returns the old "maxOpenConns" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldMaxOpenConns(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxOpenConns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxOpenConns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxOpenConns: %w", err)
	}
	return oldValue.MaxOpenConns, nil
}

// AddMaxOpenConns adds i to the "maxOpenConns" field.
func (m *DataSourceMutation) AddMaxOpenConns(i int32) {
	if m.addmaxOpenConns != nil {
		*m.addmaxOpenConns += i
	} else {
		m.addmaxOpenConns = &i
	}
}

// AddedMaxOpenConns returns the value that was added to the "maxOpenConns" field in this mutation.
func (m *DataSourceMutation) AddedMaxOpenConns() (r int32, exists bool) {
	v := m.addmaxOpenConns
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxOpenConns clears the value of the "maxOpenConns" field.
func (m *DataSourceMutation) ClearMaxOpenConns() {
	m.maxOpenConns = nil
	m.addmaxOpenConns = nil
	m.clearedFields[datasource.FieldMaxOpenConns] = struct{}{}
}

// MaxOpenConnsCleared returns if the "maxOpenConns" field was cleared in this mutation.
func (m *DataSourceMutation) MaxOpenConnsCleared() bool {
	_, ok := m.clearedFields[datasource.FieldMaxOpenConns]
	return ok
}

// ResetMaxOpenConns resets all changes to the "maxOpenConns" field.
func (m *DataSourceMutation) ResetMaxOpenConns() {
	m.maxOpenConns = nil
	m.addmaxOpenConns = nil
	delete(m.clearedFields, datasource.FieldMaxOpenConns)
}

// SetRemark sets the "remark" field.
func (m *DataSourceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *DataSourceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *DataSourceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[datasource.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *DataSourceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[datasource.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *DataSourceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, datasource.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *DataSourceMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *DataSourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *DataSourceMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *DataSourceMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *DataSourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *DataSourceMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *DataSourceMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *DataSourceMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *DataSourceMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *DataSourceMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *DataSourceMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *DataSourceMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *DataSourceMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *DataSourceMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *DataSourceMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *DataSourceMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *DataSourceMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *DataSourceMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *DataSourceMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *DataSourceMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *DataSourceMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the DataSourceMutation builder.
func (m *DataSourceMutation) Where(ps ...predicate.DataSource) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DataSourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DataSource).
func (m *DataSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataSourceMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.dbName != nil {
		fields = append(fields, datasource.FieldDbName)
	}
	if m.host != nil {
		fields = append(fields, datasource.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, datasource.FieldPort)
	}
	if m.database != nil {
		fields = append(fields, datasource.FieldDatabase)
	}
	if m.userName != nil {
		fields = append(fields, datasource.FieldUserName)
	}
	if m.pwd != nil {
		fields = append(fields, datasource.FieldPwd)
	}
	if m.status != nil {
		fields = append(fields, datasource.FieldStatus)
	}
	if m.dbType != nil {
		fields = append(fields, datasource.FieldDbType)
	}
	if m.connMaxIdleTime != nil {
		fields = append(fields, datasource.FieldConnMaxIdleTime)
	}
	if m.connMaxLifeTime != nil {
		fields = append(fields, datasource.FieldConnMaxLifeTime)
	}
	if m.maxIdleConns != nil {
		fields = append(fields, datasource.FieldMaxIdleConns)
	}
	if m.maxOpenConns != nil {
		fields = append(fields, datasource.FieldMaxOpenConns)
	}
	if m.remark != nil {
		fields = append(fields, datasource.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, datasource.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, datasource.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, datasource.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, datasource.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, datasource.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case datasource.FieldDbName:
		return m.DbName()
	case datasource.FieldHost:
		return m.Host()
	case datasource.FieldPort:
		return m.Port()
	case datasource.FieldDatabase:
		return m.Database()
	case datasource.FieldUserName:
		return m.UserName()
	case datasource.FieldPwd:
		return m.Pwd()
	case datasource.FieldStatus:
		return m.Status()
	case datasource.FieldDbType:
		return m.DbType()
	case datasource.FieldConnMaxIdleTime:
		return m.ConnMaxIdleTime()
	case datasource.FieldConnMaxLifeTime:
		return m.ConnMaxLifeTime()
	case datasource.FieldMaxIdleConns:
		return m.MaxIdleConns()
	case datasource.FieldMaxOpenConns:
		return m.MaxOpenConns()
	case datasource.FieldRemark:
		return m.Remark()
	case datasource.FieldCreatedAt:
		return m.CreatedAt()
	case datasource.FieldUpdatedAt:
		return m.UpdatedAt()
	case datasource.FieldCreateBy:
		return m.CreateBy()
	case datasource.FieldUpdateBy:
		return m.UpdateBy()
	case datasource.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case datasource.FieldDbName:
		return m.OldDbName(ctx)
	case datasource.FieldHost:
		return m.OldHost(ctx)
	case datasource.FieldPort:
		return m.OldPort(ctx)
	case datasource.FieldDatabase:
		return m.OldDatabase(ctx)
	case datasource.FieldUserName:
		return m.OldUserName(ctx)
	case datasource.FieldPwd:
		return m.OldPwd(ctx)
	case datasource.FieldStatus:
		return m.OldStatus(ctx)
	case datasource.FieldDbType:
		return m.OldDbType(ctx)
	case datasource.FieldConnMaxIdleTime:
		return m.OldConnMaxIdleTime(ctx)
	case datasource.FieldConnMaxLifeTime:
		return m.OldConnMaxLifeTime(ctx)
	case datasource.FieldMaxIdleConns:
		return m.OldMaxIdleConns(ctx)
	case datasource.FieldMaxOpenConns:
		return m.OldMaxOpenConns(ctx)
	case datasource.FieldRemark:
		return m.OldRemark(ctx)
	case datasource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case datasource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case datasource.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case datasource.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case datasource.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown DataSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case datasource.FieldDbName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbName(v)
		return nil
	case datasource.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case datasource.FieldPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case datasource.FieldDatabase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatabase(v)
		return nil
	case datasource.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case datasource.FieldPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPwd(v)
		return nil
	case datasource.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case datasource.FieldDbType:
		v, ok := value.(datasource.DbType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbType(v)
		return nil
	case datasource.FieldConnMaxIdleTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnMaxIdleTime(v)
		return nil
	case datasource.FieldConnMaxLifeTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnMaxLifeTime(v)
		return nil
	case datasource.FieldMaxIdleConns:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxIdleConns(v)
		return nil
	case datasource.FieldMaxOpenConns:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxOpenConns(v)
		return nil
	case datasource.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case datasource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case datasource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case datasource.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case datasource.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case datasource.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown DataSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataSourceMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, datasource.FieldPort)
	}
	if m.addconnMaxIdleTime != nil {
		fields = append(fields, datasource.FieldConnMaxIdleTime)
	}
	if m.addconnMaxLifeTime != nil {
		fields = append(fields, datasource.FieldConnMaxLifeTime)
	}
	if m.addmaxIdleConns != nil {
		fields = append(fields, datasource.FieldMaxIdleConns)
	}
	if m.addmaxOpenConns != nil {
		fields = append(fields, datasource.FieldMaxOpenConns)
	}
	if m.addcreateBy != nil {
		fields = append(fields, datasource.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, datasource.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, datasource.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataSourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case datasource.FieldPort:
		return m.AddedPort()
	case datasource.FieldConnMaxIdleTime:
		return m.AddedConnMaxIdleTime()
	case datasource.FieldConnMaxLifeTime:
		return m.AddedConnMaxLifeTime()
	case datasource.FieldMaxIdleConns:
		return m.AddedMaxIdleConns()
	case datasource.FieldMaxOpenConns:
		return m.AddedMaxOpenConns()
	case datasource.FieldCreateBy:
		return m.AddedCreateBy()
	case datasource.FieldUpdateBy:
		return m.AddedUpdateBy()
	case datasource.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case datasource.FieldPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case datasource.FieldConnMaxIdleTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnMaxIdleTime(v)
		return nil
	case datasource.FieldConnMaxLifeTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnMaxLifeTime(v)
		return nil
	case datasource.FieldMaxIdleConns:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxIdleConns(v)
		return nil
	case datasource.FieldMaxOpenConns:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxOpenConns(v)
		return nil
	case datasource.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case datasource.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case datasource.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown DataSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataSourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(datasource.FieldDbName) {
		fields = append(fields, datasource.FieldDbName)
	}
	if m.FieldCleared(datasource.FieldHost) {
		fields = append(fields, datasource.FieldHost)
	}
	if m.FieldCleared(datasource.FieldPort) {
		fields = append(fields, datasource.FieldPort)
	}
	if m.FieldCleared(datasource.FieldDatabase) {
		fields = append(fields, datasource.FieldDatabase)
	}
	if m.FieldCleared(datasource.FieldUserName) {
		fields = append(fields, datasource.FieldUserName)
	}
	if m.FieldCleared(datasource.FieldPwd) {
		fields = append(fields, datasource.FieldPwd)
	}
	if m.FieldCleared(datasource.FieldStatus) {
		fields = append(fields, datasource.FieldStatus)
	}
	if m.FieldCleared(datasource.FieldDbType) {
		fields = append(fields, datasource.FieldDbType)
	}
	if m.FieldCleared(datasource.FieldConnMaxIdleTime) {
		fields = append(fields, datasource.FieldConnMaxIdleTime)
	}
	if m.FieldCleared(datasource.FieldConnMaxLifeTime) {
		fields = append(fields, datasource.FieldConnMaxLifeTime)
	}
	if m.FieldCleared(datasource.FieldMaxIdleConns) {
		fields = append(fields, datasource.FieldMaxIdleConns)
	}
	if m.FieldCleared(datasource.FieldMaxOpenConns) {
		fields = append(fields, datasource.FieldMaxOpenConns)
	}
	if m.FieldCleared(datasource.FieldRemark) {
		fields = append(fields, datasource.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataSourceMutation) ClearField(name string) error {
	switch name {
	case datasource.FieldDbName:
		m.ClearDbName()
		return nil
	case datasource.FieldHost:
		m.ClearHost()
		return nil
	case datasource.FieldPort:
		m.ClearPort()
		return nil
	case datasource.FieldDatabase:
		m.ClearDatabase()
		return nil
	case datasource.FieldUserName:
		m.ClearUserName()
		return nil
	case datasource.FieldPwd:
		m.ClearPwd()
		return nil
	case datasource.FieldStatus:
		m.ClearStatus()
		return nil
	case datasource.FieldDbType:
		m.ClearDbType()
		return nil
	case datasource.FieldConnMaxIdleTime:
		m.ClearConnMaxIdleTime()
		return nil
	case datasource.FieldConnMaxLifeTime:
		m.ClearConnMaxLifeTime()
		return nil
	case datasource.FieldMaxIdleConns:
		m.ClearMaxIdleConns()
		return nil
	case datasource.FieldMaxOpenConns:
		m.ClearMaxOpenConns()
		return nil
	case datasource.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown DataSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataSourceMutation) ResetField(name string) error {
	switch name {
	case datasource.FieldDbName:
		m.ResetDbName()
		return nil
	case datasource.FieldHost:
		m.ResetHost()
		return nil
	case datasource.FieldPort:
		m.ResetPort()
		return nil
	case datasource.FieldDatabase:
		m.ResetDatabase()
		return nil
	case datasource.FieldUserName:
		m.ResetUserName()
		return nil
	case datasource.FieldPwd:
		m.ResetPwd()
		return nil
	case datasource.FieldStatus:
		m.ResetStatus()
		return nil
	case datasource.FieldDbType:
		m.ResetDbType()
		return nil
	case datasource.FieldConnMaxIdleTime:
		m.ResetConnMaxIdleTime()
		return nil
	case datasource.FieldConnMaxLifeTime:
		m.ResetConnMaxLifeTime()
		return nil
	case datasource.FieldMaxIdleConns:
		m.ResetMaxIdleConns()
		return nil
	case datasource.FieldMaxOpenConns:
		m.ResetMaxOpenConns()
		return nil
	case datasource.FieldRemark:
		m.ResetRemark()
		return nil
	case datasource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case datasource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case datasource.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case datasource.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case datasource.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown DataSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataSourceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataSourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataSourceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataSourceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DataSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataSourceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DataSource edge %s", name)
}

// ListenRecordMutation represents an operation that mutates the ListenRecord nodes in the graph.
type ListenRecordMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	chapterId      *int64
	addchapterId   *int64
	novelId        *int64
	addnovelId     *int64
	listenTimes    *int64
	addlistenTimes *int64
	duration       *time.Duration
	addduration    *time.Duration
	allDuration    *time.Duration
	addallDuration *time.Duration
	dayDuration    *time.Duration
	adddayDuration *time.Duration
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ListenRecord, error)
	predicates     []predicate.ListenRecord
}

var _ ent.Mutation = (*ListenRecordMutation)(nil)

// listenrecordOption allows management of the mutation configuration using functional options.
type listenrecordOption func(*ListenRecordMutation)

// newListenRecordMutation creates new mutation for the ListenRecord entity.
func newListenRecordMutation(c config, op Op, opts ...listenrecordOption) *ListenRecordMutation {
	m := &ListenRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeListenRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withListenRecordID sets the ID field of the mutation.
func withListenRecordID(id int64) listenrecordOption {
	return func(m *ListenRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ListenRecord
		)
		m.oldValue = func(ctx context.Context) (*ListenRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ListenRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withListenRecord sets the old ListenRecord of the mutation.
func withListenRecord(node *ListenRecord) listenrecordOption {
	return func(m *ListenRecordMutation) {
		m.oldValue = func(context.Context) (*ListenRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ListenRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ListenRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ListenRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ListenRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ListenRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *ListenRecordMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *ListenRecordMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *ListenRecordMutation) ResetUserId() {
	m.user = nil
}

// SetChapterId sets the "chapterId" field.
func (m *ListenRecordMutation) SetChapterId(i int64) {
	m.chapterId = &i
	m.addchapterId = nil
}

// ChapterId returns the value of the "chapterId" field in the mutation.
func (m *ListenRecordMutation) ChapterId() (r int64, exists bool) {
	v := m.chapterId
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterId returns the old "chapterId" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldChapterId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterId: %w", err)
	}
	return oldValue.ChapterId, nil
}

// AddChapterId adds i to the "chapterId" field.
func (m *ListenRecordMutation) AddChapterId(i int64) {
	if m.addchapterId != nil {
		*m.addchapterId += i
	} else {
		m.addchapterId = &i
	}
}

// AddedChapterId returns the value that was added to the "chapterId" field in this mutation.
func (m *ListenRecordMutation) AddedChapterId() (r int64, exists bool) {
	v := m.addchapterId
	if v == nil {
		return
	}
	return *v, true
}

// ResetChapterId resets all changes to the "chapterId" field.
func (m *ListenRecordMutation) ResetChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
}

// SetNovelId sets the "novelId" field.
func (m *ListenRecordMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *ListenRecordMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *ListenRecordMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *ListenRecordMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *ListenRecordMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[listenrecord.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *ListenRecordMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[listenrecord.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *ListenRecordMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, listenrecord.FieldNovelId)
}

// SetListenTimes sets the "listenTimes" field.
func (m *ListenRecordMutation) SetListenTimes(i int64) {
	m.listenTimes = &i
	m.addlistenTimes = nil
}

// ListenTimes returns the value of the "listenTimes" field in the mutation.
func (m *ListenRecordMutation) ListenTimes() (r int64, exists bool) {
	v := m.listenTimes
	if v == nil {
		return
	}
	return *v, true
}

// OldListenTimes returns the old "listenTimes" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldListenTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListenTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListenTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListenTimes: %w", err)
	}
	return oldValue.ListenTimes, nil
}

// AddListenTimes adds i to the "listenTimes" field.
func (m *ListenRecordMutation) AddListenTimes(i int64) {
	if m.addlistenTimes != nil {
		*m.addlistenTimes += i
	} else {
		m.addlistenTimes = &i
	}
}

// AddedListenTimes returns the value that was added to the "listenTimes" field in this mutation.
func (m *ListenRecordMutation) AddedListenTimes() (r int64, exists bool) {
	v := m.addlistenTimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearListenTimes clears the value of the "listenTimes" field.
func (m *ListenRecordMutation) ClearListenTimes() {
	m.listenTimes = nil
	m.addlistenTimes = nil
	m.clearedFields[listenrecord.FieldListenTimes] = struct{}{}
}

// ListenTimesCleared returns if the "listenTimes" field was cleared in this mutation.
func (m *ListenRecordMutation) ListenTimesCleared() bool {
	_, ok := m.clearedFields[listenrecord.FieldListenTimes]
	return ok
}

// ResetListenTimes resets all changes to the "listenTimes" field.
func (m *ListenRecordMutation) ResetListenTimes() {
	m.listenTimes = nil
	m.addlistenTimes = nil
	delete(m.clearedFields, listenrecord.FieldListenTimes)
}

// SetDuration sets the "duration" field.
func (m *ListenRecordMutation) SetDuration(t time.Duration) {
	m.duration = &t
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ListenRecordMutation) Duration() (r time.Duration, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldDuration(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds t to the "duration" field.
func (m *ListenRecordMutation) AddDuration(t time.Duration) {
	if m.addduration != nil {
		*m.addduration += t
	} else {
		m.addduration = &t
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ListenRecordMutation) AddedDuration() (r time.Duration, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ListenRecordMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[listenrecord.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ListenRecordMutation) DurationCleared() bool {
	_, ok := m.clearedFields[listenrecord.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ListenRecordMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, listenrecord.FieldDuration)
}

// SetAllDuration sets the "allDuration" field.
func (m *ListenRecordMutation) SetAllDuration(t time.Duration) {
	m.allDuration = &t
	m.addallDuration = nil
}

// AllDuration returns the value of the "allDuration" field in the mutation.
func (m *ListenRecordMutation) AllDuration() (r time.Duration, exists bool) {
	v := m.allDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldAllDuration returns the old "allDuration" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldAllDuration(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllDuration: %w", err)
	}
	return oldValue.AllDuration, nil
}

// AddAllDuration adds t to the "allDuration" field.
func (m *ListenRecordMutation) AddAllDuration(t time.Duration) {
	if m.addallDuration != nil {
		*m.addallDuration += t
	} else {
		m.addallDuration = &t
	}
}

// AddedAllDuration returns the value that was added to the "allDuration" field in this mutation.
func (m *ListenRecordMutation) AddedAllDuration() (r time.Duration, exists bool) {
	v := m.addallDuration
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllDuration clears the value of the "allDuration" field.
func (m *ListenRecordMutation) ClearAllDuration() {
	m.allDuration = nil
	m.addallDuration = nil
	m.clearedFields[listenrecord.FieldAllDuration] = struct{}{}
}

// AllDurationCleared returns if the "allDuration" field was cleared in this mutation.
func (m *ListenRecordMutation) AllDurationCleared() bool {
	_, ok := m.clearedFields[listenrecord.FieldAllDuration]
	return ok
}

// ResetAllDuration resets all changes to the "allDuration" field.
func (m *ListenRecordMutation) ResetAllDuration() {
	m.allDuration = nil
	m.addallDuration = nil
	delete(m.clearedFields, listenrecord.FieldAllDuration)
}

// SetDayDuration sets the "dayDuration" field.
func (m *ListenRecordMutation) SetDayDuration(t time.Duration) {
	m.dayDuration = &t
	m.adddayDuration = nil
}

// DayDuration returns the value of the "dayDuration" field in the mutation.
func (m *ListenRecordMutation) DayDuration() (r time.Duration, exists bool) {
	v := m.dayDuration
	if v == nil {
		return
	}
	return *v, true
}

// OldDayDuration returns the old "dayDuration" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldDayDuration(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayDuration: %w", err)
	}
	return oldValue.DayDuration, nil
}

// AddDayDuration adds t to the "dayDuration" field.
func (m *ListenRecordMutation) AddDayDuration(t time.Duration) {
	if m.adddayDuration != nil {
		*m.adddayDuration += t
	} else {
		m.adddayDuration = &t
	}
}

// AddedDayDuration returns the value that was added to the "dayDuration" field in this mutation.
func (m *ListenRecordMutation) AddedDayDuration() (r time.Duration, exists bool) {
	v := m.adddayDuration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayDuration clears the value of the "dayDuration" field.
func (m *ListenRecordMutation) ClearDayDuration() {
	m.dayDuration = nil
	m.adddayDuration = nil
	m.clearedFields[listenrecord.FieldDayDuration] = struct{}{}
}

// DayDurationCleared returns if the "dayDuration" field was cleared in this mutation.
func (m *ListenRecordMutation) DayDurationCleared() bool {
	_, ok := m.clearedFields[listenrecord.FieldDayDuration]
	return ok
}

// ResetDayDuration resets all changes to the "dayDuration" field.
func (m *ListenRecordMutation) ResetDayDuration() {
	m.dayDuration = nil
	m.adddayDuration = nil
	delete(m.clearedFields, listenrecord.FieldDayDuration)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ListenRecordMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ListenRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ListenRecordMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ListenRecordMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ListenRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ListenRecordMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *ListenRecordMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *ListenRecordMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *ListenRecordMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *ListenRecordMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *ListenRecordMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *ListenRecordMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *ListenRecordMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *ListenRecordMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *ListenRecordMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *ListenRecordMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *ListenRecordMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *ListenRecordMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the ListenRecord entity.
// If the ListenRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenRecordMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *ListenRecordMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *ListenRecordMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *ListenRecordMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *ListenRecordMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *ListenRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *ListenRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ListenRecordMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ListenRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ListenRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ListenRecordMutation builder.
func (m *ListenRecordMutation) Where(ps ...predicate.ListenRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ListenRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ListenRecord).
func (m *ListenRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ListenRecordMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, listenrecord.FieldUserId)
	}
	if m.chapterId != nil {
		fields = append(fields, listenrecord.FieldChapterId)
	}
	if m.novelId != nil {
		fields = append(fields, listenrecord.FieldNovelId)
	}
	if m.listenTimes != nil {
		fields = append(fields, listenrecord.FieldListenTimes)
	}
	if m.duration != nil {
		fields = append(fields, listenrecord.FieldDuration)
	}
	if m.allDuration != nil {
		fields = append(fields, listenrecord.FieldAllDuration)
	}
	if m.dayDuration != nil {
		fields = append(fields, listenrecord.FieldDayDuration)
	}
	if m.createdAt != nil {
		fields = append(fields, listenrecord.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, listenrecord.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, listenrecord.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, listenrecord.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, listenrecord.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ListenRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case listenrecord.FieldUserId:
		return m.UserId()
	case listenrecord.FieldChapterId:
		return m.ChapterId()
	case listenrecord.FieldNovelId:
		return m.NovelId()
	case listenrecord.FieldListenTimes:
		return m.ListenTimes()
	case listenrecord.FieldDuration:
		return m.Duration()
	case listenrecord.FieldAllDuration:
		return m.AllDuration()
	case listenrecord.FieldDayDuration:
		return m.DayDuration()
	case listenrecord.FieldCreatedAt:
		return m.CreatedAt()
	case listenrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case listenrecord.FieldCreateBy:
		return m.CreateBy()
	case listenrecord.FieldUpdateBy:
		return m.UpdateBy()
	case listenrecord.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ListenRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case listenrecord.FieldUserId:
		return m.OldUserId(ctx)
	case listenrecord.FieldChapterId:
		return m.OldChapterId(ctx)
	case listenrecord.FieldNovelId:
		return m.OldNovelId(ctx)
	case listenrecord.FieldListenTimes:
		return m.OldListenTimes(ctx)
	case listenrecord.FieldDuration:
		return m.OldDuration(ctx)
	case listenrecord.FieldAllDuration:
		return m.OldAllDuration(ctx)
	case listenrecord.FieldDayDuration:
		return m.OldDayDuration(ctx)
	case listenrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case listenrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case listenrecord.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case listenrecord.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case listenrecord.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown ListenRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListenRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case listenrecord.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case listenrecord.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterId(v)
		return nil
	case listenrecord.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case listenrecord.FieldListenTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListenTimes(v)
		return nil
	case listenrecord.FieldDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case listenrecord.FieldAllDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllDuration(v)
		return nil
	case listenrecord.FieldDayDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayDuration(v)
		return nil
	case listenrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case listenrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case listenrecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case listenrecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case listenrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ListenRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ListenRecordMutation) AddedFields() []string {
	var fields []string
	if m.addchapterId != nil {
		fields = append(fields, listenrecord.FieldChapterId)
	}
	if m.addnovelId != nil {
		fields = append(fields, listenrecord.FieldNovelId)
	}
	if m.addlistenTimes != nil {
		fields = append(fields, listenrecord.FieldListenTimes)
	}
	if m.addduration != nil {
		fields = append(fields, listenrecord.FieldDuration)
	}
	if m.addallDuration != nil {
		fields = append(fields, listenrecord.FieldAllDuration)
	}
	if m.adddayDuration != nil {
		fields = append(fields, listenrecord.FieldDayDuration)
	}
	if m.addcreateBy != nil {
		fields = append(fields, listenrecord.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, listenrecord.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, listenrecord.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ListenRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case listenrecord.FieldChapterId:
		return m.AddedChapterId()
	case listenrecord.FieldNovelId:
		return m.AddedNovelId()
	case listenrecord.FieldListenTimes:
		return m.AddedListenTimes()
	case listenrecord.FieldDuration:
		return m.AddedDuration()
	case listenrecord.FieldAllDuration:
		return m.AddedAllDuration()
	case listenrecord.FieldDayDuration:
		return m.AddedDayDuration()
	case listenrecord.FieldCreateBy:
		return m.AddedCreateBy()
	case listenrecord.FieldUpdateBy:
		return m.AddedUpdateBy()
	case listenrecord.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListenRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case listenrecord.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterId(v)
		return nil
	case listenrecord.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case listenrecord.FieldListenTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddListenTimes(v)
		return nil
	case listenrecord.FieldDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case listenrecord.FieldAllDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllDuration(v)
		return nil
	case listenrecord.FieldDayDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayDuration(v)
		return nil
	case listenrecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case listenrecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case listenrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown ListenRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ListenRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(listenrecord.FieldNovelId) {
		fields = append(fields, listenrecord.FieldNovelId)
	}
	if m.FieldCleared(listenrecord.FieldListenTimes) {
		fields = append(fields, listenrecord.FieldListenTimes)
	}
	if m.FieldCleared(listenrecord.FieldDuration) {
		fields = append(fields, listenrecord.FieldDuration)
	}
	if m.FieldCleared(listenrecord.FieldAllDuration) {
		fields = append(fields, listenrecord.FieldAllDuration)
	}
	if m.FieldCleared(listenrecord.FieldDayDuration) {
		fields = append(fields, listenrecord.FieldDayDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ListenRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ListenRecordMutation) ClearField(name string) error {
	switch name {
	case listenrecord.FieldNovelId:
		m.ClearNovelId()
		return nil
	case listenrecord.FieldListenTimes:
		m.ClearListenTimes()
		return nil
	case listenrecord.FieldDuration:
		m.ClearDuration()
		return nil
	case listenrecord.FieldAllDuration:
		m.ClearAllDuration()
		return nil
	case listenrecord.FieldDayDuration:
		m.ClearDayDuration()
		return nil
	}
	return fmt.Errorf("unknown ListenRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ListenRecordMutation) ResetField(name string) error {
	switch name {
	case listenrecord.FieldUserId:
		m.ResetUserId()
		return nil
	case listenrecord.FieldChapterId:
		m.ResetChapterId()
		return nil
	case listenrecord.FieldNovelId:
		m.ResetNovelId()
		return nil
	case listenrecord.FieldListenTimes:
		m.ResetListenTimes()
		return nil
	case listenrecord.FieldDuration:
		m.ResetDuration()
		return nil
	case listenrecord.FieldAllDuration:
		m.ResetAllDuration()
		return nil
	case listenrecord.FieldDayDuration:
		m.ResetDayDuration()
		return nil
	case listenrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case listenrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case listenrecord.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case listenrecord.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case listenrecord.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown ListenRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ListenRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, listenrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ListenRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case listenrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ListenRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ListenRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ListenRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, listenrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ListenRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case listenrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ListenRecordMutation) ClearEdge(name string) error {
	switch name {
	case listenrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ListenRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ListenRecordMutation) ResetEdge(name string) error {
	switch name {
	case listenrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ListenRecord edge %s", name)
}

// NovelMutation represents an operation that mutates the Novel nodes in the graph.
type NovelMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	classifyName     *string
	authorId         *string
	title            *string
	summary          *string
	author           *string
	anchor           *string
	hits             *int64
	addhits          *int64
	keywords         *string
	source           *string
	score            *int32
	addscore         *int32
	cover            *string
	tagIds           *string
	wordNum          *int32
	addwordNum       *int32
	freeNum          *int32
	addfreeNum       *int32
	onlineState      *int32
	addonlineState   *int32
	price            *int64
	addprice         *int64
	publish          *int32
	addpublish       *int32
	originalPrice    *int64
	addoriginalPrice *int64
	chapterPrice     *int32
	addchapterPrice  *int32
	chapterCount     *int32
	addchapterCount  *int32
	signType         *int32
	addsignType      *int32
	signDate         *time.Time
	leadingMan       *string
	leadingLady      *string
	remark           *string
	mediaKey         *string
	createdAt        *time.Time
	updatedAt        *time.Time
	createBy         *int64
	addcreateBy      *int64
	updateBy         *int64
	addupdateBy      *int64
	tenantId         *int64
	addtenantId      *int64
	clearedFields    map[string]struct{}
	chapters         map[int64]struct{}
	removedchapters  map[int64]struct{}
	clearedchapters  bool
	pkgs             map[int64]struct{}
	removedpkgs      map[int64]struct{}
	clearedpkgs      bool
	classify         *int64
	clearedclassify  bool
	done             bool
	oldValue         func(context.Context) (*Novel, error)
	predicates       []predicate.Novel
}

var _ ent.Mutation = (*NovelMutation)(nil)

// novelOption allows management of the mutation configuration using functional options.
type novelOption func(*NovelMutation)

// newNovelMutation creates new mutation for the Novel entity.
func newNovelMutation(c config, op Op, opts ...novelOption) *NovelMutation {
	m := &NovelMutation{
		config:        c,
		op:            op,
		typ:           TypeNovel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelID sets the ID field of the mutation.
func withNovelID(id int64) novelOption {
	return func(m *NovelMutation) {
		var (
			err   error
			once  sync.Once
			value *Novel
		)
		m.oldValue = func(ctx context.Context) (*Novel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Novel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovel sets the old Novel of the mutation.
func withNovel(node *Novel) novelOption {
	return func(m *NovelMutation) {
		m.oldValue = func(context.Context) (*Novel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Novel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassifyId sets the "classifyId" field.
func (m *NovelMutation) SetClassifyId(i int64) {
	m.classify = &i
}

// ClassifyId returns the value of the "classifyId" field in the mutation.
func (m *NovelMutation) ClassifyId() (r int64, exists bool) {
	v := m.classify
	if v == nil {
		return
	}
	return *v, true
}

// OldClassifyId returns the old "classifyId" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldClassifyId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassifyId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassifyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassifyId: %w", err)
	}
	return oldValue.ClassifyId, nil
}

// ClearClassifyId clears the value of the "classifyId" field.
func (m *NovelMutation) ClearClassifyId() {
	m.classify = nil
	m.clearedFields[novel.FieldClassifyId] = struct{}{}
}

// ClassifyIdCleared returns if the "classifyId" field was cleared in this mutation.
func (m *NovelMutation) ClassifyIdCleared() bool {
	_, ok := m.clearedFields[novel.FieldClassifyId]
	return ok
}

// ResetClassifyId resets all changes to the "classifyId" field.
func (m *NovelMutation) ResetClassifyId() {
	m.classify = nil
	delete(m.clearedFields, novel.FieldClassifyId)
}

// SetClassifyName sets the "classifyName" field.
func (m *NovelMutation) SetClassifyName(s string) {
	m.classifyName = &s
}

// ClassifyName returns the value of the "classifyName" field in the mutation.
func (m *NovelMutation) ClassifyName() (r string, exists bool) {
	v := m.classifyName
	if v == nil {
		return
	}
	return *v, true
}

// OldClassifyName returns the old "classifyName" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldClassifyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassifyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassifyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassifyName: %w", err)
	}
	return oldValue.ClassifyName, nil
}

// ClearClassifyName clears the value of the "classifyName" field.
func (m *NovelMutation) ClearClassifyName() {
	m.classifyName = nil
	m.clearedFields[novel.FieldClassifyName] = struct{}{}
}

// ClassifyNameCleared returns if the "classifyName" field was cleared in this mutation.
func (m *NovelMutation) ClassifyNameCleared() bool {
	_, ok := m.clearedFields[novel.FieldClassifyName]
	return ok
}

// ResetClassifyName resets all changes to the "classifyName" field.
func (m *NovelMutation) ResetClassifyName() {
	m.classifyName = nil
	delete(m.clearedFields, novel.FieldClassifyName)
}

// SetAuthorId sets the "authorId" field.
func (m *NovelMutation) SetAuthorId(s string) {
	m.authorId = &s
}

// AuthorId returns the value of the "authorId" field in the mutation.
func (m *NovelMutation) AuthorId() (r string, exists bool) {
	v := m.authorId
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorId returns the old "authorId" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldAuthorId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorId: %w", err)
	}
	return oldValue.AuthorId, nil
}

// ClearAuthorId clears the value of the "authorId" field.
func (m *NovelMutation) ClearAuthorId() {
	m.authorId = nil
	m.clearedFields[novel.FieldAuthorId] = struct{}{}
}

// AuthorIdCleared returns if the "authorId" field was cleared in this mutation.
func (m *NovelMutation) AuthorIdCleared() bool {
	_, ok := m.clearedFields[novel.FieldAuthorId]
	return ok
}

// ResetAuthorId resets all changes to the "authorId" field.
func (m *NovelMutation) ResetAuthorId() {
	m.authorId = nil
	delete(m.clearedFields, novel.FieldAuthorId)
}

// SetTitle sets the "title" field.
func (m *NovelMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NovelMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *NovelMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[novel.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *NovelMutation) TitleCleared() bool {
	_, ok := m.clearedFields[novel.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *NovelMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, novel.FieldTitle)
}

// SetSummary sets the "summary" field.
func (m *NovelMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *NovelMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *NovelMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[novel.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *NovelMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[novel.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *NovelMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, novel.FieldSummary)
}

// SetAuthor sets the "author" field.
func (m *NovelMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *NovelMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *NovelMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[novel.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *NovelMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[novel.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *NovelMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, novel.FieldAuthor)
}

// SetAnchor sets the "anchor" field.
func (m *NovelMutation) SetAnchor(s string) {
	m.anchor = &s
}

// Anchor returns the value of the "anchor" field in the mutation.
func (m *NovelMutation) Anchor() (r string, exists bool) {
	v := m.anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldAnchor returns the old "anchor" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldAnchor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnchor: %w", err)
	}
	return oldValue.Anchor, nil
}

// ClearAnchor clears the value of the "anchor" field.
func (m *NovelMutation) ClearAnchor() {
	m.anchor = nil
	m.clearedFields[novel.FieldAnchor] = struct{}{}
}

// AnchorCleared returns if the "anchor" field was cleared in this mutation.
func (m *NovelMutation) AnchorCleared() bool {
	_, ok := m.clearedFields[novel.FieldAnchor]
	return ok
}

// ResetAnchor resets all changes to the "anchor" field.
func (m *NovelMutation) ResetAnchor() {
	m.anchor = nil
	delete(m.clearedFields, novel.FieldAnchor)
}

// SetHits sets the "hits" field.
func (m *NovelMutation) SetHits(i int64) {
	m.hits = &i
	m.addhits = nil
}

// Hits returns the value of the "hits" field in the mutation.
func (m *NovelMutation) Hits() (r int64, exists bool) {
	v := m.hits
	if v == nil {
		return
	}
	return *v, true
}

// OldHits returns the old "hits" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldHits(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHits: %w", err)
	}
	return oldValue.Hits, nil
}

// AddHits adds i to the "hits" field.
func (m *NovelMutation) AddHits(i int64) {
	if m.addhits != nil {
		*m.addhits += i
	} else {
		m.addhits = &i
	}
}

// AddedHits returns the value that was added to the "hits" field in this mutation.
func (m *NovelMutation) AddedHits() (r int64, exists bool) {
	v := m.addhits
	if v == nil {
		return
	}
	return *v, true
}

// ClearHits clears the value of the "hits" field.
func (m *NovelMutation) ClearHits() {
	m.hits = nil
	m.addhits = nil
	m.clearedFields[novel.FieldHits] = struct{}{}
}

// HitsCleared returns if the "hits" field was cleared in this mutation.
func (m *NovelMutation) HitsCleared() bool {
	_, ok := m.clearedFields[novel.FieldHits]
	return ok
}

// ResetHits resets all changes to the "hits" field.
func (m *NovelMutation) ResetHits() {
	m.hits = nil
	m.addhits = nil
	delete(m.clearedFields, novel.FieldHits)
}

// SetKeywords sets the "keywords" field.
func (m *NovelMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *NovelMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *NovelMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[novel.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *NovelMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[novel.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *NovelMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, novel.FieldKeywords)
}

// SetSource sets the "source" field.
func (m *NovelMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *NovelMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *NovelMutation) ClearSource() {
	m.source = nil
	m.clearedFields[novel.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *NovelMutation) SourceCleared() bool {
	_, ok := m.clearedFields[novel.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *NovelMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, novel.FieldSource)
}

// SetScore sets the "score" field.
func (m *NovelMutation) SetScore(i int32) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *NovelMutation) Score() (r int32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldScore(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *NovelMutation) AddScore(i int32) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *NovelMutation) AddedScore() (r int32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *NovelMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[novel.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *NovelMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[novel.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *NovelMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, novel.FieldScore)
}

// SetCover sets the "cover" field.
func (m *NovelMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *NovelMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ClearCover clears the value of the "cover" field.
func (m *NovelMutation) ClearCover() {
	m.cover = nil
	m.clearedFields[novel.FieldCover] = struct{}{}
}

// CoverCleared returns if the "cover" field was cleared in this mutation.
func (m *NovelMutation) CoverCleared() bool {
	_, ok := m.clearedFields[novel.FieldCover]
	return ok
}

// ResetCover resets all changes to the "cover" field.
func (m *NovelMutation) ResetCover() {
	m.cover = nil
	delete(m.clearedFields, novel.FieldCover)
}

// SetTagIds sets the "tagIds" field.
func (m *NovelMutation) SetTagIds(s string) {
	m.tagIds = &s
}

// TagIds returns the value of the "tagIds" field in the mutation.
func (m *NovelMutation) TagIds() (r string, exists bool) {
	v := m.tagIds
	if v == nil {
		return
	}
	return *v, true
}

// OldTagIds returns the old "tagIds" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldTagIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagIds: %w", err)
	}
	return oldValue.TagIds, nil
}

// ClearTagIds clears the value of the "tagIds" field.
func (m *NovelMutation) ClearTagIds() {
	m.tagIds = nil
	m.clearedFields[novel.FieldTagIds] = struct{}{}
}

// TagIdsCleared returns if the "tagIds" field was cleared in this mutation.
func (m *NovelMutation) TagIdsCleared() bool {
	_, ok := m.clearedFields[novel.FieldTagIds]
	return ok
}

// ResetTagIds resets all changes to the "tagIds" field.
func (m *NovelMutation) ResetTagIds() {
	m.tagIds = nil
	delete(m.clearedFields, novel.FieldTagIds)
}

// SetWordNum sets the "wordNum" field.
func (m *NovelMutation) SetWordNum(i int32) {
	m.wordNum = &i
	m.addwordNum = nil
}

// WordNum returns the value of the "wordNum" field in the mutation.
func (m *NovelMutation) WordNum() (r int32, exists bool) {
	v := m.wordNum
	if v == nil {
		return
	}
	return *v, true
}

// OldWordNum returns the old "wordNum" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldWordNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordNum: %w", err)
	}
	return oldValue.WordNum, nil
}

// AddWordNum adds i to the "wordNum" field.
func (m *NovelMutation) AddWordNum(i int32) {
	if m.addwordNum != nil {
		*m.addwordNum += i
	} else {
		m.addwordNum = &i
	}
}

// AddedWordNum returns the value that was added to the "wordNum" field in this mutation.
func (m *NovelMutation) AddedWordNum() (r int32, exists bool) {
	v := m.addwordNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearWordNum clears the value of the "wordNum" field.
func (m *NovelMutation) ClearWordNum() {
	m.wordNum = nil
	m.addwordNum = nil
	m.clearedFields[novel.FieldWordNum] = struct{}{}
}

// WordNumCleared returns if the "wordNum" field was cleared in this mutation.
func (m *NovelMutation) WordNumCleared() bool {
	_, ok := m.clearedFields[novel.FieldWordNum]
	return ok
}

// ResetWordNum resets all changes to the "wordNum" field.
func (m *NovelMutation) ResetWordNum() {
	m.wordNum = nil
	m.addwordNum = nil
	delete(m.clearedFields, novel.FieldWordNum)
}

// SetFreeNum sets the "freeNum" field.
func (m *NovelMutation) SetFreeNum(i int32) {
	m.freeNum = &i
	m.addfreeNum = nil
}

// FreeNum returns the value of the "freeNum" field in the mutation.
func (m *NovelMutation) FreeNum() (r int32, exists bool) {
	v := m.freeNum
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeNum returns the old "freeNum" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldFreeNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeNum: %w", err)
	}
	return oldValue.FreeNum, nil
}

// AddFreeNum adds i to the "freeNum" field.
func (m *NovelMutation) AddFreeNum(i int32) {
	if m.addfreeNum != nil {
		*m.addfreeNum += i
	} else {
		m.addfreeNum = &i
	}
}

// AddedFreeNum returns the value that was added to the "freeNum" field in this mutation.
func (m *NovelMutation) AddedFreeNum() (r int32, exists bool) {
	v := m.addfreeNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreeNum clears the value of the "freeNum" field.
func (m *NovelMutation) ClearFreeNum() {
	m.freeNum = nil
	m.addfreeNum = nil
	m.clearedFields[novel.FieldFreeNum] = struct{}{}
}

// FreeNumCleared returns if the "freeNum" field was cleared in this mutation.
func (m *NovelMutation) FreeNumCleared() bool {
	_, ok := m.clearedFields[novel.FieldFreeNum]
	return ok
}

// ResetFreeNum resets all changes to the "freeNum" field.
func (m *NovelMutation) ResetFreeNum() {
	m.freeNum = nil
	m.addfreeNum = nil
	delete(m.clearedFields, novel.FieldFreeNum)
}

// SetOnlineState sets the "onlineState" field.
func (m *NovelMutation) SetOnlineState(i int32) {
	m.onlineState = &i
	m.addonlineState = nil
}

// OnlineState returns the value of the "onlineState" field in the mutation.
func (m *NovelMutation) OnlineState() (r int32, exists bool) {
	v := m.onlineState
	if v == nil {
		return
	}
	return *v, true
}

// OldOnlineState returns the old "onlineState" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldOnlineState(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnlineState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnlineState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnlineState: %w", err)
	}
	return oldValue.OnlineState, nil
}

// AddOnlineState adds i to the "onlineState" field.
func (m *NovelMutation) AddOnlineState(i int32) {
	if m.addonlineState != nil {
		*m.addonlineState += i
	} else {
		m.addonlineState = &i
	}
}

// AddedOnlineState returns the value that was added to the "onlineState" field in this mutation.
func (m *NovelMutation) AddedOnlineState() (r int32, exists bool) {
	v := m.addonlineState
	if v == nil {
		return
	}
	return *v, true
}

// ClearOnlineState clears the value of the "onlineState" field.
func (m *NovelMutation) ClearOnlineState() {
	m.onlineState = nil
	m.addonlineState = nil
	m.clearedFields[novel.FieldOnlineState] = struct{}{}
}

// OnlineStateCleared returns if the "onlineState" field was cleared in this mutation.
func (m *NovelMutation) OnlineStateCleared() bool {
	_, ok := m.clearedFields[novel.FieldOnlineState]
	return ok
}

// ResetOnlineState resets all changes to the "onlineState" field.
func (m *NovelMutation) ResetOnlineState() {
	m.onlineState = nil
	m.addonlineState = nil
	delete(m.clearedFields, novel.FieldOnlineState)
}

// SetPrice sets the "price" field.
func (m *NovelMutation) SetPrice(i int64) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *NovelMutation) Price() (r int64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *NovelMutation) AddPrice(i int64) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *NovelMutation) AddedPrice() (r int64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *NovelMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[novel.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *NovelMutation) PriceCleared() bool {
	_, ok := m.clearedFields[novel.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *NovelMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, novel.FieldPrice)
}

// SetPublish sets the "publish" field.
func (m *NovelMutation) SetPublish(i int32) {
	m.publish = &i
	m.addpublish = nil
}

// Publish returns the value of the "publish" field in the mutation.
func (m *NovelMutation) Publish() (r int32, exists bool) {
	v := m.publish
	if v == nil {
		return
	}
	return *v, true
}

// OldPublish returns the old "publish" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldPublish(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublish: %w", err)
	}
	return oldValue.Publish, nil
}

// AddPublish adds i to the "publish" field.
func (m *NovelMutation) AddPublish(i int32) {
	if m.addpublish != nil {
		*m.addpublish += i
	} else {
		m.addpublish = &i
	}
}

// AddedPublish returns the value that was added to the "publish" field in this mutation.
func (m *NovelMutation) AddedPublish() (r int32, exists bool) {
	v := m.addpublish
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublish clears the value of the "publish" field.
func (m *NovelMutation) ClearPublish() {
	m.publish = nil
	m.addpublish = nil
	m.clearedFields[novel.FieldPublish] = struct{}{}
}

// PublishCleared returns if the "publish" field was cleared in this mutation.
func (m *NovelMutation) PublishCleared() bool {
	_, ok := m.clearedFields[novel.FieldPublish]
	return ok
}

// ResetPublish resets all changes to the "publish" field.
func (m *NovelMutation) ResetPublish() {
	m.publish = nil
	m.addpublish = nil
	delete(m.clearedFields, novel.FieldPublish)
}

// SetOriginalPrice sets the "originalPrice" field.
func (m *NovelMutation) SetOriginalPrice(i int64) {
	m.originalPrice = &i
	m.addoriginalPrice = nil
}

// OriginalPrice returns the value of the "originalPrice" field in the mutation.
func (m *NovelMutation) OriginalPrice() (r int64, exists bool) {
	v := m.originalPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalPrice returns the old "originalPrice" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldOriginalPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalPrice: %w", err)
	}
	return oldValue.OriginalPrice, nil
}

// AddOriginalPrice adds i to the "originalPrice" field.
func (m *NovelMutation) AddOriginalPrice(i int64) {
	if m.addoriginalPrice != nil {
		*m.addoriginalPrice += i
	} else {
		m.addoriginalPrice = &i
	}
}

// AddedOriginalPrice returns the value that was added to the "originalPrice" field in this mutation.
func (m *NovelMutation) AddedOriginalPrice() (r int64, exists bool) {
	v := m.addoriginalPrice
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginalPrice clears the value of the "originalPrice" field.
func (m *NovelMutation) ClearOriginalPrice() {
	m.originalPrice = nil
	m.addoriginalPrice = nil
	m.clearedFields[novel.FieldOriginalPrice] = struct{}{}
}

// OriginalPriceCleared returns if the "originalPrice" field was cleared in this mutation.
func (m *NovelMutation) OriginalPriceCleared() bool {
	_, ok := m.clearedFields[novel.FieldOriginalPrice]
	return ok
}

// ResetOriginalPrice resets all changes to the "originalPrice" field.
func (m *NovelMutation) ResetOriginalPrice() {
	m.originalPrice = nil
	m.addoriginalPrice = nil
	delete(m.clearedFields, novel.FieldOriginalPrice)
}

// SetChapterPrice sets the "chapterPrice" field.
func (m *NovelMutation) SetChapterPrice(i int32) {
	m.chapterPrice = &i
	m.addchapterPrice = nil
}

// ChapterPrice returns the value of the "chapterPrice" field in the mutation.
func (m *NovelMutation) ChapterPrice() (r int32, exists bool) {
	v := m.chapterPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterPrice returns the old "chapterPrice" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldChapterPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterPrice: %w", err)
	}
	return oldValue.ChapterPrice, nil
}

// AddChapterPrice adds i to the "chapterPrice" field.
func (m *NovelMutation) AddChapterPrice(i int32) {
	if m.addchapterPrice != nil {
		*m.addchapterPrice += i
	} else {
		m.addchapterPrice = &i
	}
}

// AddedChapterPrice returns the value that was added to the "chapterPrice" field in this mutation.
func (m *NovelMutation) AddedChapterPrice() (r int32, exists bool) {
	v := m.addchapterPrice
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterPrice clears the value of the "chapterPrice" field.
func (m *NovelMutation) ClearChapterPrice() {
	m.chapterPrice = nil
	m.addchapterPrice = nil
	m.clearedFields[novel.FieldChapterPrice] = struct{}{}
}

// ChapterPriceCleared returns if the "chapterPrice" field was cleared in this mutation.
func (m *NovelMutation) ChapterPriceCleared() bool {
	_, ok := m.clearedFields[novel.FieldChapterPrice]
	return ok
}

// ResetChapterPrice resets all changes to the "chapterPrice" field.
func (m *NovelMutation) ResetChapterPrice() {
	m.chapterPrice = nil
	m.addchapterPrice = nil
	delete(m.clearedFields, novel.FieldChapterPrice)
}

// SetChapterCount sets the "chapterCount" field.
func (m *NovelMutation) SetChapterCount(i int32) {
	m.chapterCount = &i
	m.addchapterCount = nil
}

// ChapterCount returns the value of the "chapterCount" field in the mutation.
func (m *NovelMutation) ChapterCount() (r int32, exists bool) {
	v := m.chapterCount
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterCount returns the old "chapterCount" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldChapterCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterCount: %w", err)
	}
	return oldValue.ChapterCount, nil
}

// AddChapterCount adds i to the "chapterCount" field.
func (m *NovelMutation) AddChapterCount(i int32) {
	if m.addchapterCount != nil {
		*m.addchapterCount += i
	} else {
		m.addchapterCount = &i
	}
}

// AddedChapterCount returns the value that was added to the "chapterCount" field in this mutation.
func (m *NovelMutation) AddedChapterCount() (r int32, exists bool) {
	v := m.addchapterCount
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterCount clears the value of the "chapterCount" field.
func (m *NovelMutation) ClearChapterCount() {
	m.chapterCount = nil
	m.addchapterCount = nil
	m.clearedFields[novel.FieldChapterCount] = struct{}{}
}

// ChapterCountCleared returns if the "chapterCount" field was cleared in this mutation.
func (m *NovelMutation) ChapterCountCleared() bool {
	_, ok := m.clearedFields[novel.FieldChapterCount]
	return ok
}

// ResetChapterCount resets all changes to the "chapterCount" field.
func (m *NovelMutation) ResetChapterCount() {
	m.chapterCount = nil
	m.addchapterCount = nil
	delete(m.clearedFields, novel.FieldChapterCount)
}

// SetSignType sets the "signType" field.
func (m *NovelMutation) SetSignType(i int32) {
	m.signType = &i
	m.addsignType = nil
}

// SignType returns the value of the "signType" field in the mutation.
func (m *NovelMutation) SignType() (r int32, exists bool) {
	v := m.signType
	if v == nil {
		return
	}
	return *v, true
}

// OldSignType returns the old "signType" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldSignType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignType: %w", err)
	}
	return oldValue.SignType, nil
}

// AddSignType adds i to the "signType" field.
func (m *NovelMutation) AddSignType(i int32) {
	if m.addsignType != nil {
		*m.addsignType += i
	} else {
		m.addsignType = &i
	}
}

// AddedSignType returns the value that was added to the "signType" field in this mutation.
func (m *NovelMutation) AddedSignType() (r int32, exists bool) {
	v := m.addsignType
	if v == nil {
		return
	}
	return *v, true
}

// ClearSignType clears the value of the "signType" field.
func (m *NovelMutation) ClearSignType() {
	m.signType = nil
	m.addsignType = nil
	m.clearedFields[novel.FieldSignType] = struct{}{}
}

// SignTypeCleared returns if the "signType" field was cleared in this mutation.
func (m *NovelMutation) SignTypeCleared() bool {
	_, ok := m.clearedFields[novel.FieldSignType]
	return ok
}

// ResetSignType resets all changes to the "signType" field.
func (m *NovelMutation) ResetSignType() {
	m.signType = nil
	m.addsignType = nil
	delete(m.clearedFields, novel.FieldSignType)
}

// SetSignDate sets the "signDate" field.
func (m *NovelMutation) SetSignDate(t time.Time) {
	m.signDate = &t
}

// SignDate returns the value of the "signDate" field in the mutation.
func (m *NovelMutation) SignDate() (r time.Time, exists bool) {
	v := m.signDate
	if v == nil {
		return
	}
	return *v, true
}

// OldSignDate returns the old "signDate" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldSignDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignDate: %w", err)
	}
	return oldValue.SignDate, nil
}

// ClearSignDate clears the value of the "signDate" field.
func (m *NovelMutation) ClearSignDate() {
	m.signDate = nil
	m.clearedFields[novel.FieldSignDate] = struct{}{}
}

// SignDateCleared returns if the "signDate" field was cleared in this mutation.
func (m *NovelMutation) SignDateCleared() bool {
	_, ok := m.clearedFields[novel.FieldSignDate]
	return ok
}

// ResetSignDate resets all changes to the "signDate" field.
func (m *NovelMutation) ResetSignDate() {
	m.signDate = nil
	delete(m.clearedFields, novel.FieldSignDate)
}

// SetLeadingMan sets the "leadingMan" field.
func (m *NovelMutation) SetLeadingMan(s string) {
	m.leadingMan = &s
}

// LeadingMan returns the value of the "leadingMan" field in the mutation.
func (m *NovelMutation) LeadingMan() (r string, exists bool) {
	v := m.leadingMan
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadingMan returns the old "leadingMan" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldLeadingMan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadingMan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadingMan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadingMan: %w", err)
	}
	return oldValue.LeadingMan, nil
}

// ClearLeadingMan clears the value of the "leadingMan" field.
func (m *NovelMutation) ClearLeadingMan() {
	m.leadingMan = nil
	m.clearedFields[novel.FieldLeadingMan] = struct{}{}
}

// LeadingManCleared returns if the "leadingMan" field was cleared in this mutation.
func (m *NovelMutation) LeadingManCleared() bool {
	_, ok := m.clearedFields[novel.FieldLeadingMan]
	return ok
}

// ResetLeadingMan resets all changes to the "leadingMan" field.
func (m *NovelMutation) ResetLeadingMan() {
	m.leadingMan = nil
	delete(m.clearedFields, novel.FieldLeadingMan)
}

// SetLeadingLady sets the "leadingLady" field.
func (m *NovelMutation) SetLeadingLady(s string) {
	m.leadingLady = &s
}

// LeadingLady returns the value of the "leadingLady" field in the mutation.
func (m *NovelMutation) LeadingLady() (r string, exists bool) {
	v := m.leadingLady
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadingLady returns the old "leadingLady" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldLeadingLady(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadingLady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadingLady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadingLady: %w", err)
	}
	return oldValue.LeadingLady, nil
}

// ClearLeadingLady clears the value of the "leadingLady" field.
func (m *NovelMutation) ClearLeadingLady() {
	m.leadingLady = nil
	m.clearedFields[novel.FieldLeadingLady] = struct{}{}
}

// LeadingLadyCleared returns if the "leadingLady" field was cleared in this mutation.
func (m *NovelMutation) LeadingLadyCleared() bool {
	_, ok := m.clearedFields[novel.FieldLeadingLady]
	return ok
}

// ResetLeadingLady resets all changes to the "leadingLady" field.
func (m *NovelMutation) ResetLeadingLady() {
	m.leadingLady = nil
	delete(m.clearedFields, novel.FieldLeadingLady)
}

// SetRemark sets the "remark" field.
func (m *NovelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novel.FieldRemark)
}

// SetMediaKey sets the "mediaKey" field.
func (m *NovelMutation) SetMediaKey(s string) {
	m.mediaKey = &s
}

// MediaKey returns the value of the "mediaKey" field in the mutation.
func (m *NovelMutation) MediaKey() (r string, exists bool) {
	v := m.mediaKey
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaKey returns the old "mediaKey" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldMediaKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaKey: %w", err)
	}
	return oldValue.MediaKey, nil
}

// ClearMediaKey clears the value of the "mediaKey" field.
func (m *NovelMutation) ClearMediaKey() {
	m.mediaKey = nil
	m.clearedFields[novel.FieldMediaKey] = struct{}{}
}

// MediaKeyCleared returns if the "mediaKey" field was cleared in this mutation.
func (m *NovelMutation) MediaKeyCleared() bool {
	_, ok := m.clearedFields[novel.FieldMediaKey]
	return ok
}

// ResetMediaKey resets all changes to the "mediaKey" field.
func (m *NovelMutation) ResetMediaKey() {
	m.mediaKey = nil
	delete(m.clearedFields, novel.FieldMediaKey)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the Novel entity.
// If the Novel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// AddChapterIDs adds the "chapters" edge to the NovelChapter entity by ids.
func (m *NovelMutation) AddChapterIDs(ids ...int64) {
	if m.chapters == nil {
		m.chapters = make(map[int64]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the NovelChapter entity.
func (m *NovelMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the NovelChapter entity was cleared.
func (m *NovelMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the NovelChapter entity by IDs.
func (m *NovelMutation) RemoveChapterIDs(ids ...int64) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the NovelChapter entity.
func (m *NovelMutation) RemovedChaptersIDs() (ids []int64) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *NovelMutation) ChaptersIDs() (ids []int64) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *NovelMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// AddPkgIDs adds the "pkgs" edge to the BookPackage entity by ids.
func (m *NovelMutation) AddPkgIDs(ids ...int64) {
	if m.pkgs == nil {
		m.pkgs = make(map[int64]struct{})
	}
	for i := range ids {
		m.pkgs[ids[i]] = struct{}{}
	}
}

// ClearPkgs clears the "pkgs" edge to the BookPackage entity.
func (m *NovelMutation) ClearPkgs() {
	m.clearedpkgs = true
}

// PkgsCleared reports if the "pkgs" edge to the BookPackage entity was cleared.
func (m *NovelMutation) PkgsCleared() bool {
	return m.clearedpkgs
}

// RemovePkgIDs removes the "pkgs" edge to the BookPackage entity by IDs.
func (m *NovelMutation) RemovePkgIDs(ids ...int64) {
	if m.removedpkgs == nil {
		m.removedpkgs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.pkgs, ids[i])
		m.removedpkgs[ids[i]] = struct{}{}
	}
}

// RemovedPkgs returns the removed IDs of the "pkgs" edge to the BookPackage entity.
func (m *NovelMutation) RemovedPkgsIDs() (ids []int64) {
	for id := range m.removedpkgs {
		ids = append(ids, id)
	}
	return
}

// PkgsIDs returns the "pkgs" edge IDs in the mutation.
func (m *NovelMutation) PkgsIDs() (ids []int64) {
	for id := range m.pkgs {
		ids = append(ids, id)
	}
	return
}

// ResetPkgs resets all changes to the "pkgs" edge.
func (m *NovelMutation) ResetPkgs() {
	m.pkgs = nil
	m.clearedpkgs = false
	m.removedpkgs = nil
}

// SetClassifyID sets the "classify" edge to the NovelClassify entity by id.
func (m *NovelMutation) SetClassifyID(id int64) {
	m.classify = &id
}

// ClearClassify clears the "classify" edge to the NovelClassify entity.
func (m *NovelMutation) ClearClassify() {
	m.clearedclassify = true
}

// ClassifyCleared reports if the "classify" edge to the NovelClassify entity was cleared.
func (m *NovelMutation) ClassifyCleared() bool {
	return m.ClassifyIdCleared() || m.clearedclassify
}

// ClassifyID returns the "classify" edge ID in the mutation.
func (m *NovelMutation) ClassifyID() (id int64, exists bool) {
	if m.classify != nil {
		return *m.classify, true
	}
	return
}

// ClassifyIDs returns the "classify" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassifyID instead. It exists only for internal usage by the builders.
func (m *NovelMutation) ClassifyIDs() (ids []int64) {
	if id := m.classify; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassify resets all changes to the "classify" edge.
func (m *NovelMutation) ResetClassify() {
	m.classify = nil
	m.clearedclassify = false
}

// Where appends a list predicates to the NovelMutation builder.
func (m *NovelMutation) Where(ps ...predicate.Novel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Novel).
func (m *NovelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.classify != nil {
		fields = append(fields, novel.FieldClassifyId)
	}
	if m.classifyName != nil {
		fields = append(fields, novel.FieldClassifyName)
	}
	if m.authorId != nil {
		fields = append(fields, novel.FieldAuthorId)
	}
	if m.title != nil {
		fields = append(fields, novel.FieldTitle)
	}
	if m.summary != nil {
		fields = append(fields, novel.FieldSummary)
	}
	if m.author != nil {
		fields = append(fields, novel.FieldAuthor)
	}
	if m.anchor != nil {
		fields = append(fields, novel.FieldAnchor)
	}
	if m.hits != nil {
		fields = append(fields, novel.FieldHits)
	}
	if m.keywords != nil {
		fields = append(fields, novel.FieldKeywords)
	}
	if m.source != nil {
		fields = append(fields, novel.FieldSource)
	}
	if m.score != nil {
		fields = append(fields, novel.FieldScore)
	}
	if m.cover != nil {
		fields = append(fields, novel.FieldCover)
	}
	if m.tagIds != nil {
		fields = append(fields, novel.FieldTagIds)
	}
	if m.wordNum != nil {
		fields = append(fields, novel.FieldWordNum)
	}
	if m.freeNum != nil {
		fields = append(fields, novel.FieldFreeNum)
	}
	if m.onlineState != nil {
		fields = append(fields, novel.FieldOnlineState)
	}
	if m.price != nil {
		fields = append(fields, novel.FieldPrice)
	}
	if m.publish != nil {
		fields = append(fields, novel.FieldPublish)
	}
	if m.originalPrice != nil {
		fields = append(fields, novel.FieldOriginalPrice)
	}
	if m.chapterPrice != nil {
		fields = append(fields, novel.FieldChapterPrice)
	}
	if m.chapterCount != nil {
		fields = append(fields, novel.FieldChapterCount)
	}
	if m.signType != nil {
		fields = append(fields, novel.FieldSignType)
	}
	if m.signDate != nil {
		fields = append(fields, novel.FieldSignDate)
	}
	if m.leadingMan != nil {
		fields = append(fields, novel.FieldLeadingMan)
	}
	if m.leadingLady != nil {
		fields = append(fields, novel.FieldLeadingLady)
	}
	if m.remark != nil {
		fields = append(fields, novel.FieldRemark)
	}
	if m.mediaKey != nil {
		fields = append(fields, novel.FieldMediaKey)
	}
	if m.createdAt != nil {
		fields = append(fields, novel.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novel.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novel.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novel.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novel.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novel.FieldClassifyId:
		return m.ClassifyId()
	case novel.FieldClassifyName:
		return m.ClassifyName()
	case novel.FieldAuthorId:
		return m.AuthorId()
	case novel.FieldTitle:
		return m.Title()
	case novel.FieldSummary:
		return m.Summary()
	case novel.FieldAuthor:
		return m.Author()
	case novel.FieldAnchor:
		return m.Anchor()
	case novel.FieldHits:
		return m.Hits()
	case novel.FieldKeywords:
		return m.Keywords()
	case novel.FieldSource:
		return m.Source()
	case novel.FieldScore:
		return m.Score()
	case novel.FieldCover:
		return m.Cover()
	case novel.FieldTagIds:
		return m.TagIds()
	case novel.FieldWordNum:
		return m.WordNum()
	case novel.FieldFreeNum:
		return m.FreeNum()
	case novel.FieldOnlineState:
		return m.OnlineState()
	case novel.FieldPrice:
		return m.Price()
	case novel.FieldPublish:
		return m.Publish()
	case novel.FieldOriginalPrice:
		return m.OriginalPrice()
	case novel.FieldChapterPrice:
		return m.ChapterPrice()
	case novel.FieldChapterCount:
		return m.ChapterCount()
	case novel.FieldSignType:
		return m.SignType()
	case novel.FieldSignDate:
		return m.SignDate()
	case novel.FieldLeadingMan:
		return m.LeadingMan()
	case novel.FieldLeadingLady:
		return m.LeadingLady()
	case novel.FieldRemark:
		return m.Remark()
	case novel.FieldMediaKey:
		return m.MediaKey()
	case novel.FieldCreatedAt:
		return m.CreatedAt()
	case novel.FieldUpdatedAt:
		return m.UpdatedAt()
	case novel.FieldCreateBy:
		return m.CreateBy()
	case novel.FieldUpdateBy:
		return m.UpdateBy()
	case novel.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novel.FieldClassifyId:
		return m.OldClassifyId(ctx)
	case novel.FieldClassifyName:
		return m.OldClassifyName(ctx)
	case novel.FieldAuthorId:
		return m.OldAuthorId(ctx)
	case novel.FieldTitle:
		return m.OldTitle(ctx)
	case novel.FieldSummary:
		return m.OldSummary(ctx)
	case novel.FieldAuthor:
		return m.OldAuthor(ctx)
	case novel.FieldAnchor:
		return m.OldAnchor(ctx)
	case novel.FieldHits:
		return m.OldHits(ctx)
	case novel.FieldKeywords:
		return m.OldKeywords(ctx)
	case novel.FieldSource:
		return m.OldSource(ctx)
	case novel.FieldScore:
		return m.OldScore(ctx)
	case novel.FieldCover:
		return m.OldCover(ctx)
	case novel.FieldTagIds:
		return m.OldTagIds(ctx)
	case novel.FieldWordNum:
		return m.OldWordNum(ctx)
	case novel.FieldFreeNum:
		return m.OldFreeNum(ctx)
	case novel.FieldOnlineState:
		return m.OldOnlineState(ctx)
	case novel.FieldPrice:
		return m.OldPrice(ctx)
	case novel.FieldPublish:
		return m.OldPublish(ctx)
	case novel.FieldOriginalPrice:
		return m.OldOriginalPrice(ctx)
	case novel.FieldChapterPrice:
		return m.OldChapterPrice(ctx)
	case novel.FieldChapterCount:
		return m.OldChapterCount(ctx)
	case novel.FieldSignType:
		return m.OldSignType(ctx)
	case novel.FieldSignDate:
		return m.OldSignDate(ctx)
	case novel.FieldLeadingMan:
		return m.OldLeadingMan(ctx)
	case novel.FieldLeadingLady:
		return m.OldLeadingLady(ctx)
	case novel.FieldRemark:
		return m.OldRemark(ctx)
	case novel.FieldMediaKey:
		return m.OldMediaKey(ctx)
	case novel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novel.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novel.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novel.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown Novel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novel.FieldClassifyId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassifyId(v)
		return nil
	case novel.FieldClassifyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassifyName(v)
		return nil
	case novel.FieldAuthorId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorId(v)
		return nil
	case novel.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case novel.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case novel.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case novel.FieldAnchor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnchor(v)
		return nil
	case novel.FieldHits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHits(v)
		return nil
	case novel.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case novel.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case novel.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case novel.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case novel.FieldTagIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagIds(v)
		return nil
	case novel.FieldWordNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordNum(v)
		return nil
	case novel.FieldFreeNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeNum(v)
		return nil
	case novel.FieldOnlineState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnlineState(v)
		return nil
	case novel.FieldPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case novel.FieldPublish:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublish(v)
		return nil
	case novel.FieldOriginalPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalPrice(v)
		return nil
	case novel.FieldChapterPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterPrice(v)
		return nil
	case novel.FieldChapterCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterCount(v)
		return nil
	case novel.FieldSignType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignType(v)
		return nil
	case novel.FieldSignDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignDate(v)
		return nil
	case novel.FieldLeadingMan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadingMan(v)
		return nil
	case novel.FieldLeadingLady:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadingLady(v)
		return nil
	case novel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novel.FieldMediaKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaKey(v)
		return nil
	case novel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novel.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novel.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novel.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown Novel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelMutation) AddedFields() []string {
	var fields []string
	if m.addhits != nil {
		fields = append(fields, novel.FieldHits)
	}
	if m.addscore != nil {
		fields = append(fields, novel.FieldScore)
	}
	if m.addwordNum != nil {
		fields = append(fields, novel.FieldWordNum)
	}
	if m.addfreeNum != nil {
		fields = append(fields, novel.FieldFreeNum)
	}
	if m.addonlineState != nil {
		fields = append(fields, novel.FieldOnlineState)
	}
	if m.addprice != nil {
		fields = append(fields, novel.FieldPrice)
	}
	if m.addpublish != nil {
		fields = append(fields, novel.FieldPublish)
	}
	if m.addoriginalPrice != nil {
		fields = append(fields, novel.FieldOriginalPrice)
	}
	if m.addchapterPrice != nil {
		fields = append(fields, novel.FieldChapterPrice)
	}
	if m.addchapterCount != nil {
		fields = append(fields, novel.FieldChapterCount)
	}
	if m.addsignType != nil {
		fields = append(fields, novel.FieldSignType)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novel.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novel.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novel.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novel.FieldHits:
		return m.AddedHits()
	case novel.FieldScore:
		return m.AddedScore()
	case novel.FieldWordNum:
		return m.AddedWordNum()
	case novel.FieldFreeNum:
		return m.AddedFreeNum()
	case novel.FieldOnlineState:
		return m.AddedOnlineState()
	case novel.FieldPrice:
		return m.AddedPrice()
	case novel.FieldPublish:
		return m.AddedPublish()
	case novel.FieldOriginalPrice:
		return m.AddedOriginalPrice()
	case novel.FieldChapterPrice:
		return m.AddedChapterPrice()
	case novel.FieldChapterCount:
		return m.AddedChapterCount()
	case novel.FieldSignType:
		return m.AddedSignType()
	case novel.FieldCreateBy:
		return m.AddedCreateBy()
	case novel.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novel.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novel.FieldHits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHits(v)
		return nil
	case novel.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case novel.FieldWordNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordNum(v)
		return nil
	case novel.FieldFreeNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeNum(v)
		return nil
	case novel.FieldOnlineState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnlineState(v)
		return nil
	case novel.FieldPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case novel.FieldPublish:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublish(v)
		return nil
	case novel.FieldOriginalPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalPrice(v)
		return nil
	case novel.FieldChapterPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterPrice(v)
		return nil
	case novel.FieldChapterCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterCount(v)
		return nil
	case novel.FieldSignType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignType(v)
		return nil
	case novel.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novel.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novel.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown Novel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novel.FieldClassifyId) {
		fields = append(fields, novel.FieldClassifyId)
	}
	if m.FieldCleared(novel.FieldClassifyName) {
		fields = append(fields, novel.FieldClassifyName)
	}
	if m.FieldCleared(novel.FieldAuthorId) {
		fields = append(fields, novel.FieldAuthorId)
	}
	if m.FieldCleared(novel.FieldTitle) {
		fields = append(fields, novel.FieldTitle)
	}
	if m.FieldCleared(novel.FieldSummary) {
		fields = append(fields, novel.FieldSummary)
	}
	if m.FieldCleared(novel.FieldAuthor) {
		fields = append(fields, novel.FieldAuthor)
	}
	if m.FieldCleared(novel.FieldAnchor) {
		fields = append(fields, novel.FieldAnchor)
	}
	if m.FieldCleared(novel.FieldHits) {
		fields = append(fields, novel.FieldHits)
	}
	if m.FieldCleared(novel.FieldKeywords) {
		fields = append(fields, novel.FieldKeywords)
	}
	if m.FieldCleared(novel.FieldSource) {
		fields = append(fields, novel.FieldSource)
	}
	if m.FieldCleared(novel.FieldScore) {
		fields = append(fields, novel.FieldScore)
	}
	if m.FieldCleared(novel.FieldCover) {
		fields = append(fields, novel.FieldCover)
	}
	if m.FieldCleared(novel.FieldTagIds) {
		fields = append(fields, novel.FieldTagIds)
	}
	if m.FieldCleared(novel.FieldWordNum) {
		fields = append(fields, novel.FieldWordNum)
	}
	if m.FieldCleared(novel.FieldFreeNum) {
		fields = append(fields, novel.FieldFreeNum)
	}
	if m.FieldCleared(novel.FieldOnlineState) {
		fields = append(fields, novel.FieldOnlineState)
	}
	if m.FieldCleared(novel.FieldPrice) {
		fields = append(fields, novel.FieldPrice)
	}
	if m.FieldCleared(novel.FieldPublish) {
		fields = append(fields, novel.FieldPublish)
	}
	if m.FieldCleared(novel.FieldOriginalPrice) {
		fields = append(fields, novel.FieldOriginalPrice)
	}
	if m.FieldCleared(novel.FieldChapterPrice) {
		fields = append(fields, novel.FieldChapterPrice)
	}
	if m.FieldCleared(novel.FieldChapterCount) {
		fields = append(fields, novel.FieldChapterCount)
	}
	if m.FieldCleared(novel.FieldSignType) {
		fields = append(fields, novel.FieldSignType)
	}
	if m.FieldCleared(novel.FieldSignDate) {
		fields = append(fields, novel.FieldSignDate)
	}
	if m.FieldCleared(novel.FieldLeadingMan) {
		fields = append(fields, novel.FieldLeadingMan)
	}
	if m.FieldCleared(novel.FieldLeadingLady) {
		fields = append(fields, novel.FieldLeadingLady)
	}
	if m.FieldCleared(novel.FieldRemark) {
		fields = append(fields, novel.FieldRemark)
	}
	if m.FieldCleared(novel.FieldMediaKey) {
		fields = append(fields, novel.FieldMediaKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelMutation) ClearField(name string) error {
	switch name {
	case novel.FieldClassifyId:
		m.ClearClassifyId()
		return nil
	case novel.FieldClassifyName:
		m.ClearClassifyName()
		return nil
	case novel.FieldAuthorId:
		m.ClearAuthorId()
		return nil
	case novel.FieldTitle:
		m.ClearTitle()
		return nil
	case novel.FieldSummary:
		m.ClearSummary()
		return nil
	case novel.FieldAuthor:
		m.ClearAuthor()
		return nil
	case novel.FieldAnchor:
		m.ClearAnchor()
		return nil
	case novel.FieldHits:
		m.ClearHits()
		return nil
	case novel.FieldKeywords:
		m.ClearKeywords()
		return nil
	case novel.FieldSource:
		m.ClearSource()
		return nil
	case novel.FieldScore:
		m.ClearScore()
		return nil
	case novel.FieldCover:
		m.ClearCover()
		return nil
	case novel.FieldTagIds:
		m.ClearTagIds()
		return nil
	case novel.FieldWordNum:
		m.ClearWordNum()
		return nil
	case novel.FieldFreeNum:
		m.ClearFreeNum()
		return nil
	case novel.FieldOnlineState:
		m.ClearOnlineState()
		return nil
	case novel.FieldPrice:
		m.ClearPrice()
		return nil
	case novel.FieldPublish:
		m.ClearPublish()
		return nil
	case novel.FieldOriginalPrice:
		m.ClearOriginalPrice()
		return nil
	case novel.FieldChapterPrice:
		m.ClearChapterPrice()
		return nil
	case novel.FieldChapterCount:
		m.ClearChapterCount()
		return nil
	case novel.FieldSignType:
		m.ClearSignType()
		return nil
	case novel.FieldSignDate:
		m.ClearSignDate()
		return nil
	case novel.FieldLeadingMan:
		m.ClearLeadingMan()
		return nil
	case novel.FieldLeadingLady:
		m.ClearLeadingLady()
		return nil
	case novel.FieldRemark:
		m.ClearRemark()
		return nil
	case novel.FieldMediaKey:
		m.ClearMediaKey()
		return nil
	}
	return fmt.Errorf("unknown Novel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelMutation) ResetField(name string) error {
	switch name {
	case novel.FieldClassifyId:
		m.ResetClassifyId()
		return nil
	case novel.FieldClassifyName:
		m.ResetClassifyName()
		return nil
	case novel.FieldAuthorId:
		m.ResetAuthorId()
		return nil
	case novel.FieldTitle:
		m.ResetTitle()
		return nil
	case novel.FieldSummary:
		m.ResetSummary()
		return nil
	case novel.FieldAuthor:
		m.ResetAuthor()
		return nil
	case novel.FieldAnchor:
		m.ResetAnchor()
		return nil
	case novel.FieldHits:
		m.ResetHits()
		return nil
	case novel.FieldKeywords:
		m.ResetKeywords()
		return nil
	case novel.FieldSource:
		m.ResetSource()
		return nil
	case novel.FieldScore:
		m.ResetScore()
		return nil
	case novel.FieldCover:
		m.ResetCover()
		return nil
	case novel.FieldTagIds:
		m.ResetTagIds()
		return nil
	case novel.FieldWordNum:
		m.ResetWordNum()
		return nil
	case novel.FieldFreeNum:
		m.ResetFreeNum()
		return nil
	case novel.FieldOnlineState:
		m.ResetOnlineState()
		return nil
	case novel.FieldPrice:
		m.ResetPrice()
		return nil
	case novel.FieldPublish:
		m.ResetPublish()
		return nil
	case novel.FieldOriginalPrice:
		m.ResetOriginalPrice()
		return nil
	case novel.FieldChapterPrice:
		m.ResetChapterPrice()
		return nil
	case novel.FieldChapterCount:
		m.ResetChapterCount()
		return nil
	case novel.FieldSignType:
		m.ResetSignType()
		return nil
	case novel.FieldSignDate:
		m.ResetSignDate()
		return nil
	case novel.FieldLeadingMan:
		m.ResetLeadingMan()
		return nil
	case novel.FieldLeadingLady:
		m.ResetLeadingLady()
		return nil
	case novel.FieldRemark:
		m.ResetRemark()
		return nil
	case novel.FieldMediaKey:
		m.ResetMediaKey()
		return nil
	case novel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novel.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novel.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novel.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown Novel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.chapters != nil {
		edges = append(edges, novel.EdgeChapters)
	}
	if m.pkgs != nil {
		edges = append(edges, novel.EdgePkgs)
	}
	if m.classify != nil {
		edges = append(edges, novel.EdgeClassify)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novel.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	case novel.EdgePkgs:
		ids := make([]ent.Value, 0, len(m.pkgs))
		for id := range m.pkgs {
			ids = append(ids, id)
		}
		return ids
	case novel.EdgeClassify:
		if id := m.classify; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchapters != nil {
		edges = append(edges, novel.EdgeChapters)
	}
	if m.removedpkgs != nil {
		edges = append(edges, novel.EdgePkgs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case novel.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	case novel.EdgePkgs:
		ids := make([]ent.Value, 0, len(m.removedpkgs))
		for id := range m.removedpkgs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchapters {
		edges = append(edges, novel.EdgeChapters)
	}
	if m.clearedpkgs {
		edges = append(edges, novel.EdgePkgs)
	}
	if m.clearedclassify {
		edges = append(edges, novel.EdgeClassify)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelMutation) EdgeCleared(name string) bool {
	switch name {
	case novel.EdgeChapters:
		return m.clearedchapters
	case novel.EdgePkgs:
		return m.clearedpkgs
	case novel.EdgeClassify:
		return m.clearedclassify
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelMutation) ClearEdge(name string) error {
	switch name {
	case novel.EdgeClassify:
		m.ClearClassify()
		return nil
	}
	return fmt.Errorf("unknown Novel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelMutation) ResetEdge(name string) error {
	switch name {
	case novel.EdgeChapters:
		m.ResetChapters()
		return nil
	case novel.EdgePkgs:
		m.ResetPkgs()
		return nil
	case novel.EdgeClassify:
		m.ResetClassify()
		return nil
	}
	return fmt.Errorf("unknown Novel edge %s", name)
}

// NovelAutoBuyMutation represents an operation that mutates the NovelAutoBuy nodes in the graph.
type NovelAutoBuyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	novelId       *int64
	addnovelId    *int64
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*NovelAutoBuy, error)
	predicates    []predicate.NovelAutoBuy
}

var _ ent.Mutation = (*NovelAutoBuyMutation)(nil)

// novelautobuyOption allows management of the mutation configuration using functional options.
type novelautobuyOption func(*NovelAutoBuyMutation)

// newNovelAutoBuyMutation creates new mutation for the NovelAutoBuy entity.
func newNovelAutoBuyMutation(c config, op Op, opts ...novelautobuyOption) *NovelAutoBuyMutation {
	m := &NovelAutoBuyMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelAutoBuy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelAutoBuyID sets the ID field of the mutation.
func withNovelAutoBuyID(id int64) novelautobuyOption {
	return func(m *NovelAutoBuyMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelAutoBuy
		)
		m.oldValue = func(ctx context.Context) (*NovelAutoBuy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelAutoBuy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelAutoBuy sets the old NovelAutoBuy of the mutation.
func withNovelAutoBuy(node *NovelAutoBuy) novelautobuyOption {
	return func(m *NovelAutoBuyMutation) {
		m.oldValue = func(context.Context) (*NovelAutoBuy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelAutoBuyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelAutoBuyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelAutoBuyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelAutoBuyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelAutoBuy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *NovelAutoBuyMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *NovelAutoBuyMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *NovelAutoBuyMutation) ResetUserId() {
	m.user = nil
}

// SetNovelId sets the "novelId" field.
func (m *NovelAutoBuyMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelAutoBuyMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *NovelAutoBuyMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *NovelAutoBuyMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *NovelAutoBuyMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[novelautobuy.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *NovelAutoBuyMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[novelautobuy.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelAutoBuyMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, novelautobuy.FieldNovelId)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelAutoBuyMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelAutoBuyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelAutoBuyMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelAutoBuyMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelAutoBuyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelAutoBuyMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelAutoBuyMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelAutoBuyMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelAutoBuyMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelAutoBuyMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelAutoBuyMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelAutoBuyMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelAutoBuyMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelAutoBuyMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelAutoBuyMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelAutoBuyMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelAutoBuyMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelAutoBuyMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelAutoBuy entity.
// If the NovelAutoBuy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelAutoBuyMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelAutoBuyMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelAutoBuyMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelAutoBuyMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *NovelAutoBuyMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *NovelAutoBuyMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *NovelAutoBuyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NovelAutoBuyMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NovelAutoBuyMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NovelAutoBuyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NovelAutoBuyMutation builder.
func (m *NovelAutoBuyMutation) Where(ps ...predicate.NovelAutoBuy) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelAutoBuyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelAutoBuy).
func (m *NovelAutoBuyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelAutoBuyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, novelautobuy.FieldUserId)
	}
	if m.novelId != nil {
		fields = append(fields, novelautobuy.FieldNovelId)
	}
	if m.createdAt != nil {
		fields = append(fields, novelautobuy.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelautobuy.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelautobuy.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelautobuy.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelautobuy.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelAutoBuyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelautobuy.FieldUserId:
		return m.UserId()
	case novelautobuy.FieldNovelId:
		return m.NovelId()
	case novelautobuy.FieldCreatedAt:
		return m.CreatedAt()
	case novelautobuy.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelautobuy.FieldCreateBy:
		return m.CreateBy()
	case novelautobuy.FieldUpdateBy:
		return m.UpdateBy()
	case novelautobuy.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelAutoBuyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelautobuy.FieldUserId:
		return m.OldUserId(ctx)
	case novelautobuy.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelautobuy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelautobuy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelautobuy.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelautobuy.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelautobuy.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelAutoBuy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelAutoBuyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelautobuy.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case novelautobuy.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelautobuy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelautobuy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelautobuy.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelautobuy.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelautobuy.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelAutoBuy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelAutoBuyMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, novelautobuy.FieldNovelId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelautobuy.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelautobuy.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelautobuy.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelAutoBuyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelautobuy.FieldNovelId:
		return m.AddedNovelId()
	case novelautobuy.FieldCreateBy:
		return m.AddedCreateBy()
	case novelautobuy.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelautobuy.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelAutoBuyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelautobuy.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case novelautobuy.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelautobuy.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelautobuy.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelAutoBuy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelAutoBuyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelautobuy.FieldNovelId) {
		fields = append(fields, novelautobuy.FieldNovelId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelAutoBuyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelAutoBuyMutation) ClearField(name string) error {
	switch name {
	case novelautobuy.FieldNovelId:
		m.ClearNovelId()
		return nil
	}
	return fmt.Errorf("unknown NovelAutoBuy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelAutoBuyMutation) ResetField(name string) error {
	switch name {
	case novelautobuy.FieldUserId:
		m.ResetUserId()
		return nil
	case novelautobuy.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelautobuy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelautobuy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelautobuy.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelautobuy.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelautobuy.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelAutoBuy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelAutoBuyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, novelautobuy.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelAutoBuyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelautobuy.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelAutoBuyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelAutoBuyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelAutoBuyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, novelautobuy.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelAutoBuyMutation) EdgeCleared(name string) bool {
	switch name {
	case novelautobuy.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelAutoBuyMutation) ClearEdge(name string) error {
	switch name {
	case novelautobuy.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NovelAutoBuy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelAutoBuyMutation) ResetEdge(name string) error {
	switch name {
	case novelautobuy.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NovelAutoBuy edge %s", name)
}

// NovelBookshelfMutation represents an operation that mutates the NovelBookshelf nodes in the graph.
type NovelBookshelfMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	userName            *string
	novelId             *int64
	addnovelId          *int64
	lastReadTime        *time.Time
	lastChapterOrder    *int32
	addlastChapterOrder *int32
	lastChapterId       *int64
	addlastChapterId    *int64
	lastChapterName     *string
	remark              *string
	createdAt           *time.Time
	updatedAt           *time.Time
	createBy            *int64
	addcreateBy         *int64
	updateBy            *int64
	addupdateBy         *int64
	tenantId            *int64
	addtenantId         *int64
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*NovelBookshelf, error)
	predicates          []predicate.NovelBookshelf
}

var _ ent.Mutation = (*NovelBookshelfMutation)(nil)

// novelbookshelfOption allows management of the mutation configuration using functional options.
type novelbookshelfOption func(*NovelBookshelfMutation)

// newNovelBookshelfMutation creates new mutation for the NovelBookshelf entity.
func newNovelBookshelfMutation(c config, op Op, opts ...novelbookshelfOption) *NovelBookshelfMutation {
	m := &NovelBookshelfMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelBookshelf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelBookshelfID sets the ID field of the mutation.
func withNovelBookshelfID(id int64) novelbookshelfOption {
	return func(m *NovelBookshelfMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelBookshelf
		)
		m.oldValue = func(ctx context.Context) (*NovelBookshelf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelBookshelf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelBookshelf sets the old NovelBookshelf of the mutation.
func withNovelBookshelf(node *NovelBookshelf) novelbookshelfOption {
	return func(m *NovelBookshelfMutation) {
		m.oldValue = func(context.Context) (*NovelBookshelf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelBookshelfMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelBookshelfMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelBookshelfMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelBookshelfMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelBookshelf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *NovelBookshelfMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *NovelBookshelfMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *NovelBookshelfMutation) ResetUserId() {
	m.user = nil
}

// SetUserName sets the "userName" field.
func (m *NovelBookshelfMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *NovelBookshelfMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *NovelBookshelfMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[novelbookshelf.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *NovelBookshelfMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *NovelBookshelfMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, novelbookshelf.FieldUserName)
}

// SetNovelId sets the "novelId" field.
func (m *NovelBookshelfMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelBookshelfMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *NovelBookshelfMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *NovelBookshelfMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *NovelBookshelfMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[novelbookshelf.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *NovelBookshelfMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelBookshelfMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, novelbookshelf.FieldNovelId)
}

// SetLastReadTime sets the "lastReadTime" field.
func (m *NovelBookshelfMutation) SetLastReadTime(t time.Time) {
	m.lastReadTime = &t
}

// LastReadTime returns the value of the "lastReadTime" field in the mutation.
func (m *NovelBookshelfMutation) LastReadTime() (r time.Time, exists bool) {
	v := m.lastReadTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReadTime returns the old "lastReadTime" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldLastReadTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReadTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReadTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReadTime: %w", err)
	}
	return oldValue.LastReadTime, nil
}

// ClearLastReadTime clears the value of the "lastReadTime" field.
func (m *NovelBookshelfMutation) ClearLastReadTime() {
	m.lastReadTime = nil
	m.clearedFields[novelbookshelf.FieldLastReadTime] = struct{}{}
}

// LastReadTimeCleared returns if the "lastReadTime" field was cleared in this mutation.
func (m *NovelBookshelfMutation) LastReadTimeCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldLastReadTime]
	return ok
}

// ResetLastReadTime resets all changes to the "lastReadTime" field.
func (m *NovelBookshelfMutation) ResetLastReadTime() {
	m.lastReadTime = nil
	delete(m.clearedFields, novelbookshelf.FieldLastReadTime)
}

// SetLastChapterOrder sets the "lastChapterOrder" field.
func (m *NovelBookshelfMutation) SetLastChapterOrder(i int32) {
	m.lastChapterOrder = &i
	m.addlastChapterOrder = nil
}

// LastChapterOrder returns the value of the "lastChapterOrder" field in the mutation.
func (m *NovelBookshelfMutation) LastChapterOrder() (r int32, exists bool) {
	v := m.lastChapterOrder
	if v == nil {
		return
	}
	return *v, true
}

// OldLastChapterOrder returns the old "lastChapterOrder" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldLastChapterOrder(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastChapterOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastChapterOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastChapterOrder: %w", err)
	}
	return oldValue.LastChapterOrder, nil
}

// AddLastChapterOrder adds i to the "lastChapterOrder" field.
func (m *NovelBookshelfMutation) AddLastChapterOrder(i int32) {
	if m.addlastChapterOrder != nil {
		*m.addlastChapterOrder += i
	} else {
		m.addlastChapterOrder = &i
	}
}

// AddedLastChapterOrder returns the value that was added to the "lastChapterOrder" field in this mutation.
func (m *NovelBookshelfMutation) AddedLastChapterOrder() (r int32, exists bool) {
	v := m.addlastChapterOrder
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastChapterOrder clears the value of the "lastChapterOrder" field.
func (m *NovelBookshelfMutation) ClearLastChapterOrder() {
	m.lastChapterOrder = nil
	m.addlastChapterOrder = nil
	m.clearedFields[novelbookshelf.FieldLastChapterOrder] = struct{}{}
}

// LastChapterOrderCleared returns if the "lastChapterOrder" field was cleared in this mutation.
func (m *NovelBookshelfMutation) LastChapterOrderCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldLastChapterOrder]
	return ok
}

// ResetLastChapterOrder resets all changes to the "lastChapterOrder" field.
func (m *NovelBookshelfMutation) ResetLastChapterOrder() {
	m.lastChapterOrder = nil
	m.addlastChapterOrder = nil
	delete(m.clearedFields, novelbookshelf.FieldLastChapterOrder)
}

// SetLastChapterId sets the "lastChapterId" field.
func (m *NovelBookshelfMutation) SetLastChapterId(i int64) {
	m.lastChapterId = &i
	m.addlastChapterId = nil
}

// LastChapterId returns the value of the "lastChapterId" field in the mutation.
func (m *NovelBookshelfMutation) LastChapterId() (r int64, exists bool) {
	v := m.lastChapterId
	if v == nil {
		return
	}
	return *v, true
}

// OldLastChapterId returns the old "lastChapterId" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldLastChapterId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastChapterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastChapterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastChapterId: %w", err)
	}
	return oldValue.LastChapterId, nil
}

// AddLastChapterId adds i to the "lastChapterId" field.
func (m *NovelBookshelfMutation) AddLastChapterId(i int64) {
	if m.addlastChapterId != nil {
		*m.addlastChapterId += i
	} else {
		m.addlastChapterId = &i
	}
}

// AddedLastChapterId returns the value that was added to the "lastChapterId" field in this mutation.
func (m *NovelBookshelfMutation) AddedLastChapterId() (r int64, exists bool) {
	v := m.addlastChapterId
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastChapterId clears the value of the "lastChapterId" field.
func (m *NovelBookshelfMutation) ClearLastChapterId() {
	m.lastChapterId = nil
	m.addlastChapterId = nil
	m.clearedFields[novelbookshelf.FieldLastChapterId] = struct{}{}
}

// LastChapterIdCleared returns if the "lastChapterId" field was cleared in this mutation.
func (m *NovelBookshelfMutation) LastChapterIdCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldLastChapterId]
	return ok
}

// ResetLastChapterId resets all changes to the "lastChapterId" field.
func (m *NovelBookshelfMutation) ResetLastChapterId() {
	m.lastChapterId = nil
	m.addlastChapterId = nil
	delete(m.clearedFields, novelbookshelf.FieldLastChapterId)
}

// SetLastChapterName sets the "lastChapterName" field.
func (m *NovelBookshelfMutation) SetLastChapterName(s string) {
	m.lastChapterName = &s
}

// LastChapterName returns the value of the "lastChapterName" field in the mutation.
func (m *NovelBookshelfMutation) LastChapterName() (r string, exists bool) {
	v := m.lastChapterName
	if v == nil {
		return
	}
	return *v, true
}

// OldLastChapterName returns the old "lastChapterName" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldLastChapterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastChapterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastChapterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastChapterName: %w", err)
	}
	return oldValue.LastChapterName, nil
}

// ClearLastChapterName clears the value of the "lastChapterName" field.
func (m *NovelBookshelfMutation) ClearLastChapterName() {
	m.lastChapterName = nil
	m.clearedFields[novelbookshelf.FieldLastChapterName] = struct{}{}
}

// LastChapterNameCleared returns if the "lastChapterName" field was cleared in this mutation.
func (m *NovelBookshelfMutation) LastChapterNameCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldLastChapterName]
	return ok
}

// ResetLastChapterName resets all changes to the "lastChapterName" field.
func (m *NovelBookshelfMutation) ResetLastChapterName() {
	m.lastChapterName = nil
	delete(m.clearedFields, novelbookshelf.FieldLastChapterName)
}

// SetRemark sets the "remark" field.
func (m *NovelBookshelfMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelBookshelfMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelBookshelfMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelbookshelf.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelBookshelfMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelbookshelf.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelBookshelfMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelbookshelf.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelBookshelfMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelBookshelfMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelBookshelfMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelBookshelfMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelBookshelfMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelBookshelfMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelBookshelfMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelBookshelfMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelBookshelfMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelBookshelfMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelBookshelfMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelBookshelfMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelBookshelfMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelBookshelfMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelBookshelfMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelBookshelfMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelBookshelfMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelBookshelfMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelBookshelf entity.
// If the NovelBookshelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBookshelfMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelBookshelfMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelBookshelfMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelBookshelfMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *NovelBookshelfMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *NovelBookshelfMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *NovelBookshelfMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NovelBookshelfMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NovelBookshelfMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NovelBookshelfMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NovelBookshelfMutation builder.
func (m *NovelBookshelfMutation) Where(ps ...predicate.NovelBookshelf) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelBookshelfMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelBookshelf).
func (m *NovelBookshelfMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelBookshelfMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, novelbookshelf.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, novelbookshelf.FieldUserName)
	}
	if m.novelId != nil {
		fields = append(fields, novelbookshelf.FieldNovelId)
	}
	if m.lastReadTime != nil {
		fields = append(fields, novelbookshelf.FieldLastReadTime)
	}
	if m.lastChapterOrder != nil {
		fields = append(fields, novelbookshelf.FieldLastChapterOrder)
	}
	if m.lastChapterId != nil {
		fields = append(fields, novelbookshelf.FieldLastChapterId)
	}
	if m.lastChapterName != nil {
		fields = append(fields, novelbookshelf.FieldLastChapterName)
	}
	if m.remark != nil {
		fields = append(fields, novelbookshelf.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, novelbookshelf.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelbookshelf.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelbookshelf.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelbookshelf.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelbookshelf.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelBookshelfMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelbookshelf.FieldUserId:
		return m.UserId()
	case novelbookshelf.FieldUserName:
		return m.UserName()
	case novelbookshelf.FieldNovelId:
		return m.NovelId()
	case novelbookshelf.FieldLastReadTime:
		return m.LastReadTime()
	case novelbookshelf.FieldLastChapterOrder:
		return m.LastChapterOrder()
	case novelbookshelf.FieldLastChapterId:
		return m.LastChapterId()
	case novelbookshelf.FieldLastChapterName:
		return m.LastChapterName()
	case novelbookshelf.FieldRemark:
		return m.Remark()
	case novelbookshelf.FieldCreatedAt:
		return m.CreatedAt()
	case novelbookshelf.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelbookshelf.FieldCreateBy:
		return m.CreateBy()
	case novelbookshelf.FieldUpdateBy:
		return m.UpdateBy()
	case novelbookshelf.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelBookshelfMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelbookshelf.FieldUserId:
		return m.OldUserId(ctx)
	case novelbookshelf.FieldUserName:
		return m.OldUserName(ctx)
	case novelbookshelf.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelbookshelf.FieldLastReadTime:
		return m.OldLastReadTime(ctx)
	case novelbookshelf.FieldLastChapterOrder:
		return m.OldLastChapterOrder(ctx)
	case novelbookshelf.FieldLastChapterId:
		return m.OldLastChapterId(ctx)
	case novelbookshelf.FieldLastChapterName:
		return m.OldLastChapterName(ctx)
	case novelbookshelf.FieldRemark:
		return m.OldRemark(ctx)
	case novelbookshelf.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelbookshelf.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelbookshelf.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelbookshelf.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelbookshelf.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelBookshelf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelBookshelfMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelbookshelf.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case novelbookshelf.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case novelbookshelf.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelbookshelf.FieldLastReadTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReadTime(v)
		return nil
	case novelbookshelf.FieldLastChapterOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastChapterOrder(v)
		return nil
	case novelbookshelf.FieldLastChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastChapterId(v)
		return nil
	case novelbookshelf.FieldLastChapterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastChapterName(v)
		return nil
	case novelbookshelf.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelbookshelf.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelbookshelf.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelbookshelf.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelbookshelf.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelbookshelf.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelBookshelf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelBookshelfMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, novelbookshelf.FieldNovelId)
	}
	if m.addlastChapterOrder != nil {
		fields = append(fields, novelbookshelf.FieldLastChapterOrder)
	}
	if m.addlastChapterId != nil {
		fields = append(fields, novelbookshelf.FieldLastChapterId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelbookshelf.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelbookshelf.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelbookshelf.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelBookshelfMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelbookshelf.FieldNovelId:
		return m.AddedNovelId()
	case novelbookshelf.FieldLastChapterOrder:
		return m.AddedLastChapterOrder()
	case novelbookshelf.FieldLastChapterId:
		return m.AddedLastChapterId()
	case novelbookshelf.FieldCreateBy:
		return m.AddedCreateBy()
	case novelbookshelf.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelbookshelf.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelBookshelfMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelbookshelf.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case novelbookshelf.FieldLastChapterOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastChapterOrder(v)
		return nil
	case novelbookshelf.FieldLastChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastChapterId(v)
		return nil
	case novelbookshelf.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelbookshelf.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelbookshelf.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelBookshelf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelBookshelfMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelbookshelf.FieldUserName) {
		fields = append(fields, novelbookshelf.FieldUserName)
	}
	if m.FieldCleared(novelbookshelf.FieldNovelId) {
		fields = append(fields, novelbookshelf.FieldNovelId)
	}
	if m.FieldCleared(novelbookshelf.FieldLastReadTime) {
		fields = append(fields, novelbookshelf.FieldLastReadTime)
	}
	if m.FieldCleared(novelbookshelf.FieldLastChapterOrder) {
		fields = append(fields, novelbookshelf.FieldLastChapterOrder)
	}
	if m.FieldCleared(novelbookshelf.FieldLastChapterId) {
		fields = append(fields, novelbookshelf.FieldLastChapterId)
	}
	if m.FieldCleared(novelbookshelf.FieldLastChapterName) {
		fields = append(fields, novelbookshelf.FieldLastChapterName)
	}
	if m.FieldCleared(novelbookshelf.FieldRemark) {
		fields = append(fields, novelbookshelf.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelBookshelfMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelBookshelfMutation) ClearField(name string) error {
	switch name {
	case novelbookshelf.FieldUserName:
		m.ClearUserName()
		return nil
	case novelbookshelf.FieldNovelId:
		m.ClearNovelId()
		return nil
	case novelbookshelf.FieldLastReadTime:
		m.ClearLastReadTime()
		return nil
	case novelbookshelf.FieldLastChapterOrder:
		m.ClearLastChapterOrder()
		return nil
	case novelbookshelf.FieldLastChapterId:
		m.ClearLastChapterId()
		return nil
	case novelbookshelf.FieldLastChapterName:
		m.ClearLastChapterName()
		return nil
	case novelbookshelf.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelBookshelf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelBookshelfMutation) ResetField(name string) error {
	switch name {
	case novelbookshelf.FieldUserId:
		m.ResetUserId()
		return nil
	case novelbookshelf.FieldUserName:
		m.ResetUserName()
		return nil
	case novelbookshelf.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelbookshelf.FieldLastReadTime:
		m.ResetLastReadTime()
		return nil
	case novelbookshelf.FieldLastChapterOrder:
		m.ResetLastChapterOrder()
		return nil
	case novelbookshelf.FieldLastChapterId:
		m.ResetLastChapterId()
		return nil
	case novelbookshelf.FieldLastChapterName:
		m.ResetLastChapterName()
		return nil
	case novelbookshelf.FieldRemark:
		m.ResetRemark()
		return nil
	case novelbookshelf.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelbookshelf.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelbookshelf.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelbookshelf.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelbookshelf.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelBookshelf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelBookshelfMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, novelbookshelf.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelBookshelfMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelbookshelf.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelBookshelfMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelBookshelfMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelBookshelfMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, novelbookshelf.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelBookshelfMutation) EdgeCleared(name string) bool {
	switch name {
	case novelbookshelf.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelBookshelfMutation) ClearEdge(name string) error {
	switch name {
	case novelbookshelf.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NovelBookshelf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelBookshelfMutation) ResetEdge(name string) error {
	switch name {
	case novelbookshelf.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NovelBookshelf edge %s", name)
}

// NovelBuyChapterRecordMutation represents an operation that mutates the NovelBuyChapterRecord nodes in the graph.
type NovelBuyChapterRecordMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	userName           *string
	chapterId          *int64
	addchapterId       *int64
	chapterOrderNum    *int32
	addchapterOrderNum *int32
	novelId            *int64
	addnovelId         *int64
	novelName          *string
	chapterName        *string
	isSvip             *bool
	coin               *int64
	addcoin            *int64
	coupon             *int64
	addcoupon          *int64
	discount           *int64
	adddiscount        *int64
	remark             *string
	createdAt          *time.Time
	updatedAt          *time.Time
	createBy           *int64
	addcreateBy        *int64
	updateBy           *int64
	addupdateBy        *int64
	tenantId           *int64
	addtenantId        *int64
	clearedFields      map[string]struct{}
	user               *int64
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*NovelBuyChapterRecord, error)
	predicates         []predicate.NovelBuyChapterRecord
}

var _ ent.Mutation = (*NovelBuyChapterRecordMutation)(nil)

// novelbuychapterrecordOption allows management of the mutation configuration using functional options.
type novelbuychapterrecordOption func(*NovelBuyChapterRecordMutation)

// newNovelBuyChapterRecordMutation creates new mutation for the NovelBuyChapterRecord entity.
func newNovelBuyChapterRecordMutation(c config, op Op, opts ...novelbuychapterrecordOption) *NovelBuyChapterRecordMutation {
	m := &NovelBuyChapterRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelBuyChapterRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelBuyChapterRecordID sets the ID field of the mutation.
func withNovelBuyChapterRecordID(id int64) novelbuychapterrecordOption {
	return func(m *NovelBuyChapterRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelBuyChapterRecord
		)
		m.oldValue = func(ctx context.Context) (*NovelBuyChapterRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelBuyChapterRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelBuyChapterRecord sets the old NovelBuyChapterRecord of the mutation.
func withNovelBuyChapterRecord(node *NovelBuyChapterRecord) novelbuychapterrecordOption {
	return func(m *NovelBuyChapterRecordMutation) {
		m.oldValue = func(context.Context) (*NovelBuyChapterRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelBuyChapterRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelBuyChapterRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelBuyChapterRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelBuyChapterRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelBuyChapterRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *NovelBuyChapterRecordMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *NovelBuyChapterRecordMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *NovelBuyChapterRecordMutation) ResetUserId() {
	m.user = nil
}

// SetUserName sets the "userName" field.
func (m *NovelBuyChapterRecordMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *NovelBuyChapterRecordMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *NovelBuyChapterRecordMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[novelbuychapterrecord.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *NovelBuyChapterRecordMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldUserName)
}

// SetChapterId sets the "chapterId" field.
func (m *NovelBuyChapterRecordMutation) SetChapterId(i int64) {
	m.chapterId = &i
	m.addchapterId = nil
}

// ChapterId returns the value of the "chapterId" field in the mutation.
func (m *NovelBuyChapterRecordMutation) ChapterId() (r int64, exists bool) {
	v := m.chapterId
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterId returns the old "chapterId" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldChapterId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterId: %w", err)
	}
	return oldValue.ChapterId, nil
}

// AddChapterId adds i to the "chapterId" field.
func (m *NovelBuyChapterRecordMutation) AddChapterId(i int64) {
	if m.addchapterId != nil {
		*m.addchapterId += i
	} else {
		m.addchapterId = &i
	}
}

// AddedChapterId returns the value that was added to the "chapterId" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedChapterId() (r int64, exists bool) {
	v := m.addchapterId
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterId clears the value of the "chapterId" field.
func (m *NovelBuyChapterRecordMutation) ClearChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
	m.clearedFields[novelbuychapterrecord.FieldChapterId] = struct{}{}
}

// ChapterIdCleared returns if the "chapterId" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) ChapterIdCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldChapterId]
	return ok
}

// ResetChapterId resets all changes to the "chapterId" field.
func (m *NovelBuyChapterRecordMutation) ResetChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldChapterId)
}

// SetChapterOrderNum sets the "chapterOrderNum" field.
func (m *NovelBuyChapterRecordMutation) SetChapterOrderNum(i int32) {
	m.chapterOrderNum = &i
	m.addchapterOrderNum = nil
}

// ChapterOrderNum returns the value of the "chapterOrderNum" field in the mutation.
func (m *NovelBuyChapterRecordMutation) ChapterOrderNum() (r int32, exists bool) {
	v := m.chapterOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterOrderNum returns the old "chapterOrderNum" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldChapterOrderNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterOrderNum: %w", err)
	}
	return oldValue.ChapterOrderNum, nil
}

// AddChapterOrderNum adds i to the "chapterOrderNum" field.
func (m *NovelBuyChapterRecordMutation) AddChapterOrderNum(i int32) {
	if m.addchapterOrderNum != nil {
		*m.addchapterOrderNum += i
	} else {
		m.addchapterOrderNum = &i
	}
}

// AddedChapterOrderNum returns the value that was added to the "chapterOrderNum" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedChapterOrderNum() (r int32, exists bool) {
	v := m.addchapterOrderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterOrderNum clears the value of the "chapterOrderNum" field.
func (m *NovelBuyChapterRecordMutation) ClearChapterOrderNum() {
	m.chapterOrderNum = nil
	m.addchapterOrderNum = nil
	m.clearedFields[novelbuychapterrecord.FieldChapterOrderNum] = struct{}{}
}

// ChapterOrderNumCleared returns if the "chapterOrderNum" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) ChapterOrderNumCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldChapterOrderNum]
	return ok
}

// ResetChapterOrderNum resets all changes to the "chapterOrderNum" field.
func (m *NovelBuyChapterRecordMutation) ResetChapterOrderNum() {
	m.chapterOrderNum = nil
	m.addchapterOrderNum = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldChapterOrderNum)
}

// SetNovelId sets the "novelId" field.
func (m *NovelBuyChapterRecordMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelBuyChapterRecordMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *NovelBuyChapterRecordMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *NovelBuyChapterRecordMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[novelbuychapterrecord.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelBuyChapterRecordMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldNovelId)
}

// SetNovelName sets the "novelName" field.
func (m *NovelBuyChapterRecordMutation) SetNovelName(s string) {
	m.novelName = &s
}

// NovelName returns the value of the "novelName" field in the mutation.
func (m *NovelBuyChapterRecordMutation) NovelName() (r string, exists bool) {
	v := m.novelName
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelName returns the old "novelName" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldNovelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelName: %w", err)
	}
	return oldValue.NovelName, nil
}

// ClearNovelName clears the value of the "novelName" field.
func (m *NovelBuyChapterRecordMutation) ClearNovelName() {
	m.novelName = nil
	m.clearedFields[novelbuychapterrecord.FieldNovelName] = struct{}{}
}

// NovelNameCleared returns if the "novelName" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) NovelNameCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldNovelName]
	return ok
}

// ResetNovelName resets all changes to the "novelName" field.
func (m *NovelBuyChapterRecordMutation) ResetNovelName() {
	m.novelName = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldNovelName)
}

// SetChapterName sets the "chapterName" field.
func (m *NovelBuyChapterRecordMutation) SetChapterName(s string) {
	m.chapterName = &s
}

// ChapterName returns the value of the "chapterName" field in the mutation.
func (m *NovelBuyChapterRecordMutation) ChapterName() (r string, exists bool) {
	v := m.chapterName
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterName returns the old "chapterName" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldChapterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterName: %w", err)
	}
	return oldValue.ChapterName, nil
}

// ClearChapterName clears the value of the "chapterName" field.
func (m *NovelBuyChapterRecordMutation) ClearChapterName() {
	m.chapterName = nil
	m.clearedFields[novelbuychapterrecord.FieldChapterName] = struct{}{}
}

// ChapterNameCleared returns if the "chapterName" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) ChapterNameCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldChapterName]
	return ok
}

// ResetChapterName resets all changes to the "chapterName" field.
func (m *NovelBuyChapterRecordMutation) ResetChapterName() {
	m.chapterName = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldChapterName)
}

// SetIsSvip sets the "isSvip" field.
func (m *NovelBuyChapterRecordMutation) SetIsSvip(b bool) {
	m.isSvip = &b
}

// IsSvip returns the value of the "isSvip" field in the mutation.
func (m *NovelBuyChapterRecordMutation) IsSvip() (r bool, exists bool) {
	v := m.isSvip
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSvip returns the old "isSvip" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldIsSvip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSvip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSvip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSvip: %w", err)
	}
	return oldValue.IsSvip, nil
}

// ClearIsSvip clears the value of the "isSvip" field.
func (m *NovelBuyChapterRecordMutation) ClearIsSvip() {
	m.isSvip = nil
	m.clearedFields[novelbuychapterrecord.FieldIsSvip] = struct{}{}
}

// IsSvipCleared returns if the "isSvip" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) IsSvipCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldIsSvip]
	return ok
}

// ResetIsSvip resets all changes to the "isSvip" field.
func (m *NovelBuyChapterRecordMutation) ResetIsSvip() {
	m.isSvip = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldIsSvip)
}

// SetCoin sets the "coin" field.
func (m *NovelBuyChapterRecordMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *NovelBuyChapterRecordMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *NovelBuyChapterRecordMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoin clears the value of the "coin" field.
func (m *NovelBuyChapterRecordMutation) ClearCoin() {
	m.coin = nil
	m.addcoin = nil
	m.clearedFields[novelbuychapterrecord.FieldCoin] = struct{}{}
}

// CoinCleared returns if the "coin" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) CoinCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldCoin]
	return ok
}

// ResetCoin resets all changes to the "coin" field.
func (m *NovelBuyChapterRecordMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldCoin)
}

// SetCoupon sets the "coupon" field.
func (m *NovelBuyChapterRecordMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *NovelBuyChapterRecordMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *NovelBuyChapterRecordMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoupon clears the value of the "coupon" field.
func (m *NovelBuyChapterRecordMutation) ClearCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	m.clearedFields[novelbuychapterrecord.FieldCoupon] = struct{}{}
}

// CouponCleared returns if the "coupon" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) CouponCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldCoupon]
	return ok
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *NovelBuyChapterRecordMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldCoupon)
}

// SetDiscount sets the "discount" field.
func (m *NovelBuyChapterRecordMutation) SetDiscount(i int64) {
	m.discount = &i
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *NovelBuyChapterRecordMutation) Discount() (r int64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldDiscount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds i to the "discount" field.
func (m *NovelBuyChapterRecordMutation) AddDiscount(i int64) {
	if m.adddiscount != nil {
		*m.adddiscount += i
	} else {
		m.adddiscount = &i
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedDiscount() (r int64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiscount clears the value of the "discount" field.
func (m *NovelBuyChapterRecordMutation) ClearDiscount() {
	m.discount = nil
	m.adddiscount = nil
	m.clearedFields[novelbuychapterrecord.FieldDiscount] = struct{}{}
}

// DiscountCleared returns if the "discount" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) DiscountCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldDiscount]
	return ok
}

// ResetDiscount resets all changes to the "discount" field.
func (m *NovelBuyChapterRecordMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldDiscount)
}

// SetRemark sets the "remark" field.
func (m *NovelBuyChapterRecordMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelBuyChapterRecordMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelBuyChapterRecordMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelbuychapterrecord.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelbuychapterrecord.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelBuyChapterRecordMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelbuychapterrecord.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelBuyChapterRecordMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelBuyChapterRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelBuyChapterRecordMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelBuyChapterRecordMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelBuyChapterRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelBuyChapterRecordMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelBuyChapterRecordMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelBuyChapterRecordMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelBuyChapterRecordMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelBuyChapterRecordMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelBuyChapterRecordMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelBuyChapterRecordMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelBuyChapterRecordMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelBuyChapterRecordMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelBuyChapterRecordMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelBuyChapterRecordMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelBuyChapterRecord entity.
// If the NovelBuyChapterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyChapterRecordMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelBuyChapterRecordMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelBuyChapterRecordMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *NovelBuyChapterRecordMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *NovelBuyChapterRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *NovelBuyChapterRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NovelBuyChapterRecordMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NovelBuyChapterRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NovelBuyChapterRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NovelBuyChapterRecordMutation builder.
func (m *NovelBuyChapterRecordMutation) Where(ps ...predicate.NovelBuyChapterRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelBuyChapterRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelBuyChapterRecord).
func (m *NovelBuyChapterRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelBuyChapterRecordMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.user != nil {
		fields = append(fields, novelbuychapterrecord.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, novelbuychapterrecord.FieldUserName)
	}
	if m.chapterId != nil {
		fields = append(fields, novelbuychapterrecord.FieldChapterId)
	}
	if m.chapterOrderNum != nil {
		fields = append(fields, novelbuychapterrecord.FieldChapterOrderNum)
	}
	if m.novelId != nil {
		fields = append(fields, novelbuychapterrecord.FieldNovelId)
	}
	if m.novelName != nil {
		fields = append(fields, novelbuychapterrecord.FieldNovelName)
	}
	if m.chapterName != nil {
		fields = append(fields, novelbuychapterrecord.FieldChapterName)
	}
	if m.isSvip != nil {
		fields = append(fields, novelbuychapterrecord.FieldIsSvip)
	}
	if m.coin != nil {
		fields = append(fields, novelbuychapterrecord.FieldCoin)
	}
	if m.coupon != nil {
		fields = append(fields, novelbuychapterrecord.FieldCoupon)
	}
	if m.discount != nil {
		fields = append(fields, novelbuychapterrecord.FieldDiscount)
	}
	if m.remark != nil {
		fields = append(fields, novelbuychapterrecord.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, novelbuychapterrecord.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelbuychapterrecord.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelbuychapterrecord.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelbuychapterrecord.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelbuychapterrecord.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelBuyChapterRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelbuychapterrecord.FieldUserId:
		return m.UserId()
	case novelbuychapterrecord.FieldUserName:
		return m.UserName()
	case novelbuychapterrecord.FieldChapterId:
		return m.ChapterId()
	case novelbuychapterrecord.FieldChapterOrderNum:
		return m.ChapterOrderNum()
	case novelbuychapterrecord.FieldNovelId:
		return m.NovelId()
	case novelbuychapterrecord.FieldNovelName:
		return m.NovelName()
	case novelbuychapterrecord.FieldChapterName:
		return m.ChapterName()
	case novelbuychapterrecord.FieldIsSvip:
		return m.IsSvip()
	case novelbuychapterrecord.FieldCoin:
		return m.Coin()
	case novelbuychapterrecord.FieldCoupon:
		return m.Coupon()
	case novelbuychapterrecord.FieldDiscount:
		return m.Discount()
	case novelbuychapterrecord.FieldRemark:
		return m.Remark()
	case novelbuychapterrecord.FieldCreatedAt:
		return m.CreatedAt()
	case novelbuychapterrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelbuychapterrecord.FieldCreateBy:
		return m.CreateBy()
	case novelbuychapterrecord.FieldUpdateBy:
		return m.UpdateBy()
	case novelbuychapterrecord.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelBuyChapterRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelbuychapterrecord.FieldUserId:
		return m.OldUserId(ctx)
	case novelbuychapterrecord.FieldUserName:
		return m.OldUserName(ctx)
	case novelbuychapterrecord.FieldChapterId:
		return m.OldChapterId(ctx)
	case novelbuychapterrecord.FieldChapterOrderNum:
		return m.OldChapterOrderNum(ctx)
	case novelbuychapterrecord.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelbuychapterrecord.FieldNovelName:
		return m.OldNovelName(ctx)
	case novelbuychapterrecord.FieldChapterName:
		return m.OldChapterName(ctx)
	case novelbuychapterrecord.FieldIsSvip:
		return m.OldIsSvip(ctx)
	case novelbuychapterrecord.FieldCoin:
		return m.OldCoin(ctx)
	case novelbuychapterrecord.FieldCoupon:
		return m.OldCoupon(ctx)
	case novelbuychapterrecord.FieldDiscount:
		return m.OldDiscount(ctx)
	case novelbuychapterrecord.FieldRemark:
		return m.OldRemark(ctx)
	case novelbuychapterrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelbuychapterrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelbuychapterrecord.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelbuychapterrecord.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelbuychapterrecord.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelBuyChapterRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelBuyChapterRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelbuychapterrecord.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case novelbuychapterrecord.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case novelbuychapterrecord.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterId(v)
		return nil
	case novelbuychapterrecord.FieldChapterOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterOrderNum(v)
		return nil
	case novelbuychapterrecord.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelbuychapterrecord.FieldNovelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelName(v)
		return nil
	case novelbuychapterrecord.FieldChapterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterName(v)
		return nil
	case novelbuychapterrecord.FieldIsSvip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSvip(v)
		return nil
	case novelbuychapterrecord.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case novelbuychapterrecord.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case novelbuychapterrecord.FieldDiscount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case novelbuychapterrecord.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelbuychapterrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelbuychapterrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelbuychapterrecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelbuychapterrecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelbuychapterrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelBuyChapterRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelBuyChapterRecordMutation) AddedFields() []string {
	var fields []string
	if m.addchapterId != nil {
		fields = append(fields, novelbuychapterrecord.FieldChapterId)
	}
	if m.addchapterOrderNum != nil {
		fields = append(fields, novelbuychapterrecord.FieldChapterOrderNum)
	}
	if m.addnovelId != nil {
		fields = append(fields, novelbuychapterrecord.FieldNovelId)
	}
	if m.addcoin != nil {
		fields = append(fields, novelbuychapterrecord.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, novelbuychapterrecord.FieldCoupon)
	}
	if m.adddiscount != nil {
		fields = append(fields, novelbuychapterrecord.FieldDiscount)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelbuychapterrecord.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelbuychapterrecord.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelbuychapterrecord.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelBuyChapterRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelbuychapterrecord.FieldChapterId:
		return m.AddedChapterId()
	case novelbuychapterrecord.FieldChapterOrderNum:
		return m.AddedChapterOrderNum()
	case novelbuychapterrecord.FieldNovelId:
		return m.AddedNovelId()
	case novelbuychapterrecord.FieldCoin:
		return m.AddedCoin()
	case novelbuychapterrecord.FieldCoupon:
		return m.AddedCoupon()
	case novelbuychapterrecord.FieldDiscount:
		return m.AddedDiscount()
	case novelbuychapterrecord.FieldCreateBy:
		return m.AddedCreateBy()
	case novelbuychapterrecord.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelbuychapterrecord.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelBuyChapterRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelbuychapterrecord.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterId(v)
		return nil
	case novelbuychapterrecord.FieldChapterOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterOrderNum(v)
		return nil
	case novelbuychapterrecord.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case novelbuychapterrecord.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case novelbuychapterrecord.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case novelbuychapterrecord.FieldDiscount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case novelbuychapterrecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelbuychapterrecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelbuychapterrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelBuyChapterRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelBuyChapterRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelbuychapterrecord.FieldUserName) {
		fields = append(fields, novelbuychapterrecord.FieldUserName)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldChapterId) {
		fields = append(fields, novelbuychapterrecord.FieldChapterId)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldChapterOrderNum) {
		fields = append(fields, novelbuychapterrecord.FieldChapterOrderNum)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldNovelId) {
		fields = append(fields, novelbuychapterrecord.FieldNovelId)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldNovelName) {
		fields = append(fields, novelbuychapterrecord.FieldNovelName)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldChapterName) {
		fields = append(fields, novelbuychapterrecord.FieldChapterName)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldIsSvip) {
		fields = append(fields, novelbuychapterrecord.FieldIsSvip)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldCoin) {
		fields = append(fields, novelbuychapterrecord.FieldCoin)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldCoupon) {
		fields = append(fields, novelbuychapterrecord.FieldCoupon)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldDiscount) {
		fields = append(fields, novelbuychapterrecord.FieldDiscount)
	}
	if m.FieldCleared(novelbuychapterrecord.FieldRemark) {
		fields = append(fields, novelbuychapterrecord.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelBuyChapterRecordMutation) ClearField(name string) error {
	switch name {
	case novelbuychapterrecord.FieldUserName:
		m.ClearUserName()
		return nil
	case novelbuychapterrecord.FieldChapterId:
		m.ClearChapterId()
		return nil
	case novelbuychapterrecord.FieldChapterOrderNum:
		m.ClearChapterOrderNum()
		return nil
	case novelbuychapterrecord.FieldNovelId:
		m.ClearNovelId()
		return nil
	case novelbuychapterrecord.FieldNovelName:
		m.ClearNovelName()
		return nil
	case novelbuychapterrecord.FieldChapterName:
		m.ClearChapterName()
		return nil
	case novelbuychapterrecord.FieldIsSvip:
		m.ClearIsSvip()
		return nil
	case novelbuychapterrecord.FieldCoin:
		m.ClearCoin()
		return nil
	case novelbuychapterrecord.FieldCoupon:
		m.ClearCoupon()
		return nil
	case novelbuychapterrecord.FieldDiscount:
		m.ClearDiscount()
		return nil
	case novelbuychapterrecord.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyChapterRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelBuyChapterRecordMutation) ResetField(name string) error {
	switch name {
	case novelbuychapterrecord.FieldUserId:
		m.ResetUserId()
		return nil
	case novelbuychapterrecord.FieldUserName:
		m.ResetUserName()
		return nil
	case novelbuychapterrecord.FieldChapterId:
		m.ResetChapterId()
		return nil
	case novelbuychapterrecord.FieldChapterOrderNum:
		m.ResetChapterOrderNum()
		return nil
	case novelbuychapterrecord.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelbuychapterrecord.FieldNovelName:
		m.ResetNovelName()
		return nil
	case novelbuychapterrecord.FieldChapterName:
		m.ResetChapterName()
		return nil
	case novelbuychapterrecord.FieldIsSvip:
		m.ResetIsSvip()
		return nil
	case novelbuychapterrecord.FieldCoin:
		m.ResetCoin()
		return nil
	case novelbuychapterrecord.FieldCoupon:
		m.ResetCoupon()
		return nil
	case novelbuychapterrecord.FieldDiscount:
		m.ResetDiscount()
		return nil
	case novelbuychapterrecord.FieldRemark:
		m.ResetRemark()
		return nil
	case novelbuychapterrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelbuychapterrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelbuychapterrecord.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelbuychapterrecord.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelbuychapterrecord.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyChapterRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, novelbuychapterrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelBuyChapterRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelbuychapterrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelBuyChapterRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelBuyChapterRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, novelbuychapterrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelBuyChapterRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case novelbuychapterrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelBuyChapterRecordMutation) ClearEdge(name string) error {
	switch name {
	case novelbuychapterrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyChapterRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelBuyChapterRecordMutation) ResetEdge(name string) error {
	switch name {
	case novelbuychapterrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyChapterRecord edge %s", name)
}

// NovelBuyRecordMutation represents an operation that mutates the NovelBuyRecord nodes in the graph.
type NovelBuyRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	userName      *string
	novelId       *int64
	addnovelId    *int64
	novelName     *string
	packageId     *int64
	addpackageId  *int64
	cover         *string
	coin          *int64
	addcoin       *int64
	coupon        *int64
	addcoupon     *int64
	remark        *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*NovelBuyRecord, error)
	predicates    []predicate.NovelBuyRecord
}

var _ ent.Mutation = (*NovelBuyRecordMutation)(nil)

// novelbuyrecordOption allows management of the mutation configuration using functional options.
type novelbuyrecordOption func(*NovelBuyRecordMutation)

// newNovelBuyRecordMutation creates new mutation for the NovelBuyRecord entity.
func newNovelBuyRecordMutation(c config, op Op, opts ...novelbuyrecordOption) *NovelBuyRecordMutation {
	m := &NovelBuyRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelBuyRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelBuyRecordID sets the ID field of the mutation.
func withNovelBuyRecordID(id int64) novelbuyrecordOption {
	return func(m *NovelBuyRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelBuyRecord
		)
		m.oldValue = func(ctx context.Context) (*NovelBuyRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelBuyRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelBuyRecord sets the old NovelBuyRecord of the mutation.
func withNovelBuyRecord(node *NovelBuyRecord) novelbuyrecordOption {
	return func(m *NovelBuyRecordMutation) {
		m.oldValue = func(context.Context) (*NovelBuyRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelBuyRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelBuyRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelBuyRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelBuyRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelBuyRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *NovelBuyRecordMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *NovelBuyRecordMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *NovelBuyRecordMutation) ResetUserId() {
	m.user = nil
}

// SetUserName sets the "userName" field.
func (m *NovelBuyRecordMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *NovelBuyRecordMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *NovelBuyRecordMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[novelbuyrecord.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *NovelBuyRecordMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, novelbuyrecord.FieldUserName)
}

// SetNovelId sets the "novelId" field.
func (m *NovelBuyRecordMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelBuyRecordMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *NovelBuyRecordMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *NovelBuyRecordMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *NovelBuyRecordMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[novelbuyrecord.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelBuyRecordMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, novelbuyrecord.FieldNovelId)
}

// SetNovelName sets the "novelName" field.
func (m *NovelBuyRecordMutation) SetNovelName(s string) {
	m.novelName = &s
}

// NovelName returns the value of the "novelName" field in the mutation.
func (m *NovelBuyRecordMutation) NovelName() (r string, exists bool) {
	v := m.novelName
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelName returns the old "novelName" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldNovelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelName: %w", err)
	}
	return oldValue.NovelName, nil
}

// ClearNovelName clears the value of the "novelName" field.
func (m *NovelBuyRecordMutation) ClearNovelName() {
	m.novelName = nil
	m.clearedFields[novelbuyrecord.FieldNovelName] = struct{}{}
}

// NovelNameCleared returns if the "novelName" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) NovelNameCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldNovelName]
	return ok
}

// ResetNovelName resets all changes to the "novelName" field.
func (m *NovelBuyRecordMutation) ResetNovelName() {
	m.novelName = nil
	delete(m.clearedFields, novelbuyrecord.FieldNovelName)
}

// SetPackageId sets the "packageId" field.
func (m *NovelBuyRecordMutation) SetPackageId(i int64) {
	m.packageId = &i
	m.addpackageId = nil
}

// PackageId returns the value of the "packageId" field in the mutation.
func (m *NovelBuyRecordMutation) PackageId() (r int64, exists bool) {
	v := m.packageId
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageId returns the old "packageId" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldPackageId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageId: %w", err)
	}
	return oldValue.PackageId, nil
}

// AddPackageId adds i to the "packageId" field.
func (m *NovelBuyRecordMutation) AddPackageId(i int64) {
	if m.addpackageId != nil {
		*m.addpackageId += i
	} else {
		m.addpackageId = &i
	}
}

// AddedPackageId returns the value that was added to the "packageId" field in this mutation.
func (m *NovelBuyRecordMutation) AddedPackageId() (r int64, exists bool) {
	v := m.addpackageId
	if v == nil {
		return
	}
	return *v, true
}

// ClearPackageId clears the value of the "packageId" field.
func (m *NovelBuyRecordMutation) ClearPackageId() {
	m.packageId = nil
	m.addpackageId = nil
	m.clearedFields[novelbuyrecord.FieldPackageId] = struct{}{}
}

// PackageIdCleared returns if the "packageId" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) PackageIdCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldPackageId]
	return ok
}

// ResetPackageId resets all changes to the "packageId" field.
func (m *NovelBuyRecordMutation) ResetPackageId() {
	m.packageId = nil
	m.addpackageId = nil
	delete(m.clearedFields, novelbuyrecord.FieldPackageId)
}

// SetCover sets the "cover" field.
func (m *NovelBuyRecordMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *NovelBuyRecordMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ClearCover clears the value of the "cover" field.
func (m *NovelBuyRecordMutation) ClearCover() {
	m.cover = nil
	m.clearedFields[novelbuyrecord.FieldCover] = struct{}{}
}

// CoverCleared returns if the "cover" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) CoverCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldCover]
	return ok
}

// ResetCover resets all changes to the "cover" field.
func (m *NovelBuyRecordMutation) ResetCover() {
	m.cover = nil
	delete(m.clearedFields, novelbuyrecord.FieldCover)
}

// SetCoin sets the "coin" field.
func (m *NovelBuyRecordMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *NovelBuyRecordMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *NovelBuyRecordMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *NovelBuyRecordMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoin clears the value of the "coin" field.
func (m *NovelBuyRecordMutation) ClearCoin() {
	m.coin = nil
	m.addcoin = nil
	m.clearedFields[novelbuyrecord.FieldCoin] = struct{}{}
}

// CoinCleared returns if the "coin" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) CoinCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldCoin]
	return ok
}

// ResetCoin resets all changes to the "coin" field.
func (m *NovelBuyRecordMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
	delete(m.clearedFields, novelbuyrecord.FieldCoin)
}

// SetCoupon sets the "coupon" field.
func (m *NovelBuyRecordMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *NovelBuyRecordMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *NovelBuyRecordMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *NovelBuyRecordMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoupon clears the value of the "coupon" field.
func (m *NovelBuyRecordMutation) ClearCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	m.clearedFields[novelbuyrecord.FieldCoupon] = struct{}{}
}

// CouponCleared returns if the "coupon" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) CouponCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldCoupon]
	return ok
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *NovelBuyRecordMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	delete(m.clearedFields, novelbuyrecord.FieldCoupon)
}

// SetRemark sets the "remark" field.
func (m *NovelBuyRecordMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelBuyRecordMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelBuyRecordMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelbuyrecord.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelBuyRecordMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelbuyrecord.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelBuyRecordMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelbuyrecord.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelBuyRecordMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelBuyRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelBuyRecordMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelBuyRecordMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelBuyRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelBuyRecordMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelBuyRecordMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelBuyRecordMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelBuyRecordMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelBuyRecordMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelBuyRecordMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelBuyRecordMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelBuyRecordMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelBuyRecordMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelBuyRecordMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelBuyRecordMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelBuyRecordMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelBuyRecordMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelBuyRecord entity.
// If the NovelBuyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelBuyRecordMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelBuyRecordMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelBuyRecordMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelBuyRecordMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *NovelBuyRecordMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *NovelBuyRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *NovelBuyRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NovelBuyRecordMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NovelBuyRecordMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NovelBuyRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NovelBuyRecordMutation builder.
func (m *NovelBuyRecordMutation) Where(ps ...predicate.NovelBuyRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelBuyRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelBuyRecord).
func (m *NovelBuyRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelBuyRecordMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.user != nil {
		fields = append(fields, novelbuyrecord.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, novelbuyrecord.FieldUserName)
	}
	if m.novelId != nil {
		fields = append(fields, novelbuyrecord.FieldNovelId)
	}
	if m.novelName != nil {
		fields = append(fields, novelbuyrecord.FieldNovelName)
	}
	if m.packageId != nil {
		fields = append(fields, novelbuyrecord.FieldPackageId)
	}
	if m.cover != nil {
		fields = append(fields, novelbuyrecord.FieldCover)
	}
	if m.coin != nil {
		fields = append(fields, novelbuyrecord.FieldCoin)
	}
	if m.coupon != nil {
		fields = append(fields, novelbuyrecord.FieldCoupon)
	}
	if m.remark != nil {
		fields = append(fields, novelbuyrecord.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, novelbuyrecord.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelbuyrecord.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelbuyrecord.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelbuyrecord.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelbuyrecord.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelBuyRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelbuyrecord.FieldUserId:
		return m.UserId()
	case novelbuyrecord.FieldUserName:
		return m.UserName()
	case novelbuyrecord.FieldNovelId:
		return m.NovelId()
	case novelbuyrecord.FieldNovelName:
		return m.NovelName()
	case novelbuyrecord.FieldPackageId:
		return m.PackageId()
	case novelbuyrecord.FieldCover:
		return m.Cover()
	case novelbuyrecord.FieldCoin:
		return m.Coin()
	case novelbuyrecord.FieldCoupon:
		return m.Coupon()
	case novelbuyrecord.FieldRemark:
		return m.Remark()
	case novelbuyrecord.FieldCreatedAt:
		return m.CreatedAt()
	case novelbuyrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelbuyrecord.FieldCreateBy:
		return m.CreateBy()
	case novelbuyrecord.FieldUpdateBy:
		return m.UpdateBy()
	case novelbuyrecord.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelBuyRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelbuyrecord.FieldUserId:
		return m.OldUserId(ctx)
	case novelbuyrecord.FieldUserName:
		return m.OldUserName(ctx)
	case novelbuyrecord.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelbuyrecord.FieldNovelName:
		return m.OldNovelName(ctx)
	case novelbuyrecord.FieldPackageId:
		return m.OldPackageId(ctx)
	case novelbuyrecord.FieldCover:
		return m.OldCover(ctx)
	case novelbuyrecord.FieldCoin:
		return m.OldCoin(ctx)
	case novelbuyrecord.FieldCoupon:
		return m.OldCoupon(ctx)
	case novelbuyrecord.FieldRemark:
		return m.OldRemark(ctx)
	case novelbuyrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelbuyrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelbuyrecord.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelbuyrecord.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelbuyrecord.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelBuyRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelBuyRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelbuyrecord.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case novelbuyrecord.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case novelbuyrecord.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelbuyrecord.FieldNovelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelName(v)
		return nil
	case novelbuyrecord.FieldPackageId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageId(v)
		return nil
	case novelbuyrecord.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case novelbuyrecord.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case novelbuyrecord.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case novelbuyrecord.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelbuyrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelbuyrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelbuyrecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelbuyrecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelbuyrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelBuyRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelBuyRecordMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, novelbuyrecord.FieldNovelId)
	}
	if m.addpackageId != nil {
		fields = append(fields, novelbuyrecord.FieldPackageId)
	}
	if m.addcoin != nil {
		fields = append(fields, novelbuyrecord.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, novelbuyrecord.FieldCoupon)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelbuyrecord.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelbuyrecord.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelbuyrecord.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelBuyRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelbuyrecord.FieldNovelId:
		return m.AddedNovelId()
	case novelbuyrecord.FieldPackageId:
		return m.AddedPackageId()
	case novelbuyrecord.FieldCoin:
		return m.AddedCoin()
	case novelbuyrecord.FieldCoupon:
		return m.AddedCoupon()
	case novelbuyrecord.FieldCreateBy:
		return m.AddedCreateBy()
	case novelbuyrecord.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelbuyrecord.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelBuyRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelbuyrecord.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case novelbuyrecord.FieldPackageId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPackageId(v)
		return nil
	case novelbuyrecord.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case novelbuyrecord.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case novelbuyrecord.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelbuyrecord.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelbuyrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelBuyRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelBuyRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelbuyrecord.FieldUserName) {
		fields = append(fields, novelbuyrecord.FieldUserName)
	}
	if m.FieldCleared(novelbuyrecord.FieldNovelId) {
		fields = append(fields, novelbuyrecord.FieldNovelId)
	}
	if m.FieldCleared(novelbuyrecord.FieldNovelName) {
		fields = append(fields, novelbuyrecord.FieldNovelName)
	}
	if m.FieldCleared(novelbuyrecord.FieldPackageId) {
		fields = append(fields, novelbuyrecord.FieldPackageId)
	}
	if m.FieldCleared(novelbuyrecord.FieldCover) {
		fields = append(fields, novelbuyrecord.FieldCover)
	}
	if m.FieldCleared(novelbuyrecord.FieldCoin) {
		fields = append(fields, novelbuyrecord.FieldCoin)
	}
	if m.FieldCleared(novelbuyrecord.FieldCoupon) {
		fields = append(fields, novelbuyrecord.FieldCoupon)
	}
	if m.FieldCleared(novelbuyrecord.FieldRemark) {
		fields = append(fields, novelbuyrecord.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelBuyRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelBuyRecordMutation) ClearField(name string) error {
	switch name {
	case novelbuyrecord.FieldUserName:
		m.ClearUserName()
		return nil
	case novelbuyrecord.FieldNovelId:
		m.ClearNovelId()
		return nil
	case novelbuyrecord.FieldNovelName:
		m.ClearNovelName()
		return nil
	case novelbuyrecord.FieldPackageId:
		m.ClearPackageId()
		return nil
	case novelbuyrecord.FieldCover:
		m.ClearCover()
		return nil
	case novelbuyrecord.FieldCoin:
		m.ClearCoin()
		return nil
	case novelbuyrecord.FieldCoupon:
		m.ClearCoupon()
		return nil
	case novelbuyrecord.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelBuyRecordMutation) ResetField(name string) error {
	switch name {
	case novelbuyrecord.FieldUserId:
		m.ResetUserId()
		return nil
	case novelbuyrecord.FieldUserName:
		m.ResetUserName()
		return nil
	case novelbuyrecord.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelbuyrecord.FieldNovelName:
		m.ResetNovelName()
		return nil
	case novelbuyrecord.FieldPackageId:
		m.ResetPackageId()
		return nil
	case novelbuyrecord.FieldCover:
		m.ResetCover()
		return nil
	case novelbuyrecord.FieldCoin:
		m.ResetCoin()
		return nil
	case novelbuyrecord.FieldCoupon:
		m.ResetCoupon()
		return nil
	case novelbuyrecord.FieldRemark:
		m.ResetRemark()
		return nil
	case novelbuyrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelbuyrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelbuyrecord.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelbuyrecord.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelbuyrecord.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelBuyRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, novelbuyrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelBuyRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelbuyrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelBuyRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelBuyRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelBuyRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, novelbuyrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelBuyRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case novelbuyrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelBuyRecordMutation) ClearEdge(name string) error {
	switch name {
	case novelbuyrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelBuyRecordMutation) ResetEdge(name string) error {
	switch name {
	case novelbuyrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NovelBuyRecord edge %s", name)
}

// NovelChapterMutation represents an operation that mutates the NovelChapter nodes in the graph.
type NovelChapterMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	orderNum      *int32
	addorderNum   *int32
	chapterName   *string
	content       *string
	mediaKey      *string
	duration      *string
	publishTime   *time.Time
	status        *int32
	addstatus     *int32
	isFree        *bool
	price         *int64
	addprice      *int64
	wordNum       *int32
	addwordNum    *int32
	remark        *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	prev          *int64
	clearedprev   bool
	next          *int64
	clearednext   bool
	novel         *int64
	clearednovel  bool
	done          bool
	oldValue      func(context.Context) (*NovelChapter, error)
	predicates    []predicate.NovelChapter
}

var _ ent.Mutation = (*NovelChapterMutation)(nil)

// novelchapterOption allows management of the mutation configuration using functional options.
type novelchapterOption func(*NovelChapterMutation)

// newNovelChapterMutation creates new mutation for the NovelChapter entity.
func newNovelChapterMutation(c config, op Op, opts ...novelchapterOption) *NovelChapterMutation {
	m := &NovelChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelChapterID sets the ID field of the mutation.
func withNovelChapterID(id int64) novelchapterOption {
	return func(m *NovelChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelChapter
		)
		m.oldValue = func(ctx context.Context) (*NovelChapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelChapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelChapter sets the old NovelChapter of the mutation.
func withNovelChapter(node *NovelChapter) novelchapterOption {
	return func(m *NovelChapterMutation) {
		m.oldValue = func(context.Context) (*NovelChapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelChapterMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelChapterMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelChapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNovelId sets the "novelId" field.
func (m *NovelChapterMutation) SetNovelId(i int64) {
	m.novel = &i
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelChapterMutation) NovelId() (r int64, exists bool) {
	v := m.novel
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelChapterMutation) ResetNovelId() {
	m.novel = nil
}

// SetOrderNum sets the "orderNum" field.
func (m *NovelChapterMutation) SetOrderNum(i int32) {
	m.orderNum = &i
	m.addorderNum = nil
}

// OrderNum returns the value of the "orderNum" field in the mutation.
func (m *NovelChapterMutation) OrderNum() (r int32, exists bool) {
	v := m.orderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNum returns the old "orderNum" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldOrderNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNum: %w", err)
	}
	return oldValue.OrderNum, nil
}

// AddOrderNum adds i to the "orderNum" field.
func (m *NovelChapterMutation) AddOrderNum(i int32) {
	if m.addorderNum != nil {
		*m.addorderNum += i
	} else {
		m.addorderNum = &i
	}
}

// AddedOrderNum returns the value that was added to the "orderNum" field in this mutation.
func (m *NovelChapterMutation) AddedOrderNum() (r int32, exists bool) {
	v := m.addorderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderNum clears the value of the "orderNum" field.
func (m *NovelChapterMutation) ClearOrderNum() {
	m.orderNum = nil
	m.addorderNum = nil
	m.clearedFields[novelchapter.FieldOrderNum] = struct{}{}
}

// OrderNumCleared returns if the "orderNum" field was cleared in this mutation.
func (m *NovelChapterMutation) OrderNumCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldOrderNum]
	return ok
}

// ResetOrderNum resets all changes to the "orderNum" field.
func (m *NovelChapterMutation) ResetOrderNum() {
	m.orderNum = nil
	m.addorderNum = nil
	delete(m.clearedFields, novelchapter.FieldOrderNum)
}

// SetChapterName sets the "chapterName" field.
func (m *NovelChapterMutation) SetChapterName(s string) {
	m.chapterName = &s
}

// ChapterName returns the value of the "chapterName" field in the mutation.
func (m *NovelChapterMutation) ChapterName() (r string, exists bool) {
	v := m.chapterName
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterName returns the old "chapterName" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldChapterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterName: %w", err)
	}
	return oldValue.ChapterName, nil
}

// ClearChapterName clears the value of the "chapterName" field.
func (m *NovelChapterMutation) ClearChapterName() {
	m.chapterName = nil
	m.clearedFields[novelchapter.FieldChapterName] = struct{}{}
}

// ChapterNameCleared returns if the "chapterName" field was cleared in this mutation.
func (m *NovelChapterMutation) ChapterNameCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldChapterName]
	return ok
}

// ResetChapterName resets all changes to the "chapterName" field.
func (m *NovelChapterMutation) ResetChapterName() {
	m.chapterName = nil
	delete(m.clearedFields, novelchapter.FieldChapterName)
}

// SetContent sets the "content" field.
func (m *NovelChapterMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NovelChapterMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *NovelChapterMutation) ClearContent() {
	m.content = nil
	m.clearedFields[novelchapter.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *NovelChapterMutation) ContentCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *NovelChapterMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, novelchapter.FieldContent)
}

// SetMediaKey sets the "mediaKey" field.
func (m *NovelChapterMutation) SetMediaKey(s string) {
	m.mediaKey = &s
}

// MediaKey returns the value of the "mediaKey" field in the mutation.
func (m *NovelChapterMutation) MediaKey() (r string, exists bool) {
	v := m.mediaKey
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaKey returns the old "mediaKey" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldMediaKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaKey: %w", err)
	}
	return oldValue.MediaKey, nil
}

// ClearMediaKey clears the value of the "mediaKey" field.
func (m *NovelChapterMutation) ClearMediaKey() {
	m.mediaKey = nil
	m.clearedFields[novelchapter.FieldMediaKey] = struct{}{}
}

// MediaKeyCleared returns if the "mediaKey" field was cleared in this mutation.
func (m *NovelChapterMutation) MediaKeyCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldMediaKey]
	return ok
}

// ResetMediaKey resets all changes to the "mediaKey" field.
func (m *NovelChapterMutation) ResetMediaKey() {
	m.mediaKey = nil
	delete(m.clearedFields, novelchapter.FieldMediaKey)
}

// SetDuration sets the "duration" field.
func (m *NovelChapterMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *NovelChapterMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *NovelChapterMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[novelchapter.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *NovelChapterMutation) DurationCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *NovelChapterMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, novelchapter.FieldDuration)
}

// SetPublishTime sets the "publishTime" field.
func (m *NovelChapterMutation) SetPublishTime(t time.Time) {
	m.publishTime = &t
}

// PublishTime returns the value of the "publishTime" field in the mutation.
func (m *NovelChapterMutation) PublishTime() (r time.Time, exists bool) {
	v := m.publishTime
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishTime returns the old "publishTime" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldPublishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishTime: %w", err)
	}
	return oldValue.PublishTime, nil
}

// ClearPublishTime clears the value of the "publishTime" field.
func (m *NovelChapterMutation) ClearPublishTime() {
	m.publishTime = nil
	m.clearedFields[novelchapter.FieldPublishTime] = struct{}{}
}

// PublishTimeCleared returns if the "publishTime" field was cleared in this mutation.
func (m *NovelChapterMutation) PublishTimeCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldPublishTime]
	return ok
}

// ResetPublishTime resets all changes to the "publishTime" field.
func (m *NovelChapterMutation) ResetPublishTime() {
	m.publishTime = nil
	delete(m.clearedFields, novelchapter.FieldPublishTime)
}

// SetStatus sets the "status" field.
func (m *NovelChapterMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *NovelChapterMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *NovelChapterMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *NovelChapterMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *NovelChapterMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[novelchapter.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *NovelChapterMutation) StatusCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *NovelChapterMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, novelchapter.FieldStatus)
}

// SetIsFree sets the "isFree" field.
func (m *NovelChapterMutation) SetIsFree(b bool) {
	m.isFree = &b
}

// IsFree returns the value of the "isFree" field in the mutation.
func (m *NovelChapterMutation) IsFree() (r bool, exists bool) {
	v := m.isFree
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "isFree" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldIsFree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// ClearIsFree clears the value of the "isFree" field.
func (m *NovelChapterMutation) ClearIsFree() {
	m.isFree = nil
	m.clearedFields[novelchapter.FieldIsFree] = struct{}{}
}

// IsFreeCleared returns if the "isFree" field was cleared in this mutation.
func (m *NovelChapterMutation) IsFreeCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldIsFree]
	return ok
}

// ResetIsFree resets all changes to the "isFree" field.
func (m *NovelChapterMutation) ResetIsFree() {
	m.isFree = nil
	delete(m.clearedFields, novelchapter.FieldIsFree)
}

// SetPrice sets the "price" field.
func (m *NovelChapterMutation) SetPrice(i int64) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *NovelChapterMutation) Price() (r int64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *NovelChapterMutation) AddPrice(i int64) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *NovelChapterMutation) AddedPrice() (r int64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *NovelChapterMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[novelchapter.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *NovelChapterMutation) PriceCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *NovelChapterMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, novelchapter.FieldPrice)
}

// SetWordNum sets the "wordNum" field.
func (m *NovelChapterMutation) SetWordNum(i int32) {
	m.wordNum = &i
	m.addwordNum = nil
}

// WordNum returns the value of the "wordNum" field in the mutation.
func (m *NovelChapterMutation) WordNum() (r int32, exists bool) {
	v := m.wordNum
	if v == nil {
		return
	}
	return *v, true
}

// OldWordNum returns the old "wordNum" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldWordNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordNum: %w", err)
	}
	return oldValue.WordNum, nil
}

// AddWordNum adds i to the "wordNum" field.
func (m *NovelChapterMutation) AddWordNum(i int32) {
	if m.addwordNum != nil {
		*m.addwordNum += i
	} else {
		m.addwordNum = &i
	}
}

// AddedWordNum returns the value that was added to the "wordNum" field in this mutation.
func (m *NovelChapterMutation) AddedWordNum() (r int32, exists bool) {
	v := m.addwordNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearWordNum clears the value of the "wordNum" field.
func (m *NovelChapterMutation) ClearWordNum() {
	m.wordNum = nil
	m.addwordNum = nil
	m.clearedFields[novelchapter.FieldWordNum] = struct{}{}
}

// WordNumCleared returns if the "wordNum" field was cleared in this mutation.
func (m *NovelChapterMutation) WordNumCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldWordNum]
	return ok
}

// ResetWordNum resets all changes to the "wordNum" field.
func (m *NovelChapterMutation) ResetWordNum() {
	m.wordNum = nil
	m.addwordNum = nil
	delete(m.clearedFields, novelchapter.FieldWordNum)
}

// SetRemark sets the "remark" field.
func (m *NovelChapterMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelChapterMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelChapterMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelchapter.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelChapterMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelchapter.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelChapterMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelchapter.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelChapterMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelChapterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelChapterMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelChapterMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelChapterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelChapterMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelChapterMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelChapterMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelChapterMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelChapterMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelChapterMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelChapterMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelChapterMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelChapterMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelChapterMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelChapterMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelChapterMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelChapterMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelChapter entity.
// If the NovelChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelChapterMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelChapterMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelChapterMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelChapterMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetPrevID sets the "prev" edge to the NovelChapter entity by id.
func (m *NovelChapterMutation) SetPrevID(id int64) {
	m.prev = &id
}

// ClearPrev clears the "prev" edge to the NovelChapter entity.
func (m *NovelChapterMutation) ClearPrev() {
	m.clearedprev = true
}

// PrevCleared reports if the "prev" edge to the NovelChapter entity was cleared.
func (m *NovelChapterMutation) PrevCleared() bool {
	return m.clearedprev
}

// PrevID returns the "prev" edge ID in the mutation.
func (m *NovelChapterMutation) PrevID() (id int64, exists bool) {
	if m.prev != nil {
		return *m.prev, true
	}
	return
}

// PrevIDs returns the "prev" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrevID instead. It exists only for internal usage by the builders.
func (m *NovelChapterMutation) PrevIDs() (ids []int64) {
	if id := m.prev; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrev resets all changes to the "prev" edge.
func (m *NovelChapterMutation) ResetPrev() {
	m.prev = nil
	m.clearedprev = false
}

// SetNextID sets the "next" edge to the NovelChapter entity by id.
func (m *NovelChapterMutation) SetNextID(id int64) {
	m.next = &id
}

// ClearNext clears the "next" edge to the NovelChapter entity.
func (m *NovelChapterMutation) ClearNext() {
	m.clearednext = true
}

// NextCleared reports if the "next" edge to the NovelChapter entity was cleared.
func (m *NovelChapterMutation) NextCleared() bool {
	return m.clearednext
}

// NextID returns the "next" edge ID in the mutation.
func (m *NovelChapterMutation) NextID() (id int64, exists bool) {
	if m.next != nil {
		return *m.next, true
	}
	return
}

// NextIDs returns the "next" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NextID instead. It exists only for internal usage by the builders.
func (m *NovelChapterMutation) NextIDs() (ids []int64) {
	if id := m.next; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNext resets all changes to the "next" edge.
func (m *NovelChapterMutation) ResetNext() {
	m.next = nil
	m.clearednext = false
}

// SetNovelID sets the "novel" edge to the Novel entity by id.
func (m *NovelChapterMutation) SetNovelID(id int64) {
	m.novel = &id
}

// ClearNovel clears the "novel" edge to the Novel entity.
func (m *NovelChapterMutation) ClearNovel() {
	m.clearednovel = true
}

// NovelCleared reports if the "novel" edge to the Novel entity was cleared.
func (m *NovelChapterMutation) NovelCleared() bool {
	return m.clearednovel
}

// NovelID returns the "novel" edge ID in the mutation.
func (m *NovelChapterMutation) NovelID() (id int64, exists bool) {
	if m.novel != nil {
		return *m.novel, true
	}
	return
}

// NovelIDs returns the "novel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NovelID instead. It exists only for internal usage by the builders.
func (m *NovelChapterMutation) NovelIDs() (ids []int64) {
	if id := m.novel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNovel resets all changes to the "novel" edge.
func (m *NovelChapterMutation) ResetNovel() {
	m.novel = nil
	m.clearednovel = false
}

// Where appends a list predicates to the NovelChapterMutation builder.
func (m *NovelChapterMutation) Where(ps ...predicate.NovelChapter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelChapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelChapter).
func (m *NovelChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelChapterMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.novel != nil {
		fields = append(fields, novelchapter.FieldNovelId)
	}
	if m.orderNum != nil {
		fields = append(fields, novelchapter.FieldOrderNum)
	}
	if m.chapterName != nil {
		fields = append(fields, novelchapter.FieldChapterName)
	}
	if m.content != nil {
		fields = append(fields, novelchapter.FieldContent)
	}
	if m.mediaKey != nil {
		fields = append(fields, novelchapter.FieldMediaKey)
	}
	if m.duration != nil {
		fields = append(fields, novelchapter.FieldDuration)
	}
	if m.publishTime != nil {
		fields = append(fields, novelchapter.FieldPublishTime)
	}
	if m.status != nil {
		fields = append(fields, novelchapter.FieldStatus)
	}
	if m.isFree != nil {
		fields = append(fields, novelchapter.FieldIsFree)
	}
	if m.price != nil {
		fields = append(fields, novelchapter.FieldPrice)
	}
	if m.wordNum != nil {
		fields = append(fields, novelchapter.FieldWordNum)
	}
	if m.remark != nil {
		fields = append(fields, novelchapter.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, novelchapter.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelchapter.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelchapter.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelchapter.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelchapter.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelchapter.FieldNovelId:
		return m.NovelId()
	case novelchapter.FieldOrderNum:
		return m.OrderNum()
	case novelchapter.FieldChapterName:
		return m.ChapterName()
	case novelchapter.FieldContent:
		return m.Content()
	case novelchapter.FieldMediaKey:
		return m.MediaKey()
	case novelchapter.FieldDuration:
		return m.Duration()
	case novelchapter.FieldPublishTime:
		return m.PublishTime()
	case novelchapter.FieldStatus:
		return m.Status()
	case novelchapter.FieldIsFree:
		return m.IsFree()
	case novelchapter.FieldPrice:
		return m.Price()
	case novelchapter.FieldWordNum:
		return m.WordNum()
	case novelchapter.FieldRemark:
		return m.Remark()
	case novelchapter.FieldCreatedAt:
		return m.CreatedAt()
	case novelchapter.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelchapter.FieldCreateBy:
		return m.CreateBy()
	case novelchapter.FieldUpdateBy:
		return m.UpdateBy()
	case novelchapter.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelchapter.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelchapter.FieldOrderNum:
		return m.OldOrderNum(ctx)
	case novelchapter.FieldChapterName:
		return m.OldChapterName(ctx)
	case novelchapter.FieldContent:
		return m.OldContent(ctx)
	case novelchapter.FieldMediaKey:
		return m.OldMediaKey(ctx)
	case novelchapter.FieldDuration:
		return m.OldDuration(ctx)
	case novelchapter.FieldPublishTime:
		return m.OldPublishTime(ctx)
	case novelchapter.FieldStatus:
		return m.OldStatus(ctx)
	case novelchapter.FieldIsFree:
		return m.OldIsFree(ctx)
	case novelchapter.FieldPrice:
		return m.OldPrice(ctx)
	case novelchapter.FieldWordNum:
		return m.OldWordNum(ctx)
	case novelchapter.FieldRemark:
		return m.OldRemark(ctx)
	case novelchapter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelchapter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelchapter.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelchapter.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelchapter.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelChapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelchapter.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelchapter.FieldOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNum(v)
		return nil
	case novelchapter.FieldChapterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterName(v)
		return nil
	case novelchapter.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case novelchapter.FieldMediaKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaKey(v)
		return nil
	case novelchapter.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case novelchapter.FieldPublishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishTime(v)
		return nil
	case novelchapter.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case novelchapter.FieldIsFree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case novelchapter.FieldPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case novelchapter.FieldWordNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordNum(v)
		return nil
	case novelchapter.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelchapter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelchapter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelchapter.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelchapter.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelchapter.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelChapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelChapterMutation) AddedFields() []string {
	var fields []string
	if m.addorderNum != nil {
		fields = append(fields, novelchapter.FieldOrderNum)
	}
	if m.addstatus != nil {
		fields = append(fields, novelchapter.FieldStatus)
	}
	if m.addprice != nil {
		fields = append(fields, novelchapter.FieldPrice)
	}
	if m.addwordNum != nil {
		fields = append(fields, novelchapter.FieldWordNum)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelchapter.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelchapter.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelchapter.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelchapter.FieldOrderNum:
		return m.AddedOrderNum()
	case novelchapter.FieldStatus:
		return m.AddedStatus()
	case novelchapter.FieldPrice:
		return m.AddedPrice()
	case novelchapter.FieldWordNum:
		return m.AddedWordNum()
	case novelchapter.FieldCreateBy:
		return m.AddedCreateBy()
	case novelchapter.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelchapter.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelchapter.FieldOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNum(v)
		return nil
	case novelchapter.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case novelchapter.FieldPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case novelchapter.FieldWordNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordNum(v)
		return nil
	case novelchapter.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelchapter.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelchapter.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelChapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelChapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelchapter.FieldOrderNum) {
		fields = append(fields, novelchapter.FieldOrderNum)
	}
	if m.FieldCleared(novelchapter.FieldChapterName) {
		fields = append(fields, novelchapter.FieldChapterName)
	}
	if m.FieldCleared(novelchapter.FieldContent) {
		fields = append(fields, novelchapter.FieldContent)
	}
	if m.FieldCleared(novelchapter.FieldMediaKey) {
		fields = append(fields, novelchapter.FieldMediaKey)
	}
	if m.FieldCleared(novelchapter.FieldDuration) {
		fields = append(fields, novelchapter.FieldDuration)
	}
	if m.FieldCleared(novelchapter.FieldPublishTime) {
		fields = append(fields, novelchapter.FieldPublishTime)
	}
	if m.FieldCleared(novelchapter.FieldStatus) {
		fields = append(fields, novelchapter.FieldStatus)
	}
	if m.FieldCleared(novelchapter.FieldIsFree) {
		fields = append(fields, novelchapter.FieldIsFree)
	}
	if m.FieldCleared(novelchapter.FieldPrice) {
		fields = append(fields, novelchapter.FieldPrice)
	}
	if m.FieldCleared(novelchapter.FieldWordNum) {
		fields = append(fields, novelchapter.FieldWordNum)
	}
	if m.FieldCleared(novelchapter.FieldRemark) {
		fields = append(fields, novelchapter.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelChapterMutation) ClearField(name string) error {
	switch name {
	case novelchapter.FieldOrderNum:
		m.ClearOrderNum()
		return nil
	case novelchapter.FieldChapterName:
		m.ClearChapterName()
		return nil
	case novelchapter.FieldContent:
		m.ClearContent()
		return nil
	case novelchapter.FieldMediaKey:
		m.ClearMediaKey()
		return nil
	case novelchapter.FieldDuration:
		m.ClearDuration()
		return nil
	case novelchapter.FieldPublishTime:
		m.ClearPublishTime()
		return nil
	case novelchapter.FieldStatus:
		m.ClearStatus()
		return nil
	case novelchapter.FieldIsFree:
		m.ClearIsFree()
		return nil
	case novelchapter.FieldPrice:
		m.ClearPrice()
		return nil
	case novelchapter.FieldWordNum:
		m.ClearWordNum()
		return nil
	case novelchapter.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelChapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelChapterMutation) ResetField(name string) error {
	switch name {
	case novelchapter.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelchapter.FieldOrderNum:
		m.ResetOrderNum()
		return nil
	case novelchapter.FieldChapterName:
		m.ResetChapterName()
		return nil
	case novelchapter.FieldContent:
		m.ResetContent()
		return nil
	case novelchapter.FieldMediaKey:
		m.ResetMediaKey()
		return nil
	case novelchapter.FieldDuration:
		m.ResetDuration()
		return nil
	case novelchapter.FieldPublishTime:
		m.ResetPublishTime()
		return nil
	case novelchapter.FieldStatus:
		m.ResetStatus()
		return nil
	case novelchapter.FieldIsFree:
		m.ResetIsFree()
		return nil
	case novelchapter.FieldPrice:
		m.ResetPrice()
		return nil
	case novelchapter.FieldWordNum:
		m.ResetWordNum()
		return nil
	case novelchapter.FieldRemark:
		m.ResetRemark()
		return nil
	case novelchapter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelchapter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelchapter.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelchapter.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelchapter.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelChapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prev != nil {
		edges = append(edges, novelchapter.EdgePrev)
	}
	if m.next != nil {
		edges = append(edges, novelchapter.EdgeNext)
	}
	if m.novel != nil {
		edges = append(edges, novelchapter.EdgeNovel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelchapter.EdgePrev:
		if id := m.prev; id != nil {
			return []ent.Value{*id}
		}
	case novelchapter.EdgeNext:
		if id := m.next; id != nil {
			return []ent.Value{*id}
		}
	case novelchapter.EdgeNovel:
		if id := m.novel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprev {
		edges = append(edges, novelchapter.EdgePrev)
	}
	if m.clearednext {
		edges = append(edges, novelchapter.EdgeNext)
	}
	if m.clearednovel {
		edges = append(edges, novelchapter.EdgeNovel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case novelchapter.EdgePrev:
		return m.clearedprev
	case novelchapter.EdgeNext:
		return m.clearednext
	case novelchapter.EdgeNovel:
		return m.clearednovel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelChapterMutation) ClearEdge(name string) error {
	switch name {
	case novelchapter.EdgePrev:
		m.ClearPrev()
		return nil
	case novelchapter.EdgeNext:
		m.ClearNext()
		return nil
	case novelchapter.EdgeNovel:
		m.ClearNovel()
		return nil
	}
	return fmt.Errorf("unknown NovelChapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelChapterMutation) ResetEdge(name string) error {
	switch name {
	case novelchapter.EdgePrev:
		m.ResetPrev()
		return nil
	case novelchapter.EdgeNext:
		m.ResetNext()
		return nil
	case novelchapter.EdgeNovel:
		m.ResetNovel()
		return nil
	}
	return fmt.Errorf("unknown NovelChapter edge %s", name)
}

// NovelClassifyMutation represents an operation that mutates the NovelClassify nodes in the graph.
type NovelClassifyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	pid           *int64
	addpid        *int64
	classifyName  *string
	status        *int32
	addstatus     *int32
	orderNum      *int32
	addorderNum   *int32
	remark        *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	novels        map[int64]struct{}
	removednovels map[int64]struct{}
	clearednovels bool
	done          bool
	oldValue      func(context.Context) (*NovelClassify, error)
	predicates    []predicate.NovelClassify
}

var _ ent.Mutation = (*NovelClassifyMutation)(nil)

// novelclassifyOption allows management of the mutation configuration using functional options.
type novelclassifyOption func(*NovelClassifyMutation)

// newNovelClassifyMutation creates new mutation for the NovelClassify entity.
func newNovelClassifyMutation(c config, op Op, opts ...novelclassifyOption) *NovelClassifyMutation {
	m := &NovelClassifyMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelClassify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelClassifyID sets the ID field of the mutation.
func withNovelClassifyID(id int64) novelclassifyOption {
	return func(m *NovelClassifyMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelClassify
		)
		m.oldValue = func(ctx context.Context) (*NovelClassify, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelClassify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelClassify sets the old NovelClassify of the mutation.
func withNovelClassify(node *NovelClassify) novelclassifyOption {
	return func(m *NovelClassifyMutation) {
		m.oldValue = func(context.Context) (*NovelClassify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelClassifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelClassifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelClassifyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelClassifyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelClassify.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPid sets the "pid" field.
func (m *NovelClassifyMutation) SetPid(i int64) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *NovelClassifyMutation) Pid() (r int64, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldPid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *NovelClassifyMutation) AddPid(i int64) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *NovelClassifyMutation) AddedPid() (r int64, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ClearPid clears the value of the "pid" field.
func (m *NovelClassifyMutation) ClearPid() {
	m.pid = nil
	m.addpid = nil
	m.clearedFields[novelclassify.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *NovelClassifyMutation) PidCleared() bool {
	_, ok := m.clearedFields[novelclassify.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *NovelClassifyMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
	delete(m.clearedFields, novelclassify.FieldPid)
}

// SetClassifyName sets the "classifyName" field.
func (m *NovelClassifyMutation) SetClassifyName(s string) {
	m.classifyName = &s
}

// ClassifyName returns the value of the "classifyName" field in the mutation.
func (m *NovelClassifyMutation) ClassifyName() (r string, exists bool) {
	v := m.classifyName
	if v == nil {
		return
	}
	return *v, true
}

// OldClassifyName returns the old "classifyName" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldClassifyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassifyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassifyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassifyName: %w", err)
	}
	return oldValue.ClassifyName, nil
}

// ClearClassifyName clears the value of the "classifyName" field.
func (m *NovelClassifyMutation) ClearClassifyName() {
	m.classifyName = nil
	m.clearedFields[novelclassify.FieldClassifyName] = struct{}{}
}

// ClassifyNameCleared returns if the "classifyName" field was cleared in this mutation.
func (m *NovelClassifyMutation) ClassifyNameCleared() bool {
	_, ok := m.clearedFields[novelclassify.FieldClassifyName]
	return ok
}

// ResetClassifyName resets all changes to the "classifyName" field.
func (m *NovelClassifyMutation) ResetClassifyName() {
	m.classifyName = nil
	delete(m.clearedFields, novelclassify.FieldClassifyName)
}

// SetStatus sets the "status" field.
func (m *NovelClassifyMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *NovelClassifyMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *NovelClassifyMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *NovelClassifyMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *NovelClassifyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[novelclassify.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *NovelClassifyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[novelclassify.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *NovelClassifyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, novelclassify.FieldStatus)
}

// SetOrderNum sets the "orderNum" field.
func (m *NovelClassifyMutation) SetOrderNum(i int32) {
	m.orderNum = &i
	m.addorderNum = nil
}

// OrderNum returns the value of the "orderNum" field in the mutation.
func (m *NovelClassifyMutation) OrderNum() (r int32, exists bool) {
	v := m.orderNum
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNum returns the old "orderNum" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldOrderNum(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNum: %w", err)
	}
	return oldValue.OrderNum, nil
}

// AddOrderNum adds i to the "orderNum" field.
func (m *NovelClassifyMutation) AddOrderNum(i int32) {
	if m.addorderNum != nil {
		*m.addorderNum += i
	} else {
		m.addorderNum = &i
	}
}

// AddedOrderNum returns the value that was added to the "orderNum" field in this mutation.
func (m *NovelClassifyMutation) AddedOrderNum() (r int32, exists bool) {
	v := m.addorderNum
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderNum clears the value of the "orderNum" field.
func (m *NovelClassifyMutation) ClearOrderNum() {
	m.orderNum = nil
	m.addorderNum = nil
	m.clearedFields[novelclassify.FieldOrderNum] = struct{}{}
}

// OrderNumCleared returns if the "orderNum" field was cleared in this mutation.
func (m *NovelClassifyMutation) OrderNumCleared() bool {
	_, ok := m.clearedFields[novelclassify.FieldOrderNum]
	return ok
}

// ResetOrderNum resets all changes to the "orderNum" field.
func (m *NovelClassifyMutation) ResetOrderNum() {
	m.orderNum = nil
	m.addorderNum = nil
	delete(m.clearedFields, novelclassify.FieldOrderNum)
}

// SetRemark sets the "remark" field.
func (m *NovelClassifyMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelClassifyMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelClassifyMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelclassify.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelClassifyMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelclassify.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelClassifyMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelclassify.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelClassifyMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelClassifyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelClassifyMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelClassifyMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelClassifyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelClassifyMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelClassifyMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelClassifyMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelClassifyMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelClassifyMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelClassifyMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelClassifyMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelClassifyMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelClassifyMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelClassifyMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelClassifyMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelClassifyMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelClassifyMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelClassify entity.
// If the NovelClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelClassifyMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelClassifyMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelClassifyMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelClassifyMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// AddNovelIDs adds the "novels" edge to the Novel entity by ids.
func (m *NovelClassifyMutation) AddNovelIDs(ids ...int64) {
	if m.novels == nil {
		m.novels = make(map[int64]struct{})
	}
	for i := range ids {
		m.novels[ids[i]] = struct{}{}
	}
}

// ClearNovels clears the "novels" edge to the Novel entity.
func (m *NovelClassifyMutation) ClearNovels() {
	m.clearednovels = true
}

// NovelsCleared reports if the "novels" edge to the Novel entity was cleared.
func (m *NovelClassifyMutation) NovelsCleared() bool {
	return m.clearednovels
}

// RemoveNovelIDs removes the "novels" edge to the Novel entity by IDs.
func (m *NovelClassifyMutation) RemoveNovelIDs(ids ...int64) {
	if m.removednovels == nil {
		m.removednovels = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.novels, ids[i])
		m.removednovels[ids[i]] = struct{}{}
	}
}

// RemovedNovels returns the removed IDs of the "novels" edge to the Novel entity.
func (m *NovelClassifyMutation) RemovedNovelsIDs() (ids []int64) {
	for id := range m.removednovels {
		ids = append(ids, id)
	}
	return
}

// NovelsIDs returns the "novels" edge IDs in the mutation.
func (m *NovelClassifyMutation) NovelsIDs() (ids []int64) {
	for id := range m.novels {
		ids = append(ids, id)
	}
	return
}

// ResetNovels resets all changes to the "novels" edge.
func (m *NovelClassifyMutation) ResetNovels() {
	m.novels = nil
	m.clearednovels = false
	m.removednovels = nil
}

// Where appends a list predicates to the NovelClassifyMutation builder.
func (m *NovelClassifyMutation) Where(ps ...predicate.NovelClassify) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelClassifyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelClassify).
func (m *NovelClassifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelClassifyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.pid != nil {
		fields = append(fields, novelclassify.FieldPid)
	}
	if m.classifyName != nil {
		fields = append(fields, novelclassify.FieldClassifyName)
	}
	if m.status != nil {
		fields = append(fields, novelclassify.FieldStatus)
	}
	if m.orderNum != nil {
		fields = append(fields, novelclassify.FieldOrderNum)
	}
	if m.remark != nil {
		fields = append(fields, novelclassify.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, novelclassify.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelclassify.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelclassify.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelclassify.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelclassify.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelClassifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelclassify.FieldPid:
		return m.Pid()
	case novelclassify.FieldClassifyName:
		return m.ClassifyName()
	case novelclassify.FieldStatus:
		return m.Status()
	case novelclassify.FieldOrderNum:
		return m.OrderNum()
	case novelclassify.FieldRemark:
		return m.Remark()
	case novelclassify.FieldCreatedAt:
		return m.CreatedAt()
	case novelclassify.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelclassify.FieldCreateBy:
		return m.CreateBy()
	case novelclassify.FieldUpdateBy:
		return m.UpdateBy()
	case novelclassify.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelClassifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelclassify.FieldPid:
		return m.OldPid(ctx)
	case novelclassify.FieldClassifyName:
		return m.OldClassifyName(ctx)
	case novelclassify.FieldStatus:
		return m.OldStatus(ctx)
	case novelclassify.FieldOrderNum:
		return m.OldOrderNum(ctx)
	case novelclassify.FieldRemark:
		return m.OldRemark(ctx)
	case novelclassify.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelclassify.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelclassify.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelclassify.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelclassify.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelClassify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelClassifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelclassify.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case novelclassify.FieldClassifyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassifyName(v)
		return nil
	case novelclassify.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case novelclassify.FieldOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNum(v)
		return nil
	case novelclassify.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelclassify.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelclassify.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelclassify.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelclassify.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelclassify.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelClassify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelClassifyMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, novelclassify.FieldPid)
	}
	if m.addstatus != nil {
		fields = append(fields, novelclassify.FieldStatus)
	}
	if m.addorderNum != nil {
		fields = append(fields, novelclassify.FieldOrderNum)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelclassify.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelclassify.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelclassify.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelClassifyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelclassify.FieldPid:
		return m.AddedPid()
	case novelclassify.FieldStatus:
		return m.AddedStatus()
	case novelclassify.FieldOrderNum:
		return m.AddedOrderNum()
	case novelclassify.FieldCreateBy:
		return m.AddedCreateBy()
	case novelclassify.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelclassify.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelClassifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelclassify.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case novelclassify.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case novelclassify.FieldOrderNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNum(v)
		return nil
	case novelclassify.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelclassify.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelclassify.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelClassify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelClassifyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelclassify.FieldPid) {
		fields = append(fields, novelclassify.FieldPid)
	}
	if m.FieldCleared(novelclassify.FieldClassifyName) {
		fields = append(fields, novelclassify.FieldClassifyName)
	}
	if m.FieldCleared(novelclassify.FieldStatus) {
		fields = append(fields, novelclassify.FieldStatus)
	}
	if m.FieldCleared(novelclassify.FieldOrderNum) {
		fields = append(fields, novelclassify.FieldOrderNum)
	}
	if m.FieldCleared(novelclassify.FieldRemark) {
		fields = append(fields, novelclassify.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelClassifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelClassifyMutation) ClearField(name string) error {
	switch name {
	case novelclassify.FieldPid:
		m.ClearPid()
		return nil
	case novelclassify.FieldClassifyName:
		m.ClearClassifyName()
		return nil
	case novelclassify.FieldStatus:
		m.ClearStatus()
		return nil
	case novelclassify.FieldOrderNum:
		m.ClearOrderNum()
		return nil
	case novelclassify.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelClassify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelClassifyMutation) ResetField(name string) error {
	switch name {
	case novelclassify.FieldPid:
		m.ResetPid()
		return nil
	case novelclassify.FieldClassifyName:
		m.ResetClassifyName()
		return nil
	case novelclassify.FieldStatus:
		m.ResetStatus()
		return nil
	case novelclassify.FieldOrderNum:
		m.ResetOrderNum()
		return nil
	case novelclassify.FieldRemark:
		m.ResetRemark()
		return nil
	case novelclassify.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelclassify.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelclassify.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelclassify.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelclassify.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelClassify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelClassifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.novels != nil {
		edges = append(edges, novelclassify.EdgeNovels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelClassifyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelclassify.EdgeNovels:
		ids := make([]ent.Value, 0, len(m.novels))
		for id := range m.novels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelClassifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednovels != nil {
		edges = append(edges, novelclassify.EdgeNovels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelClassifyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case novelclassify.EdgeNovels:
		ids := make([]ent.Value, 0, len(m.removednovels))
		for id := range m.removednovels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelClassifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednovels {
		edges = append(edges, novelclassify.EdgeNovels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelClassifyMutation) EdgeCleared(name string) bool {
	switch name {
	case novelclassify.EdgeNovels:
		return m.clearednovels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelClassifyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NovelClassify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelClassifyMutation) ResetEdge(name string) error {
	switch name {
	case novelclassify.EdgeNovels:
		m.ResetNovels()
		return nil
	}
	return fmt.Errorf("unknown NovelClassify edge %s", name)
}

// NovelCommentMutation represents an operation that mutates the NovelComment nodes in the graph.
type NovelCommentMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	novelId        *int64
	addnovelId     *int64
	avatar         *string
	userName       *string
	repUserId      *int64
	addrepUserId   *int64
	repUserName    *string
	content        *string
	score          *int32
	addscore       *int32
	pId            *int64
	addpId         *int64
	isTop          *bool
	state          *novelcomment.State
	isHighlight    *bool
	isHot          *bool
	remark         *string
	createdAt      *time.Time
	updatedAt      *time.Time
	createBy       *int64
	addcreateBy    *int64
	updateBy       *int64
	addupdateBy    *int64
	tenantId       *int64
	addtenantId    *int64
	clearedFields  map[string]struct{}
	parent         *int64
	clearedparent  bool
	childes        map[int64]struct{}
	removedchildes map[int64]struct{}
	clearedchildes bool
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*NovelComment, error)
	predicates     []predicate.NovelComment
}

var _ ent.Mutation = (*NovelCommentMutation)(nil)

// novelcommentOption allows management of the mutation configuration using functional options.
type novelcommentOption func(*NovelCommentMutation)

// newNovelCommentMutation creates new mutation for the NovelComment entity.
func newNovelCommentMutation(c config, op Op, opts ...novelcommentOption) *NovelCommentMutation {
	m := &NovelCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelCommentID sets the ID field of the mutation.
func withNovelCommentID(id int64) novelcommentOption {
	return func(m *NovelCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelComment
		)
		m.oldValue = func(ctx context.Context) (*NovelComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelComment sets the old NovelComment of the mutation.
func withNovelComment(node *NovelComment) novelcommentOption {
	return func(m *NovelCommentMutation) {
		m.oldValue = func(context.Context) (*NovelComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelCommentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelCommentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNovelId sets the "novelId" field.
func (m *NovelCommentMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelCommentMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *NovelCommentMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *NovelCommentMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *NovelCommentMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[novelcomment.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *NovelCommentMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelCommentMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, novelcomment.FieldNovelId)
}

// SetUserId sets the "userId" field.
func (m *NovelCommentMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *NovelCommentMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *NovelCommentMutation) ResetUserId() {
	m.user = nil
}

// SetAvatar sets the "avatar" field.
func (m *NovelCommentMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *NovelCommentMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *NovelCommentMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[novelcomment.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *NovelCommentMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *NovelCommentMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, novelcomment.FieldAvatar)
}

// SetUserName sets the "userName" field.
func (m *NovelCommentMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *NovelCommentMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *NovelCommentMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[novelcomment.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *NovelCommentMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *NovelCommentMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, novelcomment.FieldUserName)
}

// SetRepUserId sets the "repUserId" field.
func (m *NovelCommentMutation) SetRepUserId(i int64) {
	m.repUserId = &i
	m.addrepUserId = nil
}

// RepUserId returns the value of the "repUserId" field in the mutation.
func (m *NovelCommentMutation) RepUserId() (r int64, exists bool) {
	v := m.repUserId
	if v == nil {
		return
	}
	return *v, true
}

// OldRepUserId returns the old "repUserId" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldRepUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepUserId: %w", err)
	}
	return oldValue.RepUserId, nil
}

// AddRepUserId adds i to the "repUserId" field.
func (m *NovelCommentMutation) AddRepUserId(i int64) {
	if m.addrepUserId != nil {
		*m.addrepUserId += i
	} else {
		m.addrepUserId = &i
	}
}

// AddedRepUserId returns the value that was added to the "repUserId" field in this mutation.
func (m *NovelCommentMutation) AddedRepUserId() (r int64, exists bool) {
	v := m.addrepUserId
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepUserId clears the value of the "repUserId" field.
func (m *NovelCommentMutation) ClearRepUserId() {
	m.repUserId = nil
	m.addrepUserId = nil
	m.clearedFields[novelcomment.FieldRepUserId] = struct{}{}
}

// RepUserIdCleared returns if the "repUserId" field was cleared in this mutation.
func (m *NovelCommentMutation) RepUserIdCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldRepUserId]
	return ok
}

// ResetRepUserId resets all changes to the "repUserId" field.
func (m *NovelCommentMutation) ResetRepUserId() {
	m.repUserId = nil
	m.addrepUserId = nil
	delete(m.clearedFields, novelcomment.FieldRepUserId)
}

// SetRepUserName sets the "repUserName" field.
func (m *NovelCommentMutation) SetRepUserName(s string) {
	m.repUserName = &s
}

// RepUserName returns the value of the "repUserName" field in the mutation.
func (m *NovelCommentMutation) RepUserName() (r string, exists bool) {
	v := m.repUserName
	if v == nil {
		return
	}
	return *v, true
}

// OldRepUserName returns the old "repUserName" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldRepUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepUserName: %w", err)
	}
	return oldValue.RepUserName, nil
}

// ClearRepUserName clears the value of the "repUserName" field.
func (m *NovelCommentMutation) ClearRepUserName() {
	m.repUserName = nil
	m.clearedFields[novelcomment.FieldRepUserName] = struct{}{}
}

// RepUserNameCleared returns if the "repUserName" field was cleared in this mutation.
func (m *NovelCommentMutation) RepUserNameCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldRepUserName]
	return ok
}

// ResetRepUserName resets all changes to the "repUserName" field.
func (m *NovelCommentMutation) ResetRepUserName() {
	m.repUserName = nil
	delete(m.clearedFields, novelcomment.FieldRepUserName)
}

// SetContent sets the "content" field.
func (m *NovelCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NovelCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *NovelCommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[novelcomment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *NovelCommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *NovelCommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, novelcomment.FieldContent)
}

// SetScore sets the "score" field.
func (m *NovelCommentMutation) SetScore(i int32) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *NovelCommentMutation) Score() (r int32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldScore(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *NovelCommentMutation) AddScore(i int32) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *NovelCommentMutation) AddedScore() (r int32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *NovelCommentMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[novelcomment.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *NovelCommentMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *NovelCommentMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, novelcomment.FieldScore)
}

// SetPId sets the "pId" field.
func (m *NovelCommentMutation) SetPId(i int64) {
	m.pId = &i
	m.addpId = nil
}

// PId returns the value of the "pId" field in the mutation.
func (m *NovelCommentMutation) PId() (r int64, exists bool) {
	v := m.pId
	if v == nil {
		return
	}
	return *v, true
}

// OldPId returns the old "pId" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldPId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPId: %w", err)
	}
	return oldValue.PId, nil
}

// AddPId adds i to the "pId" field.
func (m *NovelCommentMutation) AddPId(i int64) {
	if m.addpId != nil {
		*m.addpId += i
	} else {
		m.addpId = &i
	}
}

// AddedPId returns the value that was added to the "pId" field in this mutation.
func (m *NovelCommentMutation) AddedPId() (r int64, exists bool) {
	v := m.addpId
	if v == nil {
		return
	}
	return *v, true
}

// ClearPId clears the value of the "pId" field.
func (m *NovelCommentMutation) ClearPId() {
	m.pId = nil
	m.addpId = nil
	m.clearedFields[novelcomment.FieldPId] = struct{}{}
}

// PIdCleared returns if the "pId" field was cleared in this mutation.
func (m *NovelCommentMutation) PIdCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldPId]
	return ok
}

// ResetPId resets all changes to the "pId" field.
func (m *NovelCommentMutation) ResetPId() {
	m.pId = nil
	m.addpId = nil
	delete(m.clearedFields, novelcomment.FieldPId)
}

// SetIsTop sets the "isTop" field.
func (m *NovelCommentMutation) SetIsTop(b bool) {
	m.isTop = &b
}

// IsTop returns the value of the "isTop" field in the mutation.
func (m *NovelCommentMutation) IsTop() (r bool, exists bool) {
	v := m.isTop
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTop returns the old "isTop" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldIsTop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTop: %w", err)
	}
	return oldValue.IsTop, nil
}

// ClearIsTop clears the value of the "isTop" field.
func (m *NovelCommentMutation) ClearIsTop() {
	m.isTop = nil
	m.clearedFields[novelcomment.FieldIsTop] = struct{}{}
}

// IsTopCleared returns if the "isTop" field was cleared in this mutation.
func (m *NovelCommentMutation) IsTopCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldIsTop]
	return ok
}

// ResetIsTop resets all changes to the "isTop" field.
func (m *NovelCommentMutation) ResetIsTop() {
	m.isTop = nil
	delete(m.clearedFields, novelcomment.FieldIsTop)
}

// SetState sets the "state" field.
func (m *NovelCommentMutation) SetState(n novelcomment.State) {
	m.state = &n
}

// State returns the value of the "state" field in the mutation.
func (m *NovelCommentMutation) State() (r novelcomment.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldState(ctx context.Context) (v novelcomment.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *NovelCommentMutation) ClearState() {
	m.state = nil
	m.clearedFields[novelcomment.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *NovelCommentMutation) StateCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *NovelCommentMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, novelcomment.FieldState)
}

// SetIsHighlight sets the "isHighlight" field.
func (m *NovelCommentMutation) SetIsHighlight(b bool) {
	m.isHighlight = &b
}

// IsHighlight returns the value of the "isHighlight" field in the mutation.
func (m *NovelCommentMutation) IsHighlight() (r bool, exists bool) {
	v := m.isHighlight
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHighlight returns the old "isHighlight" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldIsHighlight(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHighlight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHighlight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHighlight: %w", err)
	}
	return oldValue.IsHighlight, nil
}

// ClearIsHighlight clears the value of the "isHighlight" field.
func (m *NovelCommentMutation) ClearIsHighlight() {
	m.isHighlight = nil
	m.clearedFields[novelcomment.FieldIsHighlight] = struct{}{}
}

// IsHighlightCleared returns if the "isHighlight" field was cleared in this mutation.
func (m *NovelCommentMutation) IsHighlightCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldIsHighlight]
	return ok
}

// ResetIsHighlight resets all changes to the "isHighlight" field.
func (m *NovelCommentMutation) ResetIsHighlight() {
	m.isHighlight = nil
	delete(m.clearedFields, novelcomment.FieldIsHighlight)
}

// SetIsHot sets the "isHot" field.
func (m *NovelCommentMutation) SetIsHot(b bool) {
	m.isHot = &b
}

// IsHot returns the value of the "isHot" field in the mutation.
func (m *NovelCommentMutation) IsHot() (r bool, exists bool) {
	v := m.isHot
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHot returns the old "isHot" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldIsHot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHot: %w", err)
	}
	return oldValue.IsHot, nil
}

// ClearIsHot clears the value of the "isHot" field.
func (m *NovelCommentMutation) ClearIsHot() {
	m.isHot = nil
	m.clearedFields[novelcomment.FieldIsHot] = struct{}{}
}

// IsHotCleared returns if the "isHot" field was cleared in this mutation.
func (m *NovelCommentMutation) IsHotCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldIsHot]
	return ok
}

// ResetIsHot resets all changes to the "isHot" field.
func (m *NovelCommentMutation) ResetIsHot() {
	m.isHot = nil
	delete(m.clearedFields, novelcomment.FieldIsHot)
}

// SetRemark sets the "remark" field.
func (m *NovelCommentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *NovelCommentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *NovelCommentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[novelcomment.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *NovelCommentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[novelcomment.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *NovelCommentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, novelcomment.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelCommentMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelCommentMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelCommentMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelCommentMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelCommentMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelCommentMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelCommentMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelCommentMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelCommentMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelCommentMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelCommentMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelCommentMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelCommentMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelCommentMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelCommentMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelCommentMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelComment entity.
// If the NovelComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelCommentMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelCommentMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelCommentMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelCommentMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetParentID sets the "parent" edge to the NovelComment entity by id.
func (m *NovelCommentMutation) SetParentID(id int64) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the NovelComment entity.
func (m *NovelCommentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the NovelComment entity was cleared.
func (m *NovelCommentMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *NovelCommentMutation) ParentID() (id int64, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *NovelCommentMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *NovelCommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildeIDs adds the "childes" edge to the NovelComment entity by ids.
func (m *NovelCommentMutation) AddChildeIDs(ids ...int64) {
	if m.childes == nil {
		m.childes = make(map[int64]struct{})
	}
	for i := range ids {
		m.childes[ids[i]] = struct{}{}
	}
}

// ClearChildes clears the "childes" edge to the NovelComment entity.
func (m *NovelCommentMutation) ClearChildes() {
	m.clearedchildes = true
}

// ChildesCleared reports if the "childes" edge to the NovelComment entity was cleared.
func (m *NovelCommentMutation) ChildesCleared() bool {
	return m.clearedchildes
}

// RemoveChildeIDs removes the "childes" edge to the NovelComment entity by IDs.
func (m *NovelCommentMutation) RemoveChildeIDs(ids ...int64) {
	if m.removedchildes == nil {
		m.removedchildes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childes, ids[i])
		m.removedchildes[ids[i]] = struct{}{}
	}
}

// RemovedChildes returns the removed IDs of the "childes" edge to the NovelComment entity.
func (m *NovelCommentMutation) RemovedChildesIDs() (ids []int64) {
	for id := range m.removedchildes {
		ids = append(ids, id)
	}
	return
}

// ChildesIDs returns the "childes" edge IDs in the mutation.
func (m *NovelCommentMutation) ChildesIDs() (ids []int64) {
	for id := range m.childes {
		ids = append(ids, id)
	}
	return
}

// ResetChildes resets all changes to the "childes" edge.
func (m *NovelCommentMutation) ResetChildes() {
	m.childes = nil
	m.clearedchildes = false
	m.removedchildes = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *NovelCommentMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *NovelCommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *NovelCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NovelCommentMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NovelCommentMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NovelCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NovelCommentMutation builder.
func (m *NovelCommentMutation) Where(ps ...predicate.NovelComment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelCommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelComment).
func (m *NovelCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelCommentMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.novelId != nil {
		fields = append(fields, novelcomment.FieldNovelId)
	}
	if m.user != nil {
		fields = append(fields, novelcomment.FieldUserId)
	}
	if m.avatar != nil {
		fields = append(fields, novelcomment.FieldAvatar)
	}
	if m.userName != nil {
		fields = append(fields, novelcomment.FieldUserName)
	}
	if m.repUserId != nil {
		fields = append(fields, novelcomment.FieldRepUserId)
	}
	if m.repUserName != nil {
		fields = append(fields, novelcomment.FieldRepUserName)
	}
	if m.content != nil {
		fields = append(fields, novelcomment.FieldContent)
	}
	if m.score != nil {
		fields = append(fields, novelcomment.FieldScore)
	}
	if m.pId != nil {
		fields = append(fields, novelcomment.FieldPId)
	}
	if m.isTop != nil {
		fields = append(fields, novelcomment.FieldIsTop)
	}
	if m.state != nil {
		fields = append(fields, novelcomment.FieldState)
	}
	if m.isHighlight != nil {
		fields = append(fields, novelcomment.FieldIsHighlight)
	}
	if m.isHot != nil {
		fields = append(fields, novelcomment.FieldIsHot)
	}
	if m.remark != nil {
		fields = append(fields, novelcomment.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, novelcomment.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelcomment.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelcomment.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelcomment.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelcomment.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelcomment.FieldNovelId:
		return m.NovelId()
	case novelcomment.FieldUserId:
		return m.UserId()
	case novelcomment.FieldAvatar:
		return m.Avatar()
	case novelcomment.FieldUserName:
		return m.UserName()
	case novelcomment.FieldRepUserId:
		return m.RepUserId()
	case novelcomment.FieldRepUserName:
		return m.RepUserName()
	case novelcomment.FieldContent:
		return m.Content()
	case novelcomment.FieldScore:
		return m.Score()
	case novelcomment.FieldPId:
		return m.PId()
	case novelcomment.FieldIsTop:
		return m.IsTop()
	case novelcomment.FieldState:
		return m.State()
	case novelcomment.FieldIsHighlight:
		return m.IsHighlight()
	case novelcomment.FieldIsHot:
		return m.IsHot()
	case novelcomment.FieldRemark:
		return m.Remark()
	case novelcomment.FieldCreatedAt:
		return m.CreatedAt()
	case novelcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelcomment.FieldCreateBy:
		return m.CreateBy()
	case novelcomment.FieldUpdateBy:
		return m.UpdateBy()
	case novelcomment.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelcomment.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelcomment.FieldUserId:
		return m.OldUserId(ctx)
	case novelcomment.FieldAvatar:
		return m.OldAvatar(ctx)
	case novelcomment.FieldUserName:
		return m.OldUserName(ctx)
	case novelcomment.FieldRepUserId:
		return m.OldRepUserId(ctx)
	case novelcomment.FieldRepUserName:
		return m.OldRepUserName(ctx)
	case novelcomment.FieldContent:
		return m.OldContent(ctx)
	case novelcomment.FieldScore:
		return m.OldScore(ctx)
	case novelcomment.FieldPId:
		return m.OldPId(ctx)
	case novelcomment.FieldIsTop:
		return m.OldIsTop(ctx)
	case novelcomment.FieldState:
		return m.OldState(ctx)
	case novelcomment.FieldIsHighlight:
		return m.OldIsHighlight(ctx)
	case novelcomment.FieldIsHot:
		return m.OldIsHot(ctx)
	case novelcomment.FieldRemark:
		return m.OldRemark(ctx)
	case novelcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelcomment.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelcomment.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelcomment.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelcomment.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelcomment.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case novelcomment.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case novelcomment.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case novelcomment.FieldRepUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepUserId(v)
		return nil
	case novelcomment.FieldRepUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepUserName(v)
		return nil
	case novelcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case novelcomment.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case novelcomment.FieldPId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPId(v)
		return nil
	case novelcomment.FieldIsTop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTop(v)
		return nil
	case novelcomment.FieldState:
		v, ok := value.(novelcomment.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case novelcomment.FieldIsHighlight:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHighlight(v)
		return nil
	case novelcomment.FieldIsHot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHot(v)
		return nil
	case novelcomment.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case novelcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelcomment.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelcomment.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelcomment.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelCommentMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, novelcomment.FieldNovelId)
	}
	if m.addrepUserId != nil {
		fields = append(fields, novelcomment.FieldRepUserId)
	}
	if m.addscore != nil {
		fields = append(fields, novelcomment.FieldScore)
	}
	if m.addpId != nil {
		fields = append(fields, novelcomment.FieldPId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelcomment.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelcomment.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelcomment.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelcomment.FieldNovelId:
		return m.AddedNovelId()
	case novelcomment.FieldRepUserId:
		return m.AddedRepUserId()
	case novelcomment.FieldScore:
		return m.AddedScore()
	case novelcomment.FieldPId:
		return m.AddedPId()
	case novelcomment.FieldCreateBy:
		return m.AddedCreateBy()
	case novelcomment.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelcomment.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelcomment.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case novelcomment.FieldRepUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepUserId(v)
		return nil
	case novelcomment.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case novelcomment.FieldPId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPId(v)
		return nil
	case novelcomment.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelcomment.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelcomment.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelcomment.FieldNovelId) {
		fields = append(fields, novelcomment.FieldNovelId)
	}
	if m.FieldCleared(novelcomment.FieldAvatar) {
		fields = append(fields, novelcomment.FieldAvatar)
	}
	if m.FieldCleared(novelcomment.FieldUserName) {
		fields = append(fields, novelcomment.FieldUserName)
	}
	if m.FieldCleared(novelcomment.FieldRepUserId) {
		fields = append(fields, novelcomment.FieldRepUserId)
	}
	if m.FieldCleared(novelcomment.FieldRepUserName) {
		fields = append(fields, novelcomment.FieldRepUserName)
	}
	if m.FieldCleared(novelcomment.FieldContent) {
		fields = append(fields, novelcomment.FieldContent)
	}
	if m.FieldCleared(novelcomment.FieldScore) {
		fields = append(fields, novelcomment.FieldScore)
	}
	if m.FieldCleared(novelcomment.FieldPId) {
		fields = append(fields, novelcomment.FieldPId)
	}
	if m.FieldCleared(novelcomment.FieldIsTop) {
		fields = append(fields, novelcomment.FieldIsTop)
	}
	if m.FieldCleared(novelcomment.FieldState) {
		fields = append(fields, novelcomment.FieldState)
	}
	if m.FieldCleared(novelcomment.FieldIsHighlight) {
		fields = append(fields, novelcomment.FieldIsHighlight)
	}
	if m.FieldCleared(novelcomment.FieldIsHot) {
		fields = append(fields, novelcomment.FieldIsHot)
	}
	if m.FieldCleared(novelcomment.FieldRemark) {
		fields = append(fields, novelcomment.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelCommentMutation) ClearField(name string) error {
	switch name {
	case novelcomment.FieldNovelId:
		m.ClearNovelId()
		return nil
	case novelcomment.FieldAvatar:
		m.ClearAvatar()
		return nil
	case novelcomment.FieldUserName:
		m.ClearUserName()
		return nil
	case novelcomment.FieldRepUserId:
		m.ClearRepUserId()
		return nil
	case novelcomment.FieldRepUserName:
		m.ClearRepUserName()
		return nil
	case novelcomment.FieldContent:
		m.ClearContent()
		return nil
	case novelcomment.FieldScore:
		m.ClearScore()
		return nil
	case novelcomment.FieldPId:
		m.ClearPId()
		return nil
	case novelcomment.FieldIsTop:
		m.ClearIsTop()
		return nil
	case novelcomment.FieldState:
		m.ClearState()
		return nil
	case novelcomment.FieldIsHighlight:
		m.ClearIsHighlight()
		return nil
	case novelcomment.FieldIsHot:
		m.ClearIsHot()
		return nil
	case novelcomment.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown NovelComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelCommentMutation) ResetField(name string) error {
	switch name {
	case novelcomment.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelcomment.FieldUserId:
		m.ResetUserId()
		return nil
	case novelcomment.FieldAvatar:
		m.ResetAvatar()
		return nil
	case novelcomment.FieldUserName:
		m.ResetUserName()
		return nil
	case novelcomment.FieldRepUserId:
		m.ResetRepUserId()
		return nil
	case novelcomment.FieldRepUserName:
		m.ResetRepUserName()
		return nil
	case novelcomment.FieldContent:
		m.ResetContent()
		return nil
	case novelcomment.FieldScore:
		m.ResetScore()
		return nil
	case novelcomment.FieldPId:
		m.ResetPId()
		return nil
	case novelcomment.FieldIsTop:
		m.ResetIsTop()
		return nil
	case novelcomment.FieldState:
		m.ResetState()
		return nil
	case novelcomment.FieldIsHighlight:
		m.ResetIsHighlight()
		return nil
	case novelcomment.FieldIsHot:
		m.ResetIsHot()
		return nil
	case novelcomment.FieldRemark:
		m.ResetRemark()
		return nil
	case novelcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelcomment.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelcomment.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelcomment.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, novelcomment.EdgeParent)
	}
	if m.childes != nil {
		edges = append(edges, novelcomment.EdgeChildes)
	}
	if m.user != nil {
		edges = append(edges, novelcomment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case novelcomment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case novelcomment.EdgeChildes:
		ids := make([]ent.Value, 0, len(m.childes))
		for id := range m.childes {
			ids = append(ids, id)
		}
		return ids
	case novelcomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildes != nil {
		edges = append(edges, novelcomment.EdgeChildes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelCommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case novelcomment.EdgeChildes:
		ids := make([]ent.Value, 0, len(m.removedchildes))
		for id := range m.removedchildes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, novelcomment.EdgeParent)
	}
	if m.clearedchildes {
		edges = append(edges, novelcomment.EdgeChildes)
	}
	if m.cleareduser {
		edges = append(edges, novelcomment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case novelcomment.EdgeParent:
		return m.clearedparent
	case novelcomment.EdgeChildes:
		return m.clearedchildes
	case novelcomment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelCommentMutation) ClearEdge(name string) error {
	switch name {
	case novelcomment.EdgeParent:
		m.ClearParent()
		return nil
	case novelcomment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NovelComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelCommentMutation) ResetEdge(name string) error {
	switch name {
	case novelcomment.EdgeParent:
		m.ResetParent()
		return nil
	case novelcomment.EdgeChildes:
		m.ResetChildes()
		return nil
	case novelcomment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NovelComment edge %s", name)
}

// NovelConsumeMutation represents an operation that mutates the NovelConsume nodes in the graph.
type NovelConsumeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	novelId       *int64
	addnovelId    *int64
	coin          *int64
	addcoin       *int64
	coupon        *int64
	addcoupon     *int64
	discount      *int64
	adddiscount   *int64
	reward        *int64
	addreward     *int64
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NovelConsume, error)
	predicates    []predicate.NovelConsume
}

var _ ent.Mutation = (*NovelConsumeMutation)(nil)

// novelconsumeOption allows management of the mutation configuration using functional options.
type novelconsumeOption func(*NovelConsumeMutation)

// newNovelConsumeMutation creates new mutation for the NovelConsume entity.
func newNovelConsumeMutation(c config, op Op, opts ...novelconsumeOption) *NovelConsumeMutation {
	m := &NovelConsumeMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelConsume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelConsumeID sets the ID field of the mutation.
func withNovelConsumeID(id int64) novelconsumeOption {
	return func(m *NovelConsumeMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelConsume
		)
		m.oldValue = func(ctx context.Context) (*NovelConsume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelConsume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelConsume sets the old NovelConsume of the mutation.
func withNovelConsume(node *NovelConsume) novelconsumeOption {
	return func(m *NovelConsumeMutation) {
		m.oldValue = func(context.Context) (*NovelConsume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelConsumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelConsumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelConsumeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelConsumeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelConsume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNovelId sets the "novelId" field.
func (m *NovelConsumeMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *NovelConsumeMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *NovelConsumeMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *NovelConsumeMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *NovelConsumeMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
}

// SetCoin sets the "coin" field.
func (m *NovelConsumeMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *NovelConsumeMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *NovelConsumeMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *NovelConsumeMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoin clears the value of the "coin" field.
func (m *NovelConsumeMutation) ClearCoin() {
	m.coin = nil
	m.addcoin = nil
	m.clearedFields[novelconsume.FieldCoin] = struct{}{}
}

// CoinCleared returns if the "coin" field was cleared in this mutation.
func (m *NovelConsumeMutation) CoinCleared() bool {
	_, ok := m.clearedFields[novelconsume.FieldCoin]
	return ok
}

// ResetCoin resets all changes to the "coin" field.
func (m *NovelConsumeMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
	delete(m.clearedFields, novelconsume.FieldCoin)
}

// SetCoupon sets the "coupon" field.
func (m *NovelConsumeMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *NovelConsumeMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *NovelConsumeMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *NovelConsumeMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoupon clears the value of the "coupon" field.
func (m *NovelConsumeMutation) ClearCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	m.clearedFields[novelconsume.FieldCoupon] = struct{}{}
}

// CouponCleared returns if the "coupon" field was cleared in this mutation.
func (m *NovelConsumeMutation) CouponCleared() bool {
	_, ok := m.clearedFields[novelconsume.FieldCoupon]
	return ok
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *NovelConsumeMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	delete(m.clearedFields, novelconsume.FieldCoupon)
}

// SetDiscount sets the "discount" field.
func (m *NovelConsumeMutation) SetDiscount(i int64) {
	m.discount = &i
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *NovelConsumeMutation) Discount() (r int64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldDiscount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds i to the "discount" field.
func (m *NovelConsumeMutation) AddDiscount(i int64) {
	if m.adddiscount != nil {
		*m.adddiscount += i
	} else {
		m.adddiscount = &i
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *NovelConsumeMutation) AddedDiscount() (r int64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiscount clears the value of the "discount" field.
func (m *NovelConsumeMutation) ClearDiscount() {
	m.discount = nil
	m.adddiscount = nil
	m.clearedFields[novelconsume.FieldDiscount] = struct{}{}
}

// DiscountCleared returns if the "discount" field was cleared in this mutation.
func (m *NovelConsumeMutation) DiscountCleared() bool {
	_, ok := m.clearedFields[novelconsume.FieldDiscount]
	return ok
}

// ResetDiscount resets all changes to the "discount" field.
func (m *NovelConsumeMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
	delete(m.clearedFields, novelconsume.FieldDiscount)
}

// SetReward sets the "reward" field.
func (m *NovelConsumeMutation) SetReward(i int64) {
	m.reward = &i
	m.addreward = nil
}

// Reward returns the value of the "reward" field in the mutation.
func (m *NovelConsumeMutation) Reward() (r int64, exists bool) {
	v := m.reward
	if v == nil {
		return
	}
	return *v, true
}

// OldReward returns the old "reward" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldReward(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReward: %w", err)
	}
	return oldValue.Reward, nil
}

// AddReward adds i to the "reward" field.
func (m *NovelConsumeMutation) AddReward(i int64) {
	if m.addreward != nil {
		*m.addreward += i
	} else {
		m.addreward = &i
	}
}

// AddedReward returns the value that was added to the "reward" field in this mutation.
func (m *NovelConsumeMutation) AddedReward() (r int64, exists bool) {
	v := m.addreward
	if v == nil {
		return
	}
	return *v, true
}

// ClearReward clears the value of the "reward" field.
func (m *NovelConsumeMutation) ClearReward() {
	m.reward = nil
	m.addreward = nil
	m.clearedFields[novelconsume.FieldReward] = struct{}{}
}

// RewardCleared returns if the "reward" field was cleared in this mutation.
func (m *NovelConsumeMutation) RewardCleared() bool {
	_, ok := m.clearedFields[novelconsume.FieldReward]
	return ok
}

// ResetReward resets all changes to the "reward" field.
func (m *NovelConsumeMutation) ResetReward() {
	m.reward = nil
	m.addreward = nil
	delete(m.clearedFields, novelconsume.FieldReward)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelConsumeMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelConsumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelConsumeMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelConsumeMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelConsumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelConsumeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelConsumeMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelConsumeMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelConsumeMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelConsumeMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelConsumeMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelConsumeMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelConsumeMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelConsumeMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelConsumeMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelConsumeMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelConsumeMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelConsumeMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelConsume entity.
// If the NovelConsume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelConsumeMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelConsumeMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelConsumeMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelConsumeMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the NovelConsumeMutation builder.
func (m *NovelConsumeMutation) Where(ps ...predicate.NovelConsume) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelConsumeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelConsume).
func (m *NovelConsumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelConsumeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.novelId != nil {
		fields = append(fields, novelconsume.FieldNovelId)
	}
	if m.coin != nil {
		fields = append(fields, novelconsume.FieldCoin)
	}
	if m.coupon != nil {
		fields = append(fields, novelconsume.FieldCoupon)
	}
	if m.discount != nil {
		fields = append(fields, novelconsume.FieldDiscount)
	}
	if m.reward != nil {
		fields = append(fields, novelconsume.FieldReward)
	}
	if m.createdAt != nil {
		fields = append(fields, novelconsume.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelconsume.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelconsume.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelconsume.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelconsume.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelConsumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelconsume.FieldNovelId:
		return m.NovelId()
	case novelconsume.FieldCoin:
		return m.Coin()
	case novelconsume.FieldCoupon:
		return m.Coupon()
	case novelconsume.FieldDiscount:
		return m.Discount()
	case novelconsume.FieldReward:
		return m.Reward()
	case novelconsume.FieldCreatedAt:
		return m.CreatedAt()
	case novelconsume.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelconsume.FieldCreateBy:
		return m.CreateBy()
	case novelconsume.FieldUpdateBy:
		return m.UpdateBy()
	case novelconsume.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelConsumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelconsume.FieldNovelId:
		return m.OldNovelId(ctx)
	case novelconsume.FieldCoin:
		return m.OldCoin(ctx)
	case novelconsume.FieldCoupon:
		return m.OldCoupon(ctx)
	case novelconsume.FieldDiscount:
		return m.OldDiscount(ctx)
	case novelconsume.FieldReward:
		return m.OldReward(ctx)
	case novelconsume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelconsume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelconsume.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelconsume.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelconsume.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelConsume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelConsumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelconsume.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case novelconsume.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case novelconsume.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case novelconsume.FieldDiscount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case novelconsume.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReward(v)
		return nil
	case novelconsume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelconsume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelconsume.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelconsume.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelconsume.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelConsume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelConsumeMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, novelconsume.FieldNovelId)
	}
	if m.addcoin != nil {
		fields = append(fields, novelconsume.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, novelconsume.FieldCoupon)
	}
	if m.adddiscount != nil {
		fields = append(fields, novelconsume.FieldDiscount)
	}
	if m.addreward != nil {
		fields = append(fields, novelconsume.FieldReward)
	}
	if m.addcreateBy != nil {
		fields = append(fields, novelconsume.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelconsume.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelconsume.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelConsumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelconsume.FieldNovelId:
		return m.AddedNovelId()
	case novelconsume.FieldCoin:
		return m.AddedCoin()
	case novelconsume.FieldCoupon:
		return m.AddedCoupon()
	case novelconsume.FieldDiscount:
		return m.AddedDiscount()
	case novelconsume.FieldReward:
		return m.AddedReward()
	case novelconsume.FieldCreateBy:
		return m.AddedCreateBy()
	case novelconsume.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelconsume.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelConsumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelconsume.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case novelconsume.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case novelconsume.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case novelconsume.FieldDiscount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case novelconsume.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReward(v)
		return nil
	case novelconsume.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelconsume.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelconsume.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelConsume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelConsumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelconsume.FieldCoin) {
		fields = append(fields, novelconsume.FieldCoin)
	}
	if m.FieldCleared(novelconsume.FieldCoupon) {
		fields = append(fields, novelconsume.FieldCoupon)
	}
	if m.FieldCleared(novelconsume.FieldDiscount) {
		fields = append(fields, novelconsume.FieldDiscount)
	}
	if m.FieldCleared(novelconsume.FieldReward) {
		fields = append(fields, novelconsume.FieldReward)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelConsumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelConsumeMutation) ClearField(name string) error {
	switch name {
	case novelconsume.FieldCoin:
		m.ClearCoin()
		return nil
	case novelconsume.FieldCoupon:
		m.ClearCoupon()
		return nil
	case novelconsume.FieldDiscount:
		m.ClearDiscount()
		return nil
	case novelconsume.FieldReward:
		m.ClearReward()
		return nil
	}
	return fmt.Errorf("unknown NovelConsume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelConsumeMutation) ResetField(name string) error {
	switch name {
	case novelconsume.FieldNovelId:
		m.ResetNovelId()
		return nil
	case novelconsume.FieldCoin:
		m.ResetCoin()
		return nil
	case novelconsume.FieldCoupon:
		m.ResetCoupon()
		return nil
	case novelconsume.FieldDiscount:
		m.ResetDiscount()
		return nil
	case novelconsume.FieldReward:
		m.ResetReward()
		return nil
	case novelconsume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelconsume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelconsume.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelconsume.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelconsume.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelConsume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelConsumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelConsumeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelConsumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelConsumeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelConsumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelConsumeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelConsumeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NovelConsume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelConsumeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NovelConsume edge %s", name)
}

// NovelMsgMutation represents an operation that mutates the NovelMsg nodes in the graph.
type NovelMsgMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	title         *string
	msg           *string
	msgType       *string
	status        *bool
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NovelMsg, error)
	predicates    []predicate.NovelMsg
}

var _ ent.Mutation = (*NovelMsgMutation)(nil)

// novelmsgOption allows management of the mutation configuration using functional options.
type novelmsgOption func(*NovelMsgMutation)

// newNovelMsgMutation creates new mutation for the NovelMsg entity.
func newNovelMsgMutation(c config, op Op, opts ...novelmsgOption) *NovelMsgMutation {
	m := &NovelMsgMutation{
		config:        c,
		op:            op,
		typ:           TypeNovelMsg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNovelMsgID sets the ID field of the mutation.
func withNovelMsgID(id int64) novelmsgOption {
	return func(m *NovelMsgMutation) {
		var (
			err   error
			once  sync.Once
			value *NovelMsg
		)
		m.oldValue = func(ctx context.Context) (*NovelMsg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NovelMsg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNovelMsg sets the old NovelMsg of the mutation.
func withNovelMsg(node *NovelMsg) novelmsgOption {
	return func(m *NovelMsgMutation) {
		m.oldValue = func(context.Context) (*NovelMsg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NovelMsgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NovelMsgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NovelMsgMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NovelMsgMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NovelMsg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NovelMsgMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NovelMsgMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *NovelMsgMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[novelmsg.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *NovelMsgMutation) TitleCleared() bool {
	_, ok := m.clearedFields[novelmsg.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *NovelMsgMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, novelmsg.FieldTitle)
}

// SetMsg sets the "msg" field.
func (m *NovelMsgMutation) SetMsg(s string) {
	m.msg = &s
}

// Msg returns the value of the "msg" field in the mutation.
func (m *NovelMsgMutation) Msg() (r string, exists bool) {
	v := m.msg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsg returns the old "msg" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsg: %w", err)
	}
	return oldValue.Msg, nil
}

// ClearMsg clears the value of the "msg" field.
func (m *NovelMsgMutation) ClearMsg() {
	m.msg = nil
	m.clearedFields[novelmsg.FieldMsg] = struct{}{}
}

// MsgCleared returns if the "msg" field was cleared in this mutation.
func (m *NovelMsgMutation) MsgCleared() bool {
	_, ok := m.clearedFields[novelmsg.FieldMsg]
	return ok
}

// ResetMsg resets all changes to the "msg" field.
func (m *NovelMsgMutation) ResetMsg() {
	m.msg = nil
	delete(m.clearedFields, novelmsg.FieldMsg)
}

// SetMsgType sets the "msgType" field.
func (m *NovelMsgMutation) SetMsgType(s string) {
	m.msgType = &s
}

// MsgType returns the value of the "msgType" field in the mutation.
func (m *NovelMsgMutation) MsgType() (r string, exists bool) {
	v := m.msgType
	if v == nil {
		return
	}
	return *v, true
}

// OldMsgType returns the old "msgType" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldMsgType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsgType: %w", err)
	}
	return oldValue.MsgType, nil
}

// ClearMsgType clears the value of the "msgType" field.
func (m *NovelMsgMutation) ClearMsgType() {
	m.msgType = nil
	m.clearedFields[novelmsg.FieldMsgType] = struct{}{}
}

// MsgTypeCleared returns if the "msgType" field was cleared in this mutation.
func (m *NovelMsgMutation) MsgTypeCleared() bool {
	_, ok := m.clearedFields[novelmsg.FieldMsgType]
	return ok
}

// ResetMsgType resets all changes to the "msgType" field.
func (m *NovelMsgMutation) ResetMsgType() {
	m.msgType = nil
	delete(m.clearedFields, novelmsg.FieldMsgType)
}

// SetStatus sets the "status" field.
func (m *NovelMsgMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *NovelMsgMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *NovelMsgMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[novelmsg.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *NovelMsgMutation) StatusCleared() bool {
	_, ok := m.clearedFields[novelmsg.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *NovelMsgMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, novelmsg.FieldStatus)
}

// SetCreatedAt sets the "createdAt" field.
func (m *NovelMsgMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NovelMsgMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NovelMsgMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *NovelMsgMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *NovelMsgMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *NovelMsgMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *NovelMsgMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *NovelMsgMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *NovelMsgMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *NovelMsgMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *NovelMsgMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *NovelMsgMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *NovelMsgMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *NovelMsgMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *NovelMsgMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *NovelMsgMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *NovelMsgMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *NovelMsgMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the NovelMsg entity.
// If the NovelMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NovelMsgMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *NovelMsgMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *NovelMsgMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *NovelMsgMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// Where appends a list predicates to the NovelMsgMutation builder.
func (m *NovelMsgMutation) Where(ps ...predicate.NovelMsg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NovelMsgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NovelMsg).
func (m *NovelMsgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NovelMsgMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, novelmsg.FieldTitle)
	}
	if m.msg != nil {
		fields = append(fields, novelmsg.FieldMsg)
	}
	if m.msgType != nil {
		fields = append(fields, novelmsg.FieldMsgType)
	}
	if m.status != nil {
		fields = append(fields, novelmsg.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, novelmsg.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, novelmsg.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, novelmsg.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, novelmsg.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, novelmsg.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NovelMsgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case novelmsg.FieldTitle:
		return m.Title()
	case novelmsg.FieldMsg:
		return m.Msg()
	case novelmsg.FieldMsgType:
		return m.MsgType()
	case novelmsg.FieldStatus:
		return m.Status()
	case novelmsg.FieldCreatedAt:
		return m.CreatedAt()
	case novelmsg.FieldUpdatedAt:
		return m.UpdatedAt()
	case novelmsg.FieldCreateBy:
		return m.CreateBy()
	case novelmsg.FieldUpdateBy:
		return m.UpdateBy()
	case novelmsg.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NovelMsgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case novelmsg.FieldTitle:
		return m.OldTitle(ctx)
	case novelmsg.FieldMsg:
		return m.OldMsg(ctx)
	case novelmsg.FieldMsgType:
		return m.OldMsgType(ctx)
	case novelmsg.FieldStatus:
		return m.OldStatus(ctx)
	case novelmsg.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case novelmsg.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case novelmsg.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case novelmsg.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case novelmsg.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown NovelMsg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelMsgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case novelmsg.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case novelmsg.FieldMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsg(v)
		return nil
	case novelmsg.FieldMsgType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsgType(v)
		return nil
	case novelmsg.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case novelmsg.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case novelmsg.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case novelmsg.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case novelmsg.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case novelmsg.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelMsg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NovelMsgMutation) AddedFields() []string {
	var fields []string
	if m.addcreateBy != nil {
		fields = append(fields, novelmsg.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, novelmsg.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, novelmsg.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NovelMsgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case novelmsg.FieldCreateBy:
		return m.AddedCreateBy()
	case novelmsg.FieldUpdateBy:
		return m.AddedUpdateBy()
	case novelmsg.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NovelMsgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case novelmsg.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case novelmsg.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case novelmsg.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown NovelMsg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NovelMsgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(novelmsg.FieldTitle) {
		fields = append(fields, novelmsg.FieldTitle)
	}
	if m.FieldCleared(novelmsg.FieldMsg) {
		fields = append(fields, novelmsg.FieldMsg)
	}
	if m.FieldCleared(novelmsg.FieldMsgType) {
		fields = append(fields, novelmsg.FieldMsgType)
	}
	if m.FieldCleared(novelmsg.FieldStatus) {
		fields = append(fields, novelmsg.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NovelMsgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NovelMsgMutation) ClearField(name string) error {
	switch name {
	case novelmsg.FieldTitle:
		m.ClearTitle()
		return nil
	case novelmsg.FieldMsg:
		m.ClearMsg()
		return nil
	case novelmsg.FieldMsgType:
		m.ClearMsgType()
		return nil
	case novelmsg.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown NovelMsg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NovelMsgMutation) ResetField(name string) error {
	switch name {
	case novelmsg.FieldTitle:
		m.ResetTitle()
		return nil
	case novelmsg.FieldMsg:
		m.ResetMsg()
		return nil
	case novelmsg.FieldMsgType:
		m.ResetMsgType()
		return nil
	case novelmsg.FieldStatus:
		m.ResetStatus()
		return nil
	case novelmsg.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case novelmsg.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case novelmsg.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case novelmsg.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case novelmsg.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown NovelMsg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NovelMsgMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NovelMsgMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NovelMsgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NovelMsgMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NovelMsgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NovelMsgMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NovelMsgMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NovelMsg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NovelMsgMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NovelMsg edge %s", name)
}

// PayOrderMutation represents an operation that mutates the PayOrder nodes in the graph.
type PayOrderMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	orderId          *string
	lastRead         *string
	lastChapter      *string
	paymentName      *string
	paymentId        *string
	state            *schema.OrderState
	addstate         *schema.OrderState
	payment          *int64
	addpayment       *int64
	paymentTime      *time.Time
	closeTime        *time.Time
	payType          *payorder.PayType
	coin             *int64
	addcoin          *int64
	coupon           *int64
	addcoupon        *int64
	vipDays          *string
	vipType          *int64
	addvipType       *int64
	vipName          *string
	times            *int32
	addtimes         *int32
	otherOrderId     *string
	remark           *string
	createdAt        *time.Time
	updatedAt        *time.Time
	createBy         *int64
	addcreateBy      *int64
	updateBy         *int64
	addupdateBy      *int64
	tenantId         *int64
	addtenantId      *int64
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	channel          *int64
	clearedchannel   bool
	agreement        *int64
	clearedagreement bool
	done             bool
	oldValue         func(context.Context) (*PayOrder, error)
	predicates       []predicate.PayOrder
}

var _ ent.Mutation = (*PayOrderMutation)(nil)

// payorderOption allows management of the mutation configuration using functional options.
type payorderOption func(*PayOrderMutation)

// newPayOrderMutation creates new mutation for the PayOrder entity.
func newPayOrderMutation(c config, op Op, opts ...payorderOption) *PayOrderMutation {
	m := &PayOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePayOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayOrderID sets the ID field of the mutation.
func withPayOrderID(id int64) payorderOption {
	return func(m *PayOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PayOrder
		)
		m.oldValue = func(ctx context.Context) (*PayOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PayOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayOrder sets the old PayOrder of the mutation.
func withPayOrder(node *PayOrder) payorderOption {
	return func(m *PayOrderMutation) {
		m.oldValue = func(context.Context) (*PayOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PayOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderId sets the "orderId" field.
func (m *PayOrderMutation) SetOrderId(s string) {
	m.orderId = &s
}

// OrderId returns the value of the "orderId" field in the mutation.
func (m *PayOrderMutation) OrderId() (r string, exists bool) {
	v := m.orderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderId returns the old "orderId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOrderId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderId: %w", err)
	}
	return oldValue.OrderId, nil
}

// ResetOrderId resets all changes to the "orderId" field.
func (m *PayOrderMutation) ResetOrderId() {
	m.orderId = nil
}

// SetUserId sets the "userId" field.
func (m *PayOrderMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *PayOrderMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *PayOrderMutation) ResetUserId() {
	m.user = nil
}

// SetChId sets the "chId" field.
func (m *PayOrderMutation) SetChId(i int64) {
	m.channel = &i
}

// ChId returns the value of the "chId" field in the mutation.
func (m *PayOrderMutation) ChId() (r int64, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChId returns the old "chId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldChId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChId: %w", err)
	}
	return oldValue.ChId, nil
}

// ResetChId resets all changes to the "chId" field.
func (m *PayOrderMutation) ResetChId() {
	m.channel = nil
}

// SetAgreementId sets the "agreementId" field.
func (m *PayOrderMutation) SetAgreementId(i int64) {
	m.agreement = &i
}

// AgreementId returns the value of the "agreementId" field in the mutation.
func (m *PayOrderMutation) AgreementId() (r int64, exists bool) {
	v := m.agreement
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementId returns the old "agreementId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldAgreementId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementId: %w", err)
	}
	return oldValue.AgreementId, nil
}

// ResetAgreementId resets all changes to the "agreementId" field.
func (m *PayOrderMutation) ResetAgreementId() {
	m.agreement = nil
}

// SetLastRead sets the "lastRead" field.
func (m *PayOrderMutation) SetLastRead(s string) {
	m.lastRead = &s
}

// LastRead returns the value of the "lastRead" field in the mutation.
func (m *PayOrderMutation) LastRead() (r string, exists bool) {
	v := m.lastRead
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRead returns the old "lastRead" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldLastRead(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRead: %w", err)
	}
	return oldValue.LastRead, nil
}

// ResetLastRead resets all changes to the "lastRead" field.
func (m *PayOrderMutation) ResetLastRead() {
	m.lastRead = nil
}

// SetLastChapter sets the "lastChapter" field.
func (m *PayOrderMutation) SetLastChapter(s string) {
	m.lastChapter = &s
}

// LastChapter returns the value of the "lastChapter" field in the mutation.
func (m *PayOrderMutation) LastChapter() (r string, exists bool) {
	v := m.lastChapter
	if v == nil {
		return
	}
	return *v, true
}

// OldLastChapter returns the old "lastChapter" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldLastChapter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastChapter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastChapter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastChapter: %w", err)
	}
	return oldValue.LastChapter, nil
}

// ResetLastChapter resets all changes to the "lastChapter" field.
func (m *PayOrderMutation) ResetLastChapter() {
	m.lastChapter = nil
}

// SetPaymentName sets the "paymentName" field.
func (m *PayOrderMutation) SetPaymentName(s string) {
	m.paymentName = &s
}

// PaymentName returns the value of the "paymentName" field in the mutation.
func (m *PayOrderMutation) PaymentName() (r string, exists bool) {
	v := m.paymentName
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentName returns the old "paymentName" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPaymentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentName: %w", err)
	}
	return oldValue.PaymentName, nil
}

// ResetPaymentName resets all changes to the "paymentName" field.
func (m *PayOrderMutation) ResetPaymentName() {
	m.paymentName = nil
}

// SetPaymentId sets the "paymentId" field.
func (m *PayOrderMutation) SetPaymentId(s string) {
	m.paymentId = &s
}

// PaymentId returns the value of the "paymentId" field in the mutation.
func (m *PayOrderMutation) PaymentId() (r string, exists bool) {
	v := m.paymentId
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentId returns the old "paymentId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPaymentId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentId: %w", err)
	}
	return oldValue.PaymentId, nil
}

// ResetPaymentId resets all changes to the "paymentId" field.
func (m *PayOrderMutation) ResetPaymentId() {
	m.paymentId = nil
}

// SetState sets the "state" field.
func (m *PayOrderMutation) SetState(ss schema.OrderState) {
	m.state = &ss
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *PayOrderMutation) State() (r schema.OrderState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldState(ctx context.Context) (v schema.OrderState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds ss to the "state" field.
func (m *PayOrderMutation) AddState(ss schema.OrderState) {
	if m.addstate != nil {
		*m.addstate += ss
	} else {
		m.addstate = &ss
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *PayOrderMutation) AddedState() (r schema.OrderState, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *PayOrderMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetPayment sets the "payment" field.
func (m *PayOrderMutation) SetPayment(i int64) {
	m.payment = &i
	m.addpayment = nil
}

// Payment returns the value of the "payment" field in the mutation.
func (m *PayOrderMutation) Payment() (r int64, exists bool) {
	v := m.payment
	if v == nil {
		return
	}
	return *v, true
}

// OldPayment returns the old "payment" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPayment(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayment: %w", err)
	}
	return oldValue.Payment, nil
}

// AddPayment adds i to the "payment" field.
func (m *PayOrderMutation) AddPayment(i int64) {
	if m.addpayment != nil {
		*m.addpayment += i
	} else {
		m.addpayment = &i
	}
}

// AddedPayment returns the value that was added to the "payment" field in this mutation.
func (m *PayOrderMutation) AddedPayment() (r int64, exists bool) {
	v := m.addpayment
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayment resets all changes to the "payment" field.
func (m *PayOrderMutation) ResetPayment() {
	m.payment = nil
	m.addpayment = nil
}

// SetPaymentTime sets the "paymentTime" field.
func (m *PayOrderMutation) SetPaymentTime(t time.Time) {
	m.paymentTime = &t
}

// PaymentTime returns the value of the "paymentTime" field in the mutation.
func (m *PayOrderMutation) PaymentTime() (r time.Time, exists bool) {
	v := m.paymentTime
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentTime returns the old "paymentTime" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPaymentTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentTime: %w", err)
	}
	return oldValue.PaymentTime, nil
}

// ResetPaymentTime resets all changes to the "paymentTime" field.
func (m *PayOrderMutation) ResetPaymentTime() {
	m.paymentTime = nil
}

// SetCloseTime sets the "closeTime" field.
func (m *PayOrderMutation) SetCloseTime(t time.Time) {
	m.closeTime = &t
}

// CloseTime returns the value of the "closeTime" field in the mutation.
func (m *PayOrderMutation) CloseTime() (r time.Time, exists bool) {
	v := m.closeTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseTime returns the old "closeTime" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCloseTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseTime: %w", err)
	}
	return oldValue.CloseTime, nil
}

// ResetCloseTime resets all changes to the "closeTime" field.
func (m *PayOrderMutation) ResetCloseTime() {
	m.closeTime = nil
}

// SetPayType sets the "payType" field.
func (m *PayOrderMutation) SetPayType(pt payorder.PayType) {
	m.payType = &pt
}

// PayType returns the value of the "payType" field in the mutation.
func (m *PayOrderMutation) PayType() (r payorder.PayType, exists bool) {
	v := m.payType
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "payType" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPayType(ctx context.Context) (v payorder.PayType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// ResetPayType resets all changes to the "payType" field.
func (m *PayOrderMutation) ResetPayType() {
	m.payType = nil
}

// SetCoin sets the "coin" field.
func (m *PayOrderMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *PayOrderMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *PayOrderMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *PayOrderMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoin resets all changes to the "coin" field.
func (m *PayOrderMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
}

// SetCoupon sets the "coupon" field.
func (m *PayOrderMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *PayOrderMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *PayOrderMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *PayOrderMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *PayOrderMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
}

// SetVipDays sets the "vipDays" field.
func (m *PayOrderMutation) SetVipDays(s string) {
	m.vipDays = &s
}

// VipDays returns the value of the "vipDays" field in the mutation.
func (m *PayOrderMutation) VipDays() (r string, exists bool) {
	v := m.vipDays
	if v == nil {
		return
	}
	return *v, true
}

// OldVipDays returns the old "vipDays" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldVipDays(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipDays: %w", err)
	}
	return oldValue.VipDays, nil
}

// ClearVipDays clears the value of the "vipDays" field.
func (m *PayOrderMutation) ClearVipDays() {
	m.vipDays = nil
	m.clearedFields[payorder.FieldVipDays] = struct{}{}
}

// VipDaysCleared returns if the "vipDays" field was cleared in this mutation.
func (m *PayOrderMutation) VipDaysCleared() bool {
	_, ok := m.clearedFields[payorder.FieldVipDays]
	return ok
}

// ResetVipDays resets all changes to the "vipDays" field.
func (m *PayOrderMutation) ResetVipDays() {
	m.vipDays = nil
	delete(m.clearedFields, payorder.FieldVipDays)
}

// SetVipType sets the "vipType" field.
func (m *PayOrderMutation) SetVipType(i int64) {
	m.vipType = &i
	m.addvipType = nil
}

// VipType returns the value of the "vipType" field in the mutation.
func (m *PayOrderMutation) VipType() (r int64, exists bool) {
	v := m.vipType
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vipType" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldVipType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vipType" field.
func (m *PayOrderMutation) AddVipType(i int64) {
	if m.addvipType != nil {
		*m.addvipType += i
	} else {
		m.addvipType = &i
	}
}

// AddedVipType returns the value that was added to the "vipType" field in this mutation.
func (m *PayOrderMutation) AddedVipType() (r int64, exists bool) {
	v := m.addvipType
	if v == nil {
		return
	}
	return *v, true
}

// ClearVipType clears the value of the "vipType" field.
func (m *PayOrderMutation) ClearVipType() {
	m.vipType = nil
	m.addvipType = nil
	m.clearedFields[payorder.FieldVipType] = struct{}{}
}

// VipTypeCleared returns if the "vipType" field was cleared in this mutation.
func (m *PayOrderMutation) VipTypeCleared() bool {
	_, ok := m.clearedFields[payorder.FieldVipType]
	return ok
}

// ResetVipType resets all changes to the "vipType" field.
func (m *PayOrderMutation) ResetVipType() {
	m.vipType = nil
	m.addvipType = nil
	delete(m.clearedFields, payorder.FieldVipType)
}

// SetVipName sets the "vipName" field.
func (m *PayOrderMutation) SetVipName(s string) {
	m.vipName = &s
}

// VipName returns the value of the "vipName" field in the mutation.
func (m *PayOrderMutation) VipName() (r string, exists bool) {
	v := m.vipName
	if v == nil {
		return
	}
	return *v, true
}

// OldVipName returns the old "vipName" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldVipName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipName: %w", err)
	}
	return oldValue.VipName, nil
}

// ClearVipName clears the value of the "vipName" field.
func (m *PayOrderMutation) ClearVipName() {
	m.vipName = nil
	m.clearedFields[payorder.FieldVipName] = struct{}{}
}

// VipNameCleared returns if the "vipName" field was cleared in this mutation.
func (m *PayOrderMutation) VipNameCleared() bool {
	_, ok := m.clearedFields[payorder.FieldVipName]
	return ok
}

// ResetVipName resets all changes to the "vipName" field.
func (m *PayOrderMutation) ResetVipName() {
	m.vipName = nil
	delete(m.clearedFields, payorder.FieldVipName)
}

// SetTimes sets the "times" field.
func (m *PayOrderMutation) SetTimes(i int32) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the value of the "times" field in the mutation.
func (m *PayOrderMutation) Times() (r int32, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old "times" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldTimes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to the "times" field.
func (m *PayOrderMutation) AddTimes(i int32) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the "times" field in this mutation.
func (m *PayOrderMutation) AddedTimes() (r int32, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes resets all changes to the "times" field.
func (m *PayOrderMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetOtherOrderId sets the "otherOrderId" field.
func (m *PayOrderMutation) SetOtherOrderId(s string) {
	m.otherOrderId = &s
}

// OtherOrderId returns the value of the "otherOrderId" field in the mutation.
func (m *PayOrderMutation) OtherOrderId() (r string, exists bool) {
	v := m.otherOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherOrderId returns the old "otherOrderId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOtherOrderId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherOrderId: %w", err)
	}
	return oldValue.OtherOrderId, nil
}

// ClearOtherOrderId clears the value of the "otherOrderId" field.
func (m *PayOrderMutation) ClearOtherOrderId() {
	m.otherOrderId = nil
	m.clearedFields[payorder.FieldOtherOrderId] = struct{}{}
}

// OtherOrderIdCleared returns if the "otherOrderId" field was cleared in this mutation.
func (m *PayOrderMutation) OtherOrderIdCleared() bool {
	_, ok := m.clearedFields[payorder.FieldOtherOrderId]
	return ok
}

// ResetOtherOrderId resets all changes to the "otherOrderId" field.
func (m *PayOrderMutation) ResetOtherOrderId() {
	m.otherOrderId = nil
	delete(m.clearedFields, payorder.FieldOtherOrderId)
}

// SetRemark sets the "remark" field.
func (m *PayOrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PayOrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PayOrderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[payorder.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PayOrderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[payorder.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PayOrderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, payorder.FieldRemark)
}

// SetCreatedAt sets the "createdAt" field.
func (m *PayOrderMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *PayOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *PayOrderMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *PayOrderMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *PayOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *PayOrderMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *PayOrderMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *PayOrderMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *PayOrderMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *PayOrderMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *PayOrderMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *PayOrderMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *PayOrderMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *PayOrderMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *PayOrderMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *PayOrderMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *PayOrderMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *PayOrderMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *PayOrderMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *PayOrderMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *PayOrderMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *PayOrderMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *PayOrderMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *PayOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PayOrderMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PayOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PayOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetChannelID sets the "channel" edge to the AdChannel entity by id.
func (m *PayOrderMutation) SetChannelID(id int64) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the AdChannel entity.
func (m *PayOrderMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the AdChannel entity was cleared.
func (m *PayOrderMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *PayOrderMutation) ChannelID() (id int64, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *PayOrderMutation) ChannelIDs() (ids []int64) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *PayOrderMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetAgreementID sets the "agreement" edge to the AgreementLog entity by id.
func (m *PayOrderMutation) SetAgreementID(id int64) {
	m.agreement = &id
}

// ClearAgreement clears the "agreement" edge to the AgreementLog entity.
func (m *PayOrderMutation) ClearAgreement() {
	m.clearedagreement = true
}

// AgreementCleared reports if the "agreement" edge to the AgreementLog entity was cleared.
func (m *PayOrderMutation) AgreementCleared() bool {
	return m.clearedagreement
}

// AgreementID returns the "agreement" edge ID in the mutation.
func (m *PayOrderMutation) AgreementID() (id int64, exists bool) {
	if m.agreement != nil {
		return *m.agreement, true
	}
	return
}

// AgreementIDs returns the "agreement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgreementID instead. It exists only for internal usage by the builders.
func (m *PayOrderMutation) AgreementIDs() (ids []int64) {
	if id := m.agreement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgreement resets all changes to the "agreement" edge.
func (m *PayOrderMutation) ResetAgreement() {
	m.agreement = nil
	m.clearedagreement = false
}

// Where appends a list predicates to the PayOrderMutation builder.
func (m *PayOrderMutation) Where(ps ...predicate.PayOrder) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PayOrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PayOrder).
func (m *PayOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayOrderMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.orderId != nil {
		fields = append(fields, payorder.FieldOrderId)
	}
	if m.user != nil {
		fields = append(fields, payorder.FieldUserId)
	}
	if m.channel != nil {
		fields = append(fields, payorder.FieldChId)
	}
	if m.agreement != nil {
		fields = append(fields, payorder.FieldAgreementId)
	}
	if m.lastRead != nil {
		fields = append(fields, payorder.FieldLastRead)
	}
	if m.lastChapter != nil {
		fields = append(fields, payorder.FieldLastChapter)
	}
	if m.paymentName != nil {
		fields = append(fields, payorder.FieldPaymentName)
	}
	if m.paymentId != nil {
		fields = append(fields, payorder.FieldPaymentId)
	}
	if m.state != nil {
		fields = append(fields, payorder.FieldState)
	}
	if m.payment != nil {
		fields = append(fields, payorder.FieldPayment)
	}
	if m.paymentTime != nil {
		fields = append(fields, payorder.FieldPaymentTime)
	}
	if m.closeTime != nil {
		fields = append(fields, payorder.FieldCloseTime)
	}
	if m.payType != nil {
		fields = append(fields, payorder.FieldPayType)
	}
	if m.coin != nil {
		fields = append(fields, payorder.FieldCoin)
	}
	if m.coupon != nil {
		fields = append(fields, payorder.FieldCoupon)
	}
	if m.vipDays != nil {
		fields = append(fields, payorder.FieldVipDays)
	}
	if m.vipType != nil {
		fields = append(fields, payorder.FieldVipType)
	}
	if m.vipName != nil {
		fields = append(fields, payorder.FieldVipName)
	}
	if m.times != nil {
		fields = append(fields, payorder.FieldTimes)
	}
	if m.otherOrderId != nil {
		fields = append(fields, payorder.FieldOtherOrderId)
	}
	if m.remark != nil {
		fields = append(fields, payorder.FieldRemark)
	}
	if m.createdAt != nil {
		fields = append(fields, payorder.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, payorder.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, payorder.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, payorder.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, payorder.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payorder.FieldOrderId:
		return m.OrderId()
	case payorder.FieldUserId:
		return m.UserId()
	case payorder.FieldChId:
		return m.ChId()
	case payorder.FieldAgreementId:
		return m.AgreementId()
	case payorder.FieldLastRead:
		return m.LastRead()
	case payorder.FieldLastChapter:
		return m.LastChapter()
	case payorder.FieldPaymentName:
		return m.PaymentName()
	case payorder.FieldPaymentId:
		return m.PaymentId()
	case payorder.FieldState:
		return m.State()
	case payorder.FieldPayment:
		return m.Payment()
	case payorder.FieldPaymentTime:
		return m.PaymentTime()
	case payorder.FieldCloseTime:
		return m.CloseTime()
	case payorder.FieldPayType:
		return m.PayType()
	case payorder.FieldCoin:
		return m.Coin()
	case payorder.FieldCoupon:
		return m.Coupon()
	case payorder.FieldVipDays:
		return m.VipDays()
	case payorder.FieldVipType:
		return m.VipType()
	case payorder.FieldVipName:
		return m.VipName()
	case payorder.FieldTimes:
		return m.Times()
	case payorder.FieldOtherOrderId:
		return m.OtherOrderId()
	case payorder.FieldRemark:
		return m.Remark()
	case payorder.FieldCreatedAt:
		return m.CreatedAt()
	case payorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case payorder.FieldCreateBy:
		return m.CreateBy()
	case payorder.FieldUpdateBy:
		return m.UpdateBy()
	case payorder.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payorder.FieldOrderId:
		return m.OldOrderId(ctx)
	case payorder.FieldUserId:
		return m.OldUserId(ctx)
	case payorder.FieldChId:
		return m.OldChId(ctx)
	case payorder.FieldAgreementId:
		return m.OldAgreementId(ctx)
	case payorder.FieldLastRead:
		return m.OldLastRead(ctx)
	case payorder.FieldLastChapter:
		return m.OldLastChapter(ctx)
	case payorder.FieldPaymentName:
		return m.OldPaymentName(ctx)
	case payorder.FieldPaymentId:
		return m.OldPaymentId(ctx)
	case payorder.FieldState:
		return m.OldState(ctx)
	case payorder.FieldPayment:
		return m.OldPayment(ctx)
	case payorder.FieldPaymentTime:
		return m.OldPaymentTime(ctx)
	case payorder.FieldCloseTime:
		return m.OldCloseTime(ctx)
	case payorder.FieldPayType:
		return m.OldPayType(ctx)
	case payorder.FieldCoin:
		return m.OldCoin(ctx)
	case payorder.FieldCoupon:
		return m.OldCoupon(ctx)
	case payorder.FieldVipDays:
		return m.OldVipDays(ctx)
	case payorder.FieldVipType:
		return m.OldVipType(ctx)
	case payorder.FieldVipName:
		return m.OldVipName(ctx)
	case payorder.FieldTimes:
		return m.OldTimes(ctx)
	case payorder.FieldOtherOrderId:
		return m.OldOtherOrderId(ctx)
	case payorder.FieldRemark:
		return m.OldRemark(ctx)
	case payorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payorder.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case payorder.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case payorder.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown PayOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payorder.FieldOrderId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderId(v)
		return nil
	case payorder.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case payorder.FieldChId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChId(v)
		return nil
	case payorder.FieldAgreementId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementId(v)
		return nil
	case payorder.FieldLastRead:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRead(v)
		return nil
	case payorder.FieldLastChapter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastChapter(v)
		return nil
	case payorder.FieldPaymentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentName(v)
		return nil
	case payorder.FieldPaymentId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentId(v)
		return nil
	case payorder.FieldState:
		v, ok := value.(schema.OrderState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case payorder.FieldPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayment(v)
		return nil
	case payorder.FieldPaymentTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentTime(v)
		return nil
	case payorder.FieldCloseTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseTime(v)
		return nil
	case payorder.FieldPayType:
		v, ok := value.(payorder.PayType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case payorder.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case payorder.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case payorder.FieldVipDays:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipDays(v)
		return nil
	case payorder.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case payorder.FieldVipName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipName(v)
		return nil
	case payorder.FieldTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case payorder.FieldOtherOrderId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherOrderId(v)
		return nil
	case payorder.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case payorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payorder.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case payorder.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case payorder.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown PayOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayOrderMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, payorder.FieldState)
	}
	if m.addpayment != nil {
		fields = append(fields, payorder.FieldPayment)
	}
	if m.addcoin != nil {
		fields = append(fields, payorder.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, payorder.FieldCoupon)
	}
	if m.addvipType != nil {
		fields = append(fields, payorder.FieldVipType)
	}
	if m.addtimes != nil {
		fields = append(fields, payorder.FieldTimes)
	}
	if m.addcreateBy != nil {
		fields = append(fields, payorder.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, payorder.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, payorder.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payorder.FieldState:
		return m.AddedState()
	case payorder.FieldPayment:
		return m.AddedPayment()
	case payorder.FieldCoin:
		return m.AddedCoin()
	case payorder.FieldCoupon:
		return m.AddedCoupon()
	case payorder.FieldVipType:
		return m.AddedVipType()
	case payorder.FieldTimes:
		return m.AddedTimes()
	case payorder.FieldCreateBy:
		return m.AddedCreateBy()
	case payorder.FieldUpdateBy:
		return m.AddedUpdateBy()
	case payorder.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payorder.FieldState:
		v, ok := value.(schema.OrderState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case payorder.FieldPayment:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayment(v)
		return nil
	case payorder.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case payorder.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case payorder.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	case payorder.FieldTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case payorder.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case payorder.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case payorder.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown PayOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payorder.FieldVipDays) {
		fields = append(fields, payorder.FieldVipDays)
	}
	if m.FieldCleared(payorder.FieldVipType) {
		fields = append(fields, payorder.FieldVipType)
	}
	if m.FieldCleared(payorder.FieldVipName) {
		fields = append(fields, payorder.FieldVipName)
	}
	if m.FieldCleared(payorder.FieldOtherOrderId) {
		fields = append(fields, payorder.FieldOtherOrderId)
	}
	if m.FieldCleared(payorder.FieldRemark) {
		fields = append(fields, payorder.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayOrderMutation) ClearField(name string) error {
	switch name {
	case payorder.FieldVipDays:
		m.ClearVipDays()
		return nil
	case payorder.FieldVipType:
		m.ClearVipType()
		return nil
	case payorder.FieldVipName:
		m.ClearVipName()
		return nil
	case payorder.FieldOtherOrderId:
		m.ClearOtherOrderId()
		return nil
	case payorder.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown PayOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayOrderMutation) ResetField(name string) error {
	switch name {
	case payorder.FieldOrderId:
		m.ResetOrderId()
		return nil
	case payorder.FieldUserId:
		m.ResetUserId()
		return nil
	case payorder.FieldChId:
		m.ResetChId()
		return nil
	case payorder.FieldAgreementId:
		m.ResetAgreementId()
		return nil
	case payorder.FieldLastRead:
		m.ResetLastRead()
		return nil
	case payorder.FieldLastChapter:
		m.ResetLastChapter()
		return nil
	case payorder.FieldPaymentName:
		m.ResetPaymentName()
		return nil
	case payorder.FieldPaymentId:
		m.ResetPaymentId()
		return nil
	case payorder.FieldState:
		m.ResetState()
		return nil
	case payorder.FieldPayment:
		m.ResetPayment()
		return nil
	case payorder.FieldPaymentTime:
		m.ResetPaymentTime()
		return nil
	case payorder.FieldCloseTime:
		m.ResetCloseTime()
		return nil
	case payorder.FieldPayType:
		m.ResetPayType()
		return nil
	case payorder.FieldCoin:
		m.ResetCoin()
		return nil
	case payorder.FieldCoupon:
		m.ResetCoupon()
		return nil
	case payorder.FieldVipDays:
		m.ResetVipDays()
		return nil
	case payorder.FieldVipType:
		m.ResetVipType()
		return nil
	case payorder.FieldVipName:
		m.ResetVipName()
		return nil
	case payorder.FieldTimes:
		m.ResetTimes()
		return nil
	case payorder.FieldOtherOrderId:
		m.ResetOtherOrderId()
		return nil
	case payorder.FieldRemark:
		m.ResetRemark()
		return nil
	case payorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payorder.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case payorder.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case payorder.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown PayOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, payorder.EdgeUser)
	}
	if m.channel != nil {
		edges = append(edges, payorder.EdgeChannel)
	}
	if m.agreement != nil {
		edges = append(edges, payorder.EdgeAgreement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case payorder.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case payorder.EdgeAgreement:
		if id := m.agreement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, payorder.EdgeUser)
	}
	if m.clearedchannel {
		edges = append(edges, payorder.EdgeChannel)
	}
	if m.clearedagreement {
		edges = append(edges, payorder.EdgeAgreement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case payorder.EdgeUser:
		return m.cleareduser
	case payorder.EdgeChannel:
		return m.clearedchannel
	case payorder.EdgeAgreement:
		return m.clearedagreement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayOrderMutation) ClearEdge(name string) error {
	switch name {
	case payorder.EdgeUser:
		m.ClearUser()
		return nil
	case payorder.EdgeChannel:
		m.ClearChannel()
		return nil
	case payorder.EdgeAgreement:
		m.ClearAgreement()
		return nil
	}
	return fmt.Errorf("unknown PayOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayOrderMutation) ResetEdge(name string) error {
	switch name {
	case payorder.EdgeUser:
		m.ResetUser()
		return nil
	case payorder.EdgeChannel:
		m.ResetChannel()
		return nil
	case payorder.EdgeAgreement:
		m.ResetAgreement()
		return nil
	}
	return fmt.Errorf("unknown PayOrder edge %s", name)
}

// SocialUserMutation represents an operation that mutates the SocialUser nodes in the graph.
type SocialUserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	unionid                  *string
	token                    *string
	openid                   *string
	routineOpenid            *string
	userName                 *string
	nickName                 *string
	birthday                 *time.Time
	phone                    *string
	email                    *string
	password                 *string
	avatar                   *string
	sex                      *int32
	addsex                   *int32
	region                   *string
	city                     *string
	language                 *string
	province                 *string
	country                  *string
	signature                *string
	remark                   *string
	groupid                  *int32
	addgroupid               *int32
	tagidList                *string
	subscribe                *int32
	addsubscribe             *int32
	subscribeTime            *int32
	addsubscribeTime         *int32
	sessionKey               *string
	userType                 *string
	createdAt                *time.Time
	updatedAt                *time.Time
	createBy                 *int64
	addcreateBy              *int64
	updateBy                 *int64
	addupdateBy              *int64
	tenantId                 *int64
	addtenantId              *int64
	clearedFields            map[string]struct{}
	tasks                    map[int64]struct{}
	removedtasks             map[int64]struct{}
	clearedtasks             bool
	events                   map[int64]struct{}
	removedevents            map[int64]struct{}
	clearedevents            bool
	listenRecords            map[int64]struct{}
	removedlistenRecords     map[int64]struct{}
	clearedlistenRecords     bool
	ads                      map[int64]struct{}
	removedads               map[int64]struct{}
	clearedads               bool
	bookshelves              map[int64]struct{}
	removedbookshelves       map[int64]struct{}
	clearedbookshelves       bool
	autoBuyNovels            map[int64]struct{}
	removedautoBuyNovels     map[int64]struct{}
	clearedautoBuyNovels     bool
	comments                 map[int64]struct{}
	removedcomments          map[int64]struct{}
	clearedcomments          bool
	msgs                     map[int64]struct{}
	removedmsgs              map[int64]struct{}
	clearedmsgs              bool
	orders                   map[int64]struct{}
	removedorders            map[int64]struct{}
	clearedorders            bool
	vips                     map[int64]struct{}
	removedvips              map[int64]struct{}
	clearedvips              bool
	balances                 map[int64]struct{}
	removedbalances          map[int64]struct{}
	clearedbalances          bool
	assetLogs                map[int64]struct{}
	removedassetLogs         map[int64]struct{}
	clearedassetLogs         bool
	buyChapterRecords        map[int64]struct{}
	removedbuyChapterRecords map[int64]struct{}
	clearedbuyChapterRecords bool
	buyNovelRecords          map[int64]struct{}
	removedbuyNovelRecords   map[int64]struct{}
	clearedbuyNovelRecords   bool
	channel                  *int64
	clearedchannel           bool
	done                     bool
	oldValue                 func(context.Context) (*SocialUser, error)
	predicates               []predicate.SocialUser
}

var _ ent.Mutation = (*SocialUserMutation)(nil)

// socialuserOption allows management of the mutation configuration using functional options.
type socialuserOption func(*SocialUserMutation)

// newSocialUserMutation creates new mutation for the SocialUser entity.
func newSocialUserMutation(c config, op Op, opts ...socialuserOption) *SocialUserMutation {
	m := &SocialUserMutation{
		config:        c,
		op:            op,
		typ:           TypeSocialUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSocialUserID sets the ID field of the mutation.
func withSocialUserID(id int64) socialuserOption {
	return func(m *SocialUserMutation) {
		var (
			err   error
			once  sync.Once
			value *SocialUser
		)
		m.oldValue = func(ctx context.Context) (*SocialUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SocialUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSocialUser sets the old SocialUser of the mutation.
func withSocialUser(node *SocialUser) socialuserOption {
	return func(m *SocialUserMutation) {
		m.oldValue = func(context.Context) (*SocialUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SocialUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SocialUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SocialUserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SocialUserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SocialUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChId sets the "chId" field.
func (m *SocialUserMutation) SetChId(i int64) {
	m.channel = &i
}

// ChId returns the value of the "chId" field in the mutation.
func (m *SocialUserMutation) ChId() (r int64, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChId returns the old "chId" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldChId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChId: %w", err)
	}
	return oldValue.ChId, nil
}

// ResetChId resets all changes to the "chId" field.
func (m *SocialUserMutation) ResetChId() {
	m.channel = nil
}

// SetUnionid sets the "unionid" field.
func (m *SocialUserMutation) SetUnionid(s string) {
	m.unionid = &s
}

// Unionid returns the value of the "unionid" field in the mutation.
func (m *SocialUserMutation) Unionid() (r string, exists bool) {
	v := m.unionid
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionid returns the old "unionid" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldUnionid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionid: %w", err)
	}
	return oldValue.Unionid, nil
}

// ClearUnionid clears the value of the "unionid" field.
func (m *SocialUserMutation) ClearUnionid() {
	m.unionid = nil
	m.clearedFields[socialuser.FieldUnionid] = struct{}{}
}

// UnionidCleared returns if the "unionid" field was cleared in this mutation.
func (m *SocialUserMutation) UnionidCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldUnionid]
	return ok
}

// ResetUnionid resets all changes to the "unionid" field.
func (m *SocialUserMutation) ResetUnionid() {
	m.unionid = nil
	delete(m.clearedFields, socialuser.FieldUnionid)
}

// SetToken sets the "token" field.
func (m *SocialUserMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SocialUserMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *SocialUserMutation) ClearToken() {
	m.token = nil
	m.clearedFields[socialuser.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *SocialUserMutation) TokenCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *SocialUserMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, socialuser.FieldToken)
}

// SetOpenid sets the "openid" field.
func (m *SocialUserMutation) SetOpenid(s string) {
	m.openid = &s
}

// Openid returns the value of the "openid" field in the mutation.
func (m *SocialUserMutation) Openid() (r string, exists bool) {
	v := m.openid
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenid returns the old "openid" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenid: %w", err)
	}
	return oldValue.Openid, nil
}

// ClearOpenid clears the value of the "openid" field.
func (m *SocialUserMutation) ClearOpenid() {
	m.openid = nil
	m.clearedFields[socialuser.FieldOpenid] = struct{}{}
}

// OpenidCleared returns if the "openid" field was cleared in this mutation.
func (m *SocialUserMutation) OpenidCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldOpenid]
	return ok
}

// ResetOpenid resets all changes to the "openid" field.
func (m *SocialUserMutation) ResetOpenid() {
	m.openid = nil
	delete(m.clearedFields, socialuser.FieldOpenid)
}

// SetRoutineOpenid sets the "routineOpenid" field.
func (m *SocialUserMutation) SetRoutineOpenid(s string) {
	m.routineOpenid = &s
}

// RoutineOpenid returns the value of the "routineOpenid" field in the mutation.
func (m *SocialUserMutation) RoutineOpenid() (r string, exists bool) {
	v := m.routineOpenid
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutineOpenid returns the old "routineOpenid" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldRoutineOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutineOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutineOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutineOpenid: %w", err)
	}
	return oldValue.RoutineOpenid, nil
}

// ClearRoutineOpenid clears the value of the "routineOpenid" field.
func (m *SocialUserMutation) ClearRoutineOpenid() {
	m.routineOpenid = nil
	m.clearedFields[socialuser.FieldRoutineOpenid] = struct{}{}
}

// RoutineOpenidCleared returns if the "routineOpenid" field was cleared in this mutation.
func (m *SocialUserMutation) RoutineOpenidCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldRoutineOpenid]
	return ok
}

// ResetRoutineOpenid resets all changes to the "routineOpenid" field.
func (m *SocialUserMutation) ResetRoutineOpenid() {
	m.routineOpenid = nil
	delete(m.clearedFields, socialuser.FieldRoutineOpenid)
}

// SetUserName sets the "userName" field.
func (m *SocialUserMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *SocialUserMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "userName" field.
func (m *SocialUserMutation) ClearUserName() {
	m.userName = nil
	m.clearedFields[socialuser.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "userName" field was cleared in this mutation.
func (m *SocialUserMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "userName" field.
func (m *SocialUserMutation) ResetUserName() {
	m.userName = nil
	delete(m.clearedFields, socialuser.FieldUserName)
}

// SetNickName sets the "nickName" field.
func (m *SocialUserMutation) SetNickName(s string) {
	m.nickName = &s
}

// NickName returns the value of the "nickName" field in the mutation.
func (m *SocialUserMutation) NickName() (r string, exists bool) {
	v := m.nickName
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nickName" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ClearNickName clears the value of the "nickName" field.
func (m *SocialUserMutation) ClearNickName() {
	m.nickName = nil
	m.clearedFields[socialuser.FieldNickName] = struct{}{}
}

// NickNameCleared returns if the "nickName" field was cleared in this mutation.
func (m *SocialUserMutation) NickNameCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldNickName]
	return ok
}

// ResetNickName resets all changes to the "nickName" field.
func (m *SocialUserMutation) ResetNickName() {
	m.nickName = nil
	delete(m.clearedFields, socialuser.FieldNickName)
}

// SetBirthday sets the "birthday" field.
func (m *SocialUserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *SocialUserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *SocialUserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[socialuser.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *SocialUserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *SocialUserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, socialuser.FieldBirthday)
}

// SetPhone sets the "phone" field.
func (m *SocialUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SocialUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *SocialUserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[socialuser.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *SocialUserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *SocialUserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, socialuser.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *SocialUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SocialUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SocialUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[socialuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SocialUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SocialUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, socialuser.FieldEmail)
}

// SetPassword sets the "password" field.
func (m *SocialUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *SocialUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *SocialUserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[socialuser.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *SocialUserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *SocialUserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, socialuser.FieldPassword)
}

// SetAvatar sets the "avatar" field.
func (m *SocialUserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *SocialUserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *SocialUserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[socialuser.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *SocialUserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *SocialUserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, socialuser.FieldAvatar)
}

// SetSex sets the "sex" field.
func (m *SocialUserMutation) SetSex(i int32) {
	m.sex = &i
	m.addsex = nil
}

// Sex returns the value of the "sex" field in the mutation.
func (m *SocialUserMutation) Sex() (r int32, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldSex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// AddSex adds i to the "sex" field.
func (m *SocialUserMutation) AddSex(i int32) {
	if m.addsex != nil {
		*m.addsex += i
	} else {
		m.addsex = &i
	}
}

// AddedSex returns the value that was added to the "sex" field in this mutation.
func (m *SocialUserMutation) AddedSex() (r int32, exists bool) {
	v := m.addsex
	if v == nil {
		return
	}
	return *v, true
}

// ClearSex clears the value of the "sex" field.
func (m *SocialUserMutation) ClearSex() {
	m.sex = nil
	m.addsex = nil
	m.clearedFields[socialuser.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *SocialUserMutation) SexCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *SocialUserMutation) ResetSex() {
	m.sex = nil
	m.addsex = nil
	delete(m.clearedFields, socialuser.FieldSex)
}

// SetRegion sets the "region" field.
func (m *SocialUserMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *SocialUserMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *SocialUserMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[socialuser.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *SocialUserMutation) RegionCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *SocialUserMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, socialuser.FieldRegion)
}

// SetCity sets the "city" field.
func (m *SocialUserMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *SocialUserMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *SocialUserMutation) ClearCity() {
	m.city = nil
	m.clearedFields[socialuser.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *SocialUserMutation) CityCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *SocialUserMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, socialuser.FieldCity)
}

// SetLanguage sets the "language" field.
func (m *SocialUserMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SocialUserMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *SocialUserMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[socialuser.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *SocialUserMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *SocialUserMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, socialuser.FieldLanguage)
}

// SetProvince sets the "province" field.
func (m *SocialUserMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *SocialUserMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *SocialUserMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[socialuser.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *SocialUserMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *SocialUserMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, socialuser.FieldProvince)
}

// SetCountry sets the "country" field.
func (m *SocialUserMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SocialUserMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *SocialUserMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[socialuser.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *SocialUserMutation) CountryCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *SocialUserMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, socialuser.FieldCountry)
}

// SetSignature sets the "signature" field.
func (m *SocialUserMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *SocialUserMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *SocialUserMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[socialuser.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *SocialUserMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *SocialUserMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, socialuser.FieldSignature)
}

// SetRemark sets the "remark" field.
func (m *SocialUserMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SocialUserMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SocialUserMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[socialuser.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SocialUserMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SocialUserMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, socialuser.FieldRemark)
}

// SetGroupid sets the "groupid" field.
func (m *SocialUserMutation) SetGroupid(i int32) {
	m.groupid = &i
	m.addgroupid = nil
}

// Groupid returns the value of the "groupid" field in the mutation.
func (m *SocialUserMutation) Groupid() (r int32, exists bool) {
	v := m.groupid
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupid returns the old "groupid" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldGroupid(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupid: %w", err)
	}
	return oldValue.Groupid, nil
}

// AddGroupid adds i to the "groupid" field.
func (m *SocialUserMutation) AddGroupid(i int32) {
	if m.addgroupid != nil {
		*m.addgroupid += i
	} else {
		m.addgroupid = &i
	}
}

// AddedGroupid returns the value that was added to the "groupid" field in this mutation.
func (m *SocialUserMutation) AddedGroupid() (r int32, exists bool) {
	v := m.addgroupid
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupid clears the value of the "groupid" field.
func (m *SocialUserMutation) ClearGroupid() {
	m.groupid = nil
	m.addgroupid = nil
	m.clearedFields[socialuser.FieldGroupid] = struct{}{}
}

// GroupidCleared returns if the "groupid" field was cleared in this mutation.
func (m *SocialUserMutation) GroupidCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldGroupid]
	return ok
}

// ResetGroupid resets all changes to the "groupid" field.
func (m *SocialUserMutation) ResetGroupid() {
	m.groupid = nil
	m.addgroupid = nil
	delete(m.clearedFields, socialuser.FieldGroupid)
}

// SetTagidList sets the "tagidList" field.
func (m *SocialUserMutation) SetTagidList(s string) {
	m.tagidList = &s
}

// TagidList returns the value of the "tagidList" field in the mutation.
func (m *SocialUserMutation) TagidList() (r string, exists bool) {
	v := m.tagidList
	if v == nil {
		return
	}
	return *v, true
}

// OldTagidList returns the old "tagidList" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldTagidList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagidList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagidList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagidList: %w", err)
	}
	return oldValue.TagidList, nil
}

// ClearTagidList clears the value of the "tagidList" field.
func (m *SocialUserMutation) ClearTagidList() {
	m.tagidList = nil
	m.clearedFields[socialuser.FieldTagidList] = struct{}{}
}

// TagidListCleared returns if the "tagidList" field was cleared in this mutation.
func (m *SocialUserMutation) TagidListCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldTagidList]
	return ok
}

// ResetTagidList resets all changes to the "tagidList" field.
func (m *SocialUserMutation) ResetTagidList() {
	m.tagidList = nil
	delete(m.clearedFields, socialuser.FieldTagidList)
}

// SetSubscribe sets the "subscribe" field.
func (m *SocialUserMutation) SetSubscribe(i int32) {
	m.subscribe = &i
	m.addsubscribe = nil
}

// Subscribe returns the value of the "subscribe" field in the mutation.
func (m *SocialUserMutation) Subscribe() (r int32, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribe returns the old "subscribe" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldSubscribe(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribe: %w", err)
	}
	return oldValue.Subscribe, nil
}

// AddSubscribe adds i to the "subscribe" field.
func (m *SocialUserMutation) AddSubscribe(i int32) {
	if m.addsubscribe != nil {
		*m.addsubscribe += i
	} else {
		m.addsubscribe = &i
	}
}

// AddedSubscribe returns the value that was added to the "subscribe" field in this mutation.
func (m *SocialUserMutation) AddedSubscribe() (r int32, exists bool) {
	v := m.addsubscribe
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubscribe clears the value of the "subscribe" field.
func (m *SocialUserMutation) ClearSubscribe() {
	m.subscribe = nil
	m.addsubscribe = nil
	m.clearedFields[socialuser.FieldSubscribe] = struct{}{}
}

// SubscribeCleared returns if the "subscribe" field was cleared in this mutation.
func (m *SocialUserMutation) SubscribeCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldSubscribe]
	return ok
}

// ResetSubscribe resets all changes to the "subscribe" field.
func (m *SocialUserMutation) ResetSubscribe() {
	m.subscribe = nil
	m.addsubscribe = nil
	delete(m.clearedFields, socialuser.FieldSubscribe)
}

// SetSubscribeTime sets the "subscribeTime" field.
func (m *SocialUserMutation) SetSubscribeTime(i int32) {
	m.subscribeTime = &i
	m.addsubscribeTime = nil
}

// SubscribeTime returns the value of the "subscribeTime" field in the mutation.
func (m *SocialUserMutation) SubscribeTime() (r int32, exists bool) {
	v := m.subscribeTime
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeTime returns the old "subscribeTime" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldSubscribeTime(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeTime: %w", err)
	}
	return oldValue.SubscribeTime, nil
}

// AddSubscribeTime adds i to the "subscribeTime" field.
func (m *SocialUserMutation) AddSubscribeTime(i int32) {
	if m.addsubscribeTime != nil {
		*m.addsubscribeTime += i
	} else {
		m.addsubscribeTime = &i
	}
}

// AddedSubscribeTime returns the value that was added to the "subscribeTime" field in this mutation.
func (m *SocialUserMutation) AddedSubscribeTime() (r int32, exists bool) {
	v := m.addsubscribeTime
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubscribeTime clears the value of the "subscribeTime" field.
func (m *SocialUserMutation) ClearSubscribeTime() {
	m.subscribeTime = nil
	m.addsubscribeTime = nil
	m.clearedFields[socialuser.FieldSubscribeTime] = struct{}{}
}

// SubscribeTimeCleared returns if the "subscribeTime" field was cleared in this mutation.
func (m *SocialUserMutation) SubscribeTimeCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldSubscribeTime]
	return ok
}

// ResetSubscribeTime resets all changes to the "subscribeTime" field.
func (m *SocialUserMutation) ResetSubscribeTime() {
	m.subscribeTime = nil
	m.addsubscribeTime = nil
	delete(m.clearedFields, socialuser.FieldSubscribeTime)
}

// SetSessionKey sets the "sessionKey" field.
func (m *SocialUserMutation) SetSessionKey(s string) {
	m.sessionKey = &s
}

// SessionKey returns the value of the "sessionKey" field in the mutation.
func (m *SocialUserMutation) SessionKey() (r string, exists bool) {
	v := m.sessionKey
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "sessionKey" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ClearSessionKey clears the value of the "sessionKey" field.
func (m *SocialUserMutation) ClearSessionKey() {
	m.sessionKey = nil
	m.clearedFields[socialuser.FieldSessionKey] = struct{}{}
}

// SessionKeyCleared returns if the "sessionKey" field was cleared in this mutation.
func (m *SocialUserMutation) SessionKeyCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldSessionKey]
	return ok
}

// ResetSessionKey resets all changes to the "sessionKey" field.
func (m *SocialUserMutation) ResetSessionKey() {
	m.sessionKey = nil
	delete(m.clearedFields, socialuser.FieldSessionKey)
}

// SetUserType sets the "userType" field.
func (m *SocialUserMutation) SetUserType(s string) {
	m.userType = &s
}

// UserType returns the value of the "userType" field in the mutation.
func (m *SocialUserMutation) UserType() (r string, exists bool) {
	v := m.userType
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "userType" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldUserType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ClearUserType clears the value of the "userType" field.
func (m *SocialUserMutation) ClearUserType() {
	m.userType = nil
	m.clearedFields[socialuser.FieldUserType] = struct{}{}
}

// UserTypeCleared returns if the "userType" field was cleared in this mutation.
func (m *SocialUserMutation) UserTypeCleared() bool {
	_, ok := m.clearedFields[socialuser.FieldUserType]
	return ok
}

// ResetUserType resets all changes to the "userType" field.
func (m *SocialUserMutation) ResetUserType() {
	m.userType = nil
	delete(m.clearedFields, socialuser.FieldUserType)
}

// SetCreatedAt sets the "createdAt" field.
func (m *SocialUserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *SocialUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *SocialUserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *SocialUserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *SocialUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *SocialUserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *SocialUserMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *SocialUserMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *SocialUserMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *SocialUserMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *SocialUserMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *SocialUserMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *SocialUserMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *SocialUserMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *SocialUserMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *SocialUserMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *SocialUserMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *SocialUserMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the SocialUser entity.
// If the SocialUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialUserMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *SocialUserMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *SocialUserMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *SocialUserMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// AddTaskIDs adds the "tasks" edge to the TaskLog entity by ids.
func (m *SocialUserMutation) AddTaskIDs(ids ...int64) {
	if m.tasks == nil {
		m.tasks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the TaskLog entity.
func (m *SocialUserMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the TaskLog entity was cleared.
func (m *SocialUserMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the TaskLog entity by IDs.
func (m *SocialUserMutation) RemoveTaskIDs(ids ...int64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the TaskLog entity.
func (m *SocialUserMutation) RemovedTasksIDs() (ids []int64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *SocialUserMutation) TasksIDs() (ids []int64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *SocialUserMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddEventIDs adds the "events" edge to the UserEvent entity by ids.
func (m *SocialUserMutation) AddEventIDs(ids ...int64) {
	if m.events == nil {
		m.events = make(map[int64]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the UserEvent entity.
func (m *SocialUserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the UserEvent entity was cleared.
func (m *SocialUserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the UserEvent entity by IDs.
func (m *SocialUserMutation) RemoveEventIDs(ids ...int64) {
	if m.removedevents == nil {
		m.removedevents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the UserEvent entity.
func (m *SocialUserMutation) RemovedEventsIDs() (ids []int64) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *SocialUserMutation) EventsIDs() (ids []int64) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *SocialUserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddListenRecordIDs adds the "listenRecords" edge to the ListenRecord entity by ids.
func (m *SocialUserMutation) AddListenRecordIDs(ids ...int64) {
	if m.listenRecords == nil {
		m.listenRecords = make(map[int64]struct{})
	}
	for i := range ids {
		m.listenRecords[ids[i]] = struct{}{}
	}
}

// ClearListenRecords clears the "listenRecords" edge to the ListenRecord entity.
func (m *SocialUserMutation) ClearListenRecords() {
	m.clearedlistenRecords = true
}

// ListenRecordsCleared reports if the "listenRecords" edge to the ListenRecord entity was cleared.
func (m *SocialUserMutation) ListenRecordsCleared() bool {
	return m.clearedlistenRecords
}

// RemoveListenRecordIDs removes the "listenRecords" edge to the ListenRecord entity by IDs.
func (m *SocialUserMutation) RemoveListenRecordIDs(ids ...int64) {
	if m.removedlistenRecords == nil {
		m.removedlistenRecords = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.listenRecords, ids[i])
		m.removedlistenRecords[ids[i]] = struct{}{}
	}
}

// RemovedListenRecords returns the removed IDs of the "listenRecords" edge to the ListenRecord entity.
func (m *SocialUserMutation) RemovedListenRecordsIDs() (ids []int64) {
	for id := range m.removedlistenRecords {
		ids = append(ids, id)
	}
	return
}

// ListenRecordsIDs returns the "listenRecords" edge IDs in the mutation.
func (m *SocialUserMutation) ListenRecordsIDs() (ids []int64) {
	for id := range m.listenRecords {
		ids = append(ids, id)
	}
	return
}

// ResetListenRecords resets all changes to the "listenRecords" edge.
func (m *SocialUserMutation) ResetListenRecords() {
	m.listenRecords = nil
	m.clearedlistenRecords = false
	m.removedlistenRecords = nil
}

// AddAdIDs adds the "ads" edge to the AdChangeLog entity by ids.
func (m *SocialUserMutation) AddAdIDs(ids ...int64) {
	if m.ads == nil {
		m.ads = make(map[int64]struct{})
	}
	for i := range ids {
		m.ads[ids[i]] = struct{}{}
	}
}

// ClearAds clears the "ads" edge to the AdChangeLog entity.
func (m *SocialUserMutation) ClearAds() {
	m.clearedads = true
}

// AdsCleared reports if the "ads" edge to the AdChangeLog entity was cleared.
func (m *SocialUserMutation) AdsCleared() bool {
	return m.clearedads
}

// RemoveAdIDs removes the "ads" edge to the AdChangeLog entity by IDs.
func (m *SocialUserMutation) RemoveAdIDs(ids ...int64) {
	if m.removedads == nil {
		m.removedads = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.ads, ids[i])
		m.removedads[ids[i]] = struct{}{}
	}
}

// RemovedAds returns the removed IDs of the "ads" edge to the AdChangeLog entity.
func (m *SocialUserMutation) RemovedAdsIDs() (ids []int64) {
	for id := range m.removedads {
		ids = append(ids, id)
	}
	return
}

// AdsIDs returns the "ads" edge IDs in the mutation.
func (m *SocialUserMutation) AdsIDs() (ids []int64) {
	for id := range m.ads {
		ids = append(ids, id)
	}
	return
}

// ResetAds resets all changes to the "ads" edge.
func (m *SocialUserMutation) ResetAds() {
	m.ads = nil
	m.clearedads = false
	m.removedads = nil
}

// AddBookshelfIDs adds the "bookshelves" edge to the NovelBookshelf entity by ids.
func (m *SocialUserMutation) AddBookshelfIDs(ids ...int64) {
	if m.bookshelves == nil {
		m.bookshelves = make(map[int64]struct{})
	}
	for i := range ids {
		m.bookshelves[ids[i]] = struct{}{}
	}
}

// ClearBookshelves clears the "bookshelves" edge to the NovelBookshelf entity.
func (m *SocialUserMutation) ClearBookshelves() {
	m.clearedbookshelves = true
}

// BookshelvesCleared reports if the "bookshelves" edge to the NovelBookshelf entity was cleared.
func (m *SocialUserMutation) BookshelvesCleared() bool {
	return m.clearedbookshelves
}

// RemoveBookshelfIDs removes the "bookshelves" edge to the NovelBookshelf entity by IDs.
func (m *SocialUserMutation) RemoveBookshelfIDs(ids ...int64) {
	if m.removedbookshelves == nil {
		m.removedbookshelves = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bookshelves, ids[i])
		m.removedbookshelves[ids[i]] = struct{}{}
	}
}

// RemovedBookshelves returns the removed IDs of the "bookshelves" edge to the NovelBookshelf entity.
func (m *SocialUserMutation) RemovedBookshelvesIDs() (ids []int64) {
	for id := range m.removedbookshelves {
		ids = append(ids, id)
	}
	return
}

// BookshelvesIDs returns the "bookshelves" edge IDs in the mutation.
func (m *SocialUserMutation) BookshelvesIDs() (ids []int64) {
	for id := range m.bookshelves {
		ids = append(ids, id)
	}
	return
}

// ResetBookshelves resets all changes to the "bookshelves" edge.
func (m *SocialUserMutation) ResetBookshelves() {
	m.bookshelves = nil
	m.clearedbookshelves = false
	m.removedbookshelves = nil
}

// AddAutoBuyNovelIDs adds the "autoBuyNovels" edge to the NovelAutoBuy entity by ids.
func (m *SocialUserMutation) AddAutoBuyNovelIDs(ids ...int64) {
	if m.autoBuyNovels == nil {
		m.autoBuyNovels = make(map[int64]struct{})
	}
	for i := range ids {
		m.autoBuyNovels[ids[i]] = struct{}{}
	}
}

// ClearAutoBuyNovels clears the "autoBuyNovels" edge to the NovelAutoBuy entity.
func (m *SocialUserMutation) ClearAutoBuyNovels() {
	m.clearedautoBuyNovels = true
}

// AutoBuyNovelsCleared reports if the "autoBuyNovels" edge to the NovelAutoBuy entity was cleared.
func (m *SocialUserMutation) AutoBuyNovelsCleared() bool {
	return m.clearedautoBuyNovels
}

// RemoveAutoBuyNovelIDs removes the "autoBuyNovels" edge to the NovelAutoBuy entity by IDs.
func (m *SocialUserMutation) RemoveAutoBuyNovelIDs(ids ...int64) {
	if m.removedautoBuyNovels == nil {
		m.removedautoBuyNovels = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.autoBuyNovels, ids[i])
		m.removedautoBuyNovels[ids[i]] = struct{}{}
	}
}

// RemovedAutoBuyNovels returns the removed IDs of the "autoBuyNovels" edge to the NovelAutoBuy entity.
func (m *SocialUserMutation) RemovedAutoBuyNovelsIDs() (ids []int64) {
	for id := range m.removedautoBuyNovels {
		ids = append(ids, id)
	}
	return
}

// AutoBuyNovelsIDs returns the "autoBuyNovels" edge IDs in the mutation.
func (m *SocialUserMutation) AutoBuyNovelsIDs() (ids []int64) {
	for id := range m.autoBuyNovels {
		ids = append(ids, id)
	}
	return
}

// ResetAutoBuyNovels resets all changes to the "autoBuyNovels" edge.
func (m *SocialUserMutation) ResetAutoBuyNovels() {
	m.autoBuyNovels = nil
	m.clearedautoBuyNovels = false
	m.removedautoBuyNovels = nil
}

// AddCommentIDs adds the "comments" edge to the NovelComment entity by ids.
func (m *SocialUserMutation) AddCommentIDs(ids ...int64) {
	if m.comments == nil {
		m.comments = make(map[int64]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the NovelComment entity.
func (m *SocialUserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the NovelComment entity was cleared.
func (m *SocialUserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the NovelComment entity by IDs.
func (m *SocialUserMutation) RemoveCommentIDs(ids ...int64) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the NovelComment entity.
func (m *SocialUserMutation) RemovedCommentsIDs() (ids []int64) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *SocialUserMutation) CommentsIDs() (ids []int64) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *SocialUserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddMsgIDs adds the "msgs" edge to the UserMsg entity by ids.
func (m *SocialUserMutation) AddMsgIDs(ids ...int64) {
	if m.msgs == nil {
		m.msgs = make(map[int64]struct{})
	}
	for i := range ids {
		m.msgs[ids[i]] = struct{}{}
	}
}

// ClearMsgs clears the "msgs" edge to the UserMsg entity.
func (m *SocialUserMutation) ClearMsgs() {
	m.clearedmsgs = true
}

// MsgsCleared reports if the "msgs" edge to the UserMsg entity was cleared.
func (m *SocialUserMutation) MsgsCleared() bool {
	return m.clearedmsgs
}

// RemoveMsgIDs removes the "msgs" edge to the UserMsg entity by IDs.
func (m *SocialUserMutation) RemoveMsgIDs(ids ...int64) {
	if m.removedmsgs == nil {
		m.removedmsgs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.msgs, ids[i])
		m.removedmsgs[ids[i]] = struct{}{}
	}
}

// RemovedMsgs returns the removed IDs of the "msgs" edge to the UserMsg entity.
func (m *SocialUserMutation) RemovedMsgsIDs() (ids []int64) {
	for id := range m.removedmsgs {
		ids = append(ids, id)
	}
	return
}

// MsgsIDs returns the "msgs" edge IDs in the mutation.
func (m *SocialUserMutation) MsgsIDs() (ids []int64) {
	for id := range m.msgs {
		ids = append(ids, id)
	}
	return
}

// ResetMsgs resets all changes to the "msgs" edge.
func (m *SocialUserMutation) ResetMsgs() {
	m.msgs = nil
	m.clearedmsgs = false
	m.removedmsgs = nil
}

// AddOrderIDs adds the "orders" edge to the PayOrder entity by ids.
func (m *SocialUserMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the PayOrder entity.
func (m *SocialUserMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the PayOrder entity was cleared.
func (m *SocialUserMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the PayOrder entity by IDs.
func (m *SocialUserMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the PayOrder entity.
func (m *SocialUserMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *SocialUserMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *SocialUserMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddVipIDs adds the "vips" edge to the VipUser entity by ids.
func (m *SocialUserMutation) AddVipIDs(ids ...int64) {
	if m.vips == nil {
		m.vips = make(map[int64]struct{})
	}
	for i := range ids {
		m.vips[ids[i]] = struct{}{}
	}
}

// ClearVips clears the "vips" edge to the VipUser entity.
func (m *SocialUserMutation) ClearVips() {
	m.clearedvips = true
}

// VipsCleared reports if the "vips" edge to the VipUser entity was cleared.
func (m *SocialUserMutation) VipsCleared() bool {
	return m.clearedvips
}

// RemoveVipIDs removes the "vips" edge to the VipUser entity by IDs.
func (m *SocialUserMutation) RemoveVipIDs(ids ...int64) {
	if m.removedvips == nil {
		m.removedvips = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.vips, ids[i])
		m.removedvips[ids[i]] = struct{}{}
	}
}

// RemovedVips returns the removed IDs of the "vips" edge to the VipUser entity.
func (m *SocialUserMutation) RemovedVipsIDs() (ids []int64) {
	for id := range m.removedvips {
		ids = append(ids, id)
	}
	return
}

// VipsIDs returns the "vips" edge IDs in the mutation.
func (m *SocialUserMutation) VipsIDs() (ids []int64) {
	for id := range m.vips {
		ids = append(ids, id)
	}
	return
}

// ResetVips resets all changes to the "vips" edge.
func (m *SocialUserMutation) ResetVips() {
	m.vips = nil
	m.clearedvips = false
	m.removedvips = nil
}

// AddBalanceIDs adds the "balances" edge to the AmBalance entity by ids.
func (m *SocialUserMutation) AddBalanceIDs(ids ...int64) {
	if m.balances == nil {
		m.balances = make(map[int64]struct{})
	}
	for i := range ids {
		m.balances[ids[i]] = struct{}{}
	}
}

// ClearBalances clears the "balances" edge to the AmBalance entity.
func (m *SocialUserMutation) ClearBalances() {
	m.clearedbalances = true
}

// BalancesCleared reports if the "balances" edge to the AmBalance entity was cleared.
func (m *SocialUserMutation) BalancesCleared() bool {
	return m.clearedbalances
}

// RemoveBalanceIDs removes the "balances" edge to the AmBalance entity by IDs.
func (m *SocialUserMutation) RemoveBalanceIDs(ids ...int64) {
	if m.removedbalances == nil {
		m.removedbalances = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.balances, ids[i])
		m.removedbalances[ids[i]] = struct{}{}
	}
}

// RemovedBalances returns the removed IDs of the "balances" edge to the AmBalance entity.
func (m *SocialUserMutation) RemovedBalancesIDs() (ids []int64) {
	for id := range m.removedbalances {
		ids = append(ids, id)
	}
	return
}

// BalancesIDs returns the "balances" edge IDs in the mutation.
func (m *SocialUserMutation) BalancesIDs() (ids []int64) {
	for id := range m.balances {
		ids = append(ids, id)
	}
	return
}

// ResetBalances resets all changes to the "balances" edge.
func (m *SocialUserMutation) ResetBalances() {
	m.balances = nil
	m.clearedbalances = false
	m.removedbalances = nil
}

// AddAssetLogIDs adds the "assetLogs" edge to the AssetChangeLog entity by ids.
func (m *SocialUserMutation) AddAssetLogIDs(ids ...int64) {
	if m.assetLogs == nil {
		m.assetLogs = make(map[int64]struct{})
	}
	for i := range ids {
		m.assetLogs[ids[i]] = struct{}{}
	}
}

// ClearAssetLogs clears the "assetLogs" edge to the AssetChangeLog entity.
func (m *SocialUserMutation) ClearAssetLogs() {
	m.clearedassetLogs = true
}

// AssetLogsCleared reports if the "assetLogs" edge to the AssetChangeLog entity was cleared.
func (m *SocialUserMutation) AssetLogsCleared() bool {
	return m.clearedassetLogs
}

// RemoveAssetLogIDs removes the "assetLogs" edge to the AssetChangeLog entity by IDs.
func (m *SocialUserMutation) RemoveAssetLogIDs(ids ...int64) {
	if m.removedassetLogs == nil {
		m.removedassetLogs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.assetLogs, ids[i])
		m.removedassetLogs[ids[i]] = struct{}{}
	}
}

// RemovedAssetLogs returns the removed IDs of the "assetLogs" edge to the AssetChangeLog entity.
func (m *SocialUserMutation) RemovedAssetLogsIDs() (ids []int64) {
	for id := range m.removedassetLogs {
		ids = append(ids, id)
	}
	return
}

// AssetLogsIDs returns the "assetLogs" edge IDs in the mutation.
func (m *SocialUserMutation) AssetLogsIDs() (ids []int64) {
	for id := range m.assetLogs {
		ids = append(ids, id)
	}
	return
}

// ResetAssetLogs resets all changes to the "assetLogs" edge.
func (m *SocialUserMutation) ResetAssetLogs() {
	m.assetLogs = nil
	m.clearedassetLogs = false
	m.removedassetLogs = nil
}

// AddBuyChapterRecordIDs adds the "buyChapterRecords" edge to the NovelBuyChapterRecord entity by ids.
func (m *SocialUserMutation) AddBuyChapterRecordIDs(ids ...int64) {
	if m.buyChapterRecords == nil {
		m.buyChapterRecords = make(map[int64]struct{})
	}
	for i := range ids {
		m.buyChapterRecords[ids[i]] = struct{}{}
	}
}

// ClearBuyChapterRecords clears the "buyChapterRecords" edge to the NovelBuyChapterRecord entity.
func (m *SocialUserMutation) ClearBuyChapterRecords() {
	m.clearedbuyChapterRecords = true
}

// BuyChapterRecordsCleared reports if the "buyChapterRecords" edge to the NovelBuyChapterRecord entity was cleared.
func (m *SocialUserMutation) BuyChapterRecordsCleared() bool {
	return m.clearedbuyChapterRecords
}

// RemoveBuyChapterRecordIDs removes the "buyChapterRecords" edge to the NovelBuyChapterRecord entity by IDs.
func (m *SocialUserMutation) RemoveBuyChapterRecordIDs(ids ...int64) {
	if m.removedbuyChapterRecords == nil {
		m.removedbuyChapterRecords = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.buyChapterRecords, ids[i])
		m.removedbuyChapterRecords[ids[i]] = struct{}{}
	}
}

// RemovedBuyChapterRecords returns the removed IDs of the "buyChapterRecords" edge to the NovelBuyChapterRecord entity.
func (m *SocialUserMutation) RemovedBuyChapterRecordsIDs() (ids []int64) {
	for id := range m.removedbuyChapterRecords {
		ids = append(ids, id)
	}
	return
}

// BuyChapterRecordsIDs returns the "buyChapterRecords" edge IDs in the mutation.
func (m *SocialUserMutation) BuyChapterRecordsIDs() (ids []int64) {
	for id := range m.buyChapterRecords {
		ids = append(ids, id)
	}
	return
}

// ResetBuyChapterRecords resets all changes to the "buyChapterRecords" edge.
func (m *SocialUserMutation) ResetBuyChapterRecords() {
	m.buyChapterRecords = nil
	m.clearedbuyChapterRecords = false
	m.removedbuyChapterRecords = nil
}

// AddBuyNovelRecordIDs adds the "buyNovelRecords" edge to the NovelBuyRecord entity by ids.
func (m *SocialUserMutation) AddBuyNovelRecordIDs(ids ...int64) {
	if m.buyNovelRecords == nil {
		m.buyNovelRecords = make(map[int64]struct{})
	}
	for i := range ids {
		m.buyNovelRecords[ids[i]] = struct{}{}
	}
}

// ClearBuyNovelRecords clears the "buyNovelRecords" edge to the NovelBuyRecord entity.
func (m *SocialUserMutation) ClearBuyNovelRecords() {
	m.clearedbuyNovelRecords = true
}

// BuyNovelRecordsCleared reports if the "buyNovelRecords" edge to the NovelBuyRecord entity was cleared.
func (m *SocialUserMutation) BuyNovelRecordsCleared() bool {
	return m.clearedbuyNovelRecords
}

// RemoveBuyNovelRecordIDs removes the "buyNovelRecords" edge to the NovelBuyRecord entity by IDs.
func (m *SocialUserMutation) RemoveBuyNovelRecordIDs(ids ...int64) {
	if m.removedbuyNovelRecords == nil {
		m.removedbuyNovelRecords = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.buyNovelRecords, ids[i])
		m.removedbuyNovelRecords[ids[i]] = struct{}{}
	}
}

// RemovedBuyNovelRecords returns the removed IDs of the "buyNovelRecords" edge to the NovelBuyRecord entity.
func (m *SocialUserMutation) RemovedBuyNovelRecordsIDs() (ids []int64) {
	for id := range m.removedbuyNovelRecords {
		ids = append(ids, id)
	}
	return
}

// BuyNovelRecordsIDs returns the "buyNovelRecords" edge IDs in the mutation.
func (m *SocialUserMutation) BuyNovelRecordsIDs() (ids []int64) {
	for id := range m.buyNovelRecords {
		ids = append(ids, id)
	}
	return
}

// ResetBuyNovelRecords resets all changes to the "buyNovelRecords" edge.
func (m *SocialUserMutation) ResetBuyNovelRecords() {
	m.buyNovelRecords = nil
	m.clearedbuyNovelRecords = false
	m.removedbuyNovelRecords = nil
}

// SetChannelID sets the "channel" edge to the AdChannel entity by id.
func (m *SocialUserMutation) SetChannelID(id int64) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the AdChannel entity.
func (m *SocialUserMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the AdChannel entity was cleared.
func (m *SocialUserMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *SocialUserMutation) ChannelID() (id int64, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *SocialUserMutation) ChannelIDs() (ids []int64) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *SocialUserMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the SocialUserMutation builder.
func (m *SocialUserMutation) Where(ps ...predicate.SocialUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SocialUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SocialUser).
func (m *SocialUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SocialUserMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.channel != nil {
		fields = append(fields, socialuser.FieldChId)
	}
	if m.unionid != nil {
		fields = append(fields, socialuser.FieldUnionid)
	}
	if m.token != nil {
		fields = append(fields, socialuser.FieldToken)
	}
	if m.openid != nil {
		fields = append(fields, socialuser.FieldOpenid)
	}
	if m.routineOpenid != nil {
		fields = append(fields, socialuser.FieldRoutineOpenid)
	}
	if m.userName != nil {
		fields = append(fields, socialuser.FieldUserName)
	}
	if m.nickName != nil {
		fields = append(fields, socialuser.FieldNickName)
	}
	if m.birthday != nil {
		fields = append(fields, socialuser.FieldBirthday)
	}
	if m.phone != nil {
		fields = append(fields, socialuser.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, socialuser.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, socialuser.FieldPassword)
	}
	if m.avatar != nil {
		fields = append(fields, socialuser.FieldAvatar)
	}
	if m.sex != nil {
		fields = append(fields, socialuser.FieldSex)
	}
	if m.region != nil {
		fields = append(fields, socialuser.FieldRegion)
	}
	if m.city != nil {
		fields = append(fields, socialuser.FieldCity)
	}
	if m.language != nil {
		fields = append(fields, socialuser.FieldLanguage)
	}
	if m.province != nil {
		fields = append(fields, socialuser.FieldProvince)
	}
	if m.country != nil {
		fields = append(fields, socialuser.FieldCountry)
	}
	if m.signature != nil {
		fields = append(fields, socialuser.FieldSignature)
	}
	if m.remark != nil {
		fields = append(fields, socialuser.FieldRemark)
	}
	if m.groupid != nil {
		fields = append(fields, socialuser.FieldGroupid)
	}
	if m.tagidList != nil {
		fields = append(fields, socialuser.FieldTagidList)
	}
	if m.subscribe != nil {
		fields = append(fields, socialuser.FieldSubscribe)
	}
	if m.subscribeTime != nil {
		fields = append(fields, socialuser.FieldSubscribeTime)
	}
	if m.sessionKey != nil {
		fields = append(fields, socialuser.FieldSessionKey)
	}
	if m.userType != nil {
		fields = append(fields, socialuser.FieldUserType)
	}
	if m.createdAt != nil {
		fields = append(fields, socialuser.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, socialuser.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, socialuser.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, socialuser.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, socialuser.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SocialUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case socialuser.FieldChId:
		return m.ChId()
	case socialuser.FieldUnionid:
		return m.Unionid()
	case socialuser.FieldToken:
		return m.Token()
	case socialuser.FieldOpenid:
		return m.Openid()
	case socialuser.FieldRoutineOpenid:
		return m.RoutineOpenid()
	case socialuser.FieldUserName:
		return m.UserName()
	case socialuser.FieldNickName:
		return m.NickName()
	case socialuser.FieldBirthday:
		return m.Birthday()
	case socialuser.FieldPhone:
		return m.Phone()
	case socialuser.FieldEmail:
		return m.Email()
	case socialuser.FieldPassword:
		return m.Password()
	case socialuser.FieldAvatar:
		return m.Avatar()
	case socialuser.FieldSex:
		return m.Sex()
	case socialuser.FieldRegion:
		return m.Region()
	case socialuser.FieldCity:
		return m.City()
	case socialuser.FieldLanguage:
		return m.Language()
	case socialuser.FieldProvince:
		return m.Province()
	case socialuser.FieldCountry:
		return m.Country()
	case socialuser.FieldSignature:
		return m.Signature()
	case socialuser.FieldRemark:
		return m.Remark()
	case socialuser.FieldGroupid:
		return m.Groupid()
	case socialuser.FieldTagidList:
		return m.TagidList()
	case socialuser.FieldSubscribe:
		return m.Subscribe()
	case socialuser.FieldSubscribeTime:
		return m.SubscribeTime()
	case socialuser.FieldSessionKey:
		return m.SessionKey()
	case socialuser.FieldUserType:
		return m.UserType()
	case socialuser.FieldCreatedAt:
		return m.CreatedAt()
	case socialuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case socialuser.FieldCreateBy:
		return m.CreateBy()
	case socialuser.FieldUpdateBy:
		return m.UpdateBy()
	case socialuser.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SocialUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case socialuser.FieldChId:
		return m.OldChId(ctx)
	case socialuser.FieldUnionid:
		return m.OldUnionid(ctx)
	case socialuser.FieldToken:
		return m.OldToken(ctx)
	case socialuser.FieldOpenid:
		return m.OldOpenid(ctx)
	case socialuser.FieldRoutineOpenid:
		return m.OldRoutineOpenid(ctx)
	case socialuser.FieldUserName:
		return m.OldUserName(ctx)
	case socialuser.FieldNickName:
		return m.OldNickName(ctx)
	case socialuser.FieldBirthday:
		return m.OldBirthday(ctx)
	case socialuser.FieldPhone:
		return m.OldPhone(ctx)
	case socialuser.FieldEmail:
		return m.OldEmail(ctx)
	case socialuser.FieldPassword:
		return m.OldPassword(ctx)
	case socialuser.FieldAvatar:
		return m.OldAvatar(ctx)
	case socialuser.FieldSex:
		return m.OldSex(ctx)
	case socialuser.FieldRegion:
		return m.OldRegion(ctx)
	case socialuser.FieldCity:
		return m.OldCity(ctx)
	case socialuser.FieldLanguage:
		return m.OldLanguage(ctx)
	case socialuser.FieldProvince:
		return m.OldProvince(ctx)
	case socialuser.FieldCountry:
		return m.OldCountry(ctx)
	case socialuser.FieldSignature:
		return m.OldSignature(ctx)
	case socialuser.FieldRemark:
		return m.OldRemark(ctx)
	case socialuser.FieldGroupid:
		return m.OldGroupid(ctx)
	case socialuser.FieldTagidList:
		return m.OldTagidList(ctx)
	case socialuser.FieldSubscribe:
		return m.OldSubscribe(ctx)
	case socialuser.FieldSubscribeTime:
		return m.OldSubscribeTime(ctx)
	case socialuser.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case socialuser.FieldUserType:
		return m.OldUserType(ctx)
	case socialuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case socialuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case socialuser.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case socialuser.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case socialuser.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown SocialUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SocialUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case socialuser.FieldChId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChId(v)
		return nil
	case socialuser.FieldUnionid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionid(v)
		return nil
	case socialuser.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case socialuser.FieldOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenid(v)
		return nil
	case socialuser.FieldRoutineOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutineOpenid(v)
		return nil
	case socialuser.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case socialuser.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case socialuser.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case socialuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case socialuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case socialuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case socialuser.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case socialuser.FieldSex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case socialuser.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case socialuser.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case socialuser.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case socialuser.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case socialuser.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case socialuser.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case socialuser.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case socialuser.FieldGroupid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupid(v)
		return nil
	case socialuser.FieldTagidList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagidList(v)
		return nil
	case socialuser.FieldSubscribe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribe(v)
		return nil
	case socialuser.FieldSubscribeTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeTime(v)
		return nil
	case socialuser.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case socialuser.FieldUserType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case socialuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case socialuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case socialuser.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case socialuser.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case socialuser.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown SocialUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SocialUserMutation) AddedFields() []string {
	var fields []string
	if m.addsex != nil {
		fields = append(fields, socialuser.FieldSex)
	}
	if m.addgroupid != nil {
		fields = append(fields, socialuser.FieldGroupid)
	}
	if m.addsubscribe != nil {
		fields = append(fields, socialuser.FieldSubscribe)
	}
	if m.addsubscribeTime != nil {
		fields = append(fields, socialuser.FieldSubscribeTime)
	}
	if m.addcreateBy != nil {
		fields = append(fields, socialuser.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, socialuser.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, socialuser.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SocialUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case socialuser.FieldSex:
		return m.AddedSex()
	case socialuser.FieldGroupid:
		return m.AddedGroupid()
	case socialuser.FieldSubscribe:
		return m.AddedSubscribe()
	case socialuser.FieldSubscribeTime:
		return m.AddedSubscribeTime()
	case socialuser.FieldCreateBy:
		return m.AddedCreateBy()
	case socialuser.FieldUpdateBy:
		return m.AddedUpdateBy()
	case socialuser.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SocialUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case socialuser.FieldSex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSex(v)
		return nil
	case socialuser.FieldGroupid:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupid(v)
		return nil
	case socialuser.FieldSubscribe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubscribe(v)
		return nil
	case socialuser.FieldSubscribeTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubscribeTime(v)
		return nil
	case socialuser.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case socialuser.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case socialuser.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown SocialUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SocialUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(socialuser.FieldUnionid) {
		fields = append(fields, socialuser.FieldUnionid)
	}
	if m.FieldCleared(socialuser.FieldToken) {
		fields = append(fields, socialuser.FieldToken)
	}
	if m.FieldCleared(socialuser.FieldOpenid) {
		fields = append(fields, socialuser.FieldOpenid)
	}
	if m.FieldCleared(socialuser.FieldRoutineOpenid) {
		fields = append(fields, socialuser.FieldRoutineOpenid)
	}
	if m.FieldCleared(socialuser.FieldUserName) {
		fields = append(fields, socialuser.FieldUserName)
	}
	if m.FieldCleared(socialuser.FieldNickName) {
		fields = append(fields, socialuser.FieldNickName)
	}
	if m.FieldCleared(socialuser.FieldBirthday) {
		fields = append(fields, socialuser.FieldBirthday)
	}
	if m.FieldCleared(socialuser.FieldPhone) {
		fields = append(fields, socialuser.FieldPhone)
	}
	if m.FieldCleared(socialuser.FieldEmail) {
		fields = append(fields, socialuser.FieldEmail)
	}
	if m.FieldCleared(socialuser.FieldPassword) {
		fields = append(fields, socialuser.FieldPassword)
	}
	if m.FieldCleared(socialuser.FieldAvatar) {
		fields = append(fields, socialuser.FieldAvatar)
	}
	if m.FieldCleared(socialuser.FieldSex) {
		fields = append(fields, socialuser.FieldSex)
	}
	if m.FieldCleared(socialuser.FieldRegion) {
		fields = append(fields, socialuser.FieldRegion)
	}
	if m.FieldCleared(socialuser.FieldCity) {
		fields = append(fields, socialuser.FieldCity)
	}
	if m.FieldCleared(socialuser.FieldLanguage) {
		fields = append(fields, socialuser.FieldLanguage)
	}
	if m.FieldCleared(socialuser.FieldProvince) {
		fields = append(fields, socialuser.FieldProvince)
	}
	if m.FieldCleared(socialuser.FieldCountry) {
		fields = append(fields, socialuser.FieldCountry)
	}
	if m.FieldCleared(socialuser.FieldSignature) {
		fields = append(fields, socialuser.FieldSignature)
	}
	if m.FieldCleared(socialuser.FieldRemark) {
		fields = append(fields, socialuser.FieldRemark)
	}
	if m.FieldCleared(socialuser.FieldGroupid) {
		fields = append(fields, socialuser.FieldGroupid)
	}
	if m.FieldCleared(socialuser.FieldTagidList) {
		fields = append(fields, socialuser.FieldTagidList)
	}
	if m.FieldCleared(socialuser.FieldSubscribe) {
		fields = append(fields, socialuser.FieldSubscribe)
	}
	if m.FieldCleared(socialuser.FieldSubscribeTime) {
		fields = append(fields, socialuser.FieldSubscribeTime)
	}
	if m.FieldCleared(socialuser.FieldSessionKey) {
		fields = append(fields, socialuser.FieldSessionKey)
	}
	if m.FieldCleared(socialuser.FieldUserType) {
		fields = append(fields, socialuser.FieldUserType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SocialUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SocialUserMutation) ClearField(name string) error {
	switch name {
	case socialuser.FieldUnionid:
		m.ClearUnionid()
		return nil
	case socialuser.FieldToken:
		m.ClearToken()
		return nil
	case socialuser.FieldOpenid:
		m.ClearOpenid()
		return nil
	case socialuser.FieldRoutineOpenid:
		m.ClearRoutineOpenid()
		return nil
	case socialuser.FieldUserName:
		m.ClearUserName()
		return nil
	case socialuser.FieldNickName:
		m.ClearNickName()
		return nil
	case socialuser.FieldBirthday:
		m.ClearBirthday()
		return nil
	case socialuser.FieldPhone:
		m.ClearPhone()
		return nil
	case socialuser.FieldEmail:
		m.ClearEmail()
		return nil
	case socialuser.FieldPassword:
		m.ClearPassword()
		return nil
	case socialuser.FieldAvatar:
		m.ClearAvatar()
		return nil
	case socialuser.FieldSex:
		m.ClearSex()
		return nil
	case socialuser.FieldRegion:
		m.ClearRegion()
		return nil
	case socialuser.FieldCity:
		m.ClearCity()
		return nil
	case socialuser.FieldLanguage:
		m.ClearLanguage()
		return nil
	case socialuser.FieldProvince:
		m.ClearProvince()
		return nil
	case socialuser.FieldCountry:
		m.ClearCountry()
		return nil
	case socialuser.FieldSignature:
		m.ClearSignature()
		return nil
	case socialuser.FieldRemark:
		m.ClearRemark()
		return nil
	case socialuser.FieldGroupid:
		m.ClearGroupid()
		return nil
	case socialuser.FieldTagidList:
		m.ClearTagidList()
		return nil
	case socialuser.FieldSubscribe:
		m.ClearSubscribe()
		return nil
	case socialuser.FieldSubscribeTime:
		m.ClearSubscribeTime()
		return nil
	case socialuser.FieldSessionKey:
		m.ClearSessionKey()
		return nil
	case socialuser.FieldUserType:
		m.ClearUserType()
		return nil
	}
	return fmt.Errorf("unknown SocialUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SocialUserMutation) ResetField(name string) error {
	switch name {
	case socialuser.FieldChId:
		m.ResetChId()
		return nil
	case socialuser.FieldUnionid:
		m.ResetUnionid()
		return nil
	case socialuser.FieldToken:
		m.ResetToken()
		return nil
	case socialuser.FieldOpenid:
		m.ResetOpenid()
		return nil
	case socialuser.FieldRoutineOpenid:
		m.ResetRoutineOpenid()
		return nil
	case socialuser.FieldUserName:
		m.ResetUserName()
		return nil
	case socialuser.FieldNickName:
		m.ResetNickName()
		return nil
	case socialuser.FieldBirthday:
		m.ResetBirthday()
		return nil
	case socialuser.FieldPhone:
		m.ResetPhone()
		return nil
	case socialuser.FieldEmail:
		m.ResetEmail()
		return nil
	case socialuser.FieldPassword:
		m.ResetPassword()
		return nil
	case socialuser.FieldAvatar:
		m.ResetAvatar()
		return nil
	case socialuser.FieldSex:
		m.ResetSex()
		return nil
	case socialuser.FieldRegion:
		m.ResetRegion()
		return nil
	case socialuser.FieldCity:
		m.ResetCity()
		return nil
	case socialuser.FieldLanguage:
		m.ResetLanguage()
		return nil
	case socialuser.FieldProvince:
		m.ResetProvince()
		return nil
	case socialuser.FieldCountry:
		m.ResetCountry()
		return nil
	case socialuser.FieldSignature:
		m.ResetSignature()
		return nil
	case socialuser.FieldRemark:
		m.ResetRemark()
		return nil
	case socialuser.FieldGroupid:
		m.ResetGroupid()
		return nil
	case socialuser.FieldTagidList:
		m.ResetTagidList()
		return nil
	case socialuser.FieldSubscribe:
		m.ResetSubscribe()
		return nil
	case socialuser.FieldSubscribeTime:
		m.ResetSubscribeTime()
		return nil
	case socialuser.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case socialuser.FieldUserType:
		m.ResetUserType()
		return nil
	case socialuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case socialuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case socialuser.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case socialuser.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case socialuser.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown SocialUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SocialUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.tasks != nil {
		edges = append(edges, socialuser.EdgeTasks)
	}
	if m.events != nil {
		edges = append(edges, socialuser.EdgeEvents)
	}
	if m.listenRecords != nil {
		edges = append(edges, socialuser.EdgeListenRecords)
	}
	if m.ads != nil {
		edges = append(edges, socialuser.EdgeAds)
	}
	if m.bookshelves != nil {
		edges = append(edges, socialuser.EdgeBookshelves)
	}
	if m.autoBuyNovels != nil {
		edges = append(edges, socialuser.EdgeAutoBuyNovels)
	}
	if m.comments != nil {
		edges = append(edges, socialuser.EdgeComments)
	}
	if m.msgs != nil {
		edges = append(edges, socialuser.EdgeMsgs)
	}
	if m.orders != nil {
		edges = append(edges, socialuser.EdgeOrders)
	}
	if m.vips != nil {
		edges = append(edges, socialuser.EdgeVips)
	}
	if m.balances != nil {
		edges = append(edges, socialuser.EdgeBalances)
	}
	if m.assetLogs != nil {
		edges = append(edges, socialuser.EdgeAssetLogs)
	}
	if m.buyChapterRecords != nil {
		edges = append(edges, socialuser.EdgeBuyChapterRecords)
	}
	if m.buyNovelRecords != nil {
		edges = append(edges, socialuser.EdgeBuyNovelRecords)
	}
	if m.channel != nil {
		edges = append(edges, socialuser.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SocialUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case socialuser.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeListenRecords:
		ids := make([]ent.Value, 0, len(m.listenRecords))
		for id := range m.listenRecords {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeAds:
		ids := make([]ent.Value, 0, len(m.ads))
		for id := range m.ads {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBookshelves:
		ids := make([]ent.Value, 0, len(m.bookshelves))
		for id := range m.bookshelves {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeAutoBuyNovels:
		ids := make([]ent.Value, 0, len(m.autoBuyNovels))
		for id := range m.autoBuyNovels {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeMsgs:
		ids := make([]ent.Value, 0, len(m.msgs))
		for id := range m.msgs {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeVips:
		ids := make([]ent.Value, 0, len(m.vips))
		for id := range m.vips {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBalances:
		ids := make([]ent.Value, 0, len(m.balances))
		for id := range m.balances {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeAssetLogs:
		ids := make([]ent.Value, 0, len(m.assetLogs))
		for id := range m.assetLogs {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBuyChapterRecords:
		ids := make([]ent.Value, 0, len(m.buyChapterRecords))
		for id := range m.buyChapterRecords {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBuyNovelRecords:
		ids := make([]ent.Value, 0, len(m.buyNovelRecords))
		for id := range m.buyNovelRecords {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SocialUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedtasks != nil {
		edges = append(edges, socialuser.EdgeTasks)
	}
	if m.removedevents != nil {
		edges = append(edges, socialuser.EdgeEvents)
	}
	if m.removedlistenRecords != nil {
		edges = append(edges, socialuser.EdgeListenRecords)
	}
	if m.removedads != nil {
		edges = append(edges, socialuser.EdgeAds)
	}
	if m.removedbookshelves != nil {
		edges = append(edges, socialuser.EdgeBookshelves)
	}
	if m.removedautoBuyNovels != nil {
		edges = append(edges, socialuser.EdgeAutoBuyNovels)
	}
	if m.removedcomments != nil {
		edges = append(edges, socialuser.EdgeComments)
	}
	if m.removedmsgs != nil {
		edges = append(edges, socialuser.EdgeMsgs)
	}
	if m.removedorders != nil {
		edges = append(edges, socialuser.EdgeOrders)
	}
	if m.removedvips != nil {
		edges = append(edges, socialuser.EdgeVips)
	}
	if m.removedbalances != nil {
		edges = append(edges, socialuser.EdgeBalances)
	}
	if m.removedassetLogs != nil {
		edges = append(edges, socialuser.EdgeAssetLogs)
	}
	if m.removedbuyChapterRecords != nil {
		edges = append(edges, socialuser.EdgeBuyChapterRecords)
	}
	if m.removedbuyNovelRecords != nil {
		edges = append(edges, socialuser.EdgeBuyNovelRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SocialUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case socialuser.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeListenRecords:
		ids := make([]ent.Value, 0, len(m.removedlistenRecords))
		for id := range m.removedlistenRecords {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeAds:
		ids := make([]ent.Value, 0, len(m.removedads))
		for id := range m.removedads {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBookshelves:
		ids := make([]ent.Value, 0, len(m.removedbookshelves))
		for id := range m.removedbookshelves {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeAutoBuyNovels:
		ids := make([]ent.Value, 0, len(m.removedautoBuyNovels))
		for id := range m.removedautoBuyNovels {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeMsgs:
		ids := make([]ent.Value, 0, len(m.removedmsgs))
		for id := range m.removedmsgs {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeVips:
		ids := make([]ent.Value, 0, len(m.removedvips))
		for id := range m.removedvips {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBalances:
		ids := make([]ent.Value, 0, len(m.removedbalances))
		for id := range m.removedbalances {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeAssetLogs:
		ids := make([]ent.Value, 0, len(m.removedassetLogs))
		for id := range m.removedassetLogs {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBuyChapterRecords:
		ids := make([]ent.Value, 0, len(m.removedbuyChapterRecords))
		for id := range m.removedbuyChapterRecords {
			ids = append(ids, id)
		}
		return ids
	case socialuser.EdgeBuyNovelRecords:
		ids := make([]ent.Value, 0, len(m.removedbuyNovelRecords))
		for id := range m.removedbuyNovelRecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SocialUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedtasks {
		edges = append(edges, socialuser.EdgeTasks)
	}
	if m.clearedevents {
		edges = append(edges, socialuser.EdgeEvents)
	}
	if m.clearedlistenRecords {
		edges = append(edges, socialuser.EdgeListenRecords)
	}
	if m.clearedads {
		edges = append(edges, socialuser.EdgeAds)
	}
	if m.clearedbookshelves {
		edges = append(edges, socialuser.EdgeBookshelves)
	}
	if m.clearedautoBuyNovels {
		edges = append(edges, socialuser.EdgeAutoBuyNovels)
	}
	if m.clearedcomments {
		edges = append(edges, socialuser.EdgeComments)
	}
	if m.clearedmsgs {
		edges = append(edges, socialuser.EdgeMsgs)
	}
	if m.clearedorders {
		edges = append(edges, socialuser.EdgeOrders)
	}
	if m.clearedvips {
		edges = append(edges, socialuser.EdgeVips)
	}
	if m.clearedbalances {
		edges = append(edges, socialuser.EdgeBalances)
	}
	if m.clearedassetLogs {
		edges = append(edges, socialuser.EdgeAssetLogs)
	}
	if m.clearedbuyChapterRecords {
		edges = append(edges, socialuser.EdgeBuyChapterRecords)
	}
	if m.clearedbuyNovelRecords {
		edges = append(edges, socialuser.EdgeBuyNovelRecords)
	}
	if m.clearedchannel {
		edges = append(edges, socialuser.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SocialUserMutation) EdgeCleared(name string) bool {
	switch name {
	case socialuser.EdgeTasks:
		return m.clearedtasks
	case socialuser.EdgeEvents:
		return m.clearedevents
	case socialuser.EdgeListenRecords:
		return m.clearedlistenRecords
	case socialuser.EdgeAds:
		return m.clearedads
	case socialuser.EdgeBookshelves:
		return m.clearedbookshelves
	case socialuser.EdgeAutoBuyNovels:
		return m.clearedautoBuyNovels
	case socialuser.EdgeComments:
		return m.clearedcomments
	case socialuser.EdgeMsgs:
		return m.clearedmsgs
	case socialuser.EdgeOrders:
		return m.clearedorders
	case socialuser.EdgeVips:
		return m.clearedvips
	case socialuser.EdgeBalances:
		return m.clearedbalances
	case socialuser.EdgeAssetLogs:
		return m.clearedassetLogs
	case socialuser.EdgeBuyChapterRecords:
		return m.clearedbuyChapterRecords
	case socialuser.EdgeBuyNovelRecords:
		return m.clearedbuyNovelRecords
	case socialuser.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SocialUserMutation) ClearEdge(name string) error {
	switch name {
	case socialuser.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown SocialUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SocialUserMutation) ResetEdge(name string) error {
	switch name {
	case socialuser.EdgeTasks:
		m.ResetTasks()
		return nil
	case socialuser.EdgeEvents:
		m.ResetEvents()
		return nil
	case socialuser.EdgeListenRecords:
		m.ResetListenRecords()
		return nil
	case socialuser.EdgeAds:
		m.ResetAds()
		return nil
	case socialuser.EdgeBookshelves:
		m.ResetBookshelves()
		return nil
	case socialuser.EdgeAutoBuyNovels:
		m.ResetAutoBuyNovels()
		return nil
	case socialuser.EdgeComments:
		m.ResetComments()
		return nil
	case socialuser.EdgeMsgs:
		m.ResetMsgs()
		return nil
	case socialuser.EdgeOrders:
		m.ResetOrders()
		return nil
	case socialuser.EdgeVips:
		m.ResetVips()
		return nil
	case socialuser.EdgeBalances:
		m.ResetBalances()
		return nil
	case socialuser.EdgeAssetLogs:
		m.ResetAssetLogs()
		return nil
	case socialuser.EdgeBuyChapterRecords:
		m.ResetBuyChapterRecords()
		return nil
	case socialuser.EdgeBuyNovelRecords:
		m.ResetBuyNovelRecords()
		return nil
	case socialuser.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown SocialUser edge %s", name)
}

// TaskLogMutation represents an operation that mutates the TaskLog nodes in the graph.
type TaskLogMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	taskGroup       *string
	taskCode        *string
	taskId          *int64
	addtaskId       *int64
	taskName        *string
	amount          *int64
	addamount       *int64
	reward          *int64
	addreward       *int64
	amountItem      *int32
	addamountItem   *int32
	rewardItem      *int32
	addrewardItem   *int32
	targetAmount    *int64
	addtargetAmount *int64
	doneAmount      *int64
	adddoneAmount   *int64
	state           *int64
	addstate        *int64
	doneAt          *time.Time
	obtainAt        *time.Time
	doneTimes       *int32
	adddoneTimes    *int32
	allTimes        *int32
	addallTimes     *int32
	effectTime      *time.Time
	expiredTime     *time.Time
	createdAt       *time.Time
	updatedAt       *time.Time
	createBy        *int64
	addcreateBy     *int64
	updateBy        *int64
	addupdateBy     *int64
	tenantId        *int64
	addtenantId     *int64
	clearedFields   map[string]struct{}
	user            *int64
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*TaskLog, error)
	predicates      []predicate.TaskLog
}

var _ ent.Mutation = (*TaskLogMutation)(nil)

// tasklogOption allows management of the mutation configuration using functional options.
type tasklogOption func(*TaskLogMutation)

// newTaskLogMutation creates new mutation for the TaskLog entity.
func newTaskLogMutation(c config, op Op, opts ...tasklogOption) *TaskLogMutation {
	m := &TaskLogMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskLogID sets the ID field of the mutation.
func withTaskLogID(id int64) tasklogOption {
	return func(m *TaskLogMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskLog
		)
		m.oldValue = func(ctx context.Context) (*TaskLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskLog sets the old TaskLog of the mutation.
func withTaskLog(node *TaskLog) tasklogOption {
	return func(m *TaskLogMutation) {
		m.oldValue = func(context.Context) (*TaskLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *TaskLogMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *TaskLogMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *TaskLogMutation) ResetUserId() {
	m.user = nil
}

// SetTaskGroup sets the "taskGroup" field.
func (m *TaskLogMutation) SetTaskGroup(s string) {
	m.taskGroup = &s
}

// TaskGroup returns the value of the "taskGroup" field in the mutation.
func (m *TaskLogMutation) TaskGroup() (r string, exists bool) {
	v := m.taskGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskGroup returns the old "taskGroup" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldTaskGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskGroup: %w", err)
	}
	return oldValue.TaskGroup, nil
}

// ClearTaskGroup clears the value of the "taskGroup" field.
func (m *TaskLogMutation) ClearTaskGroup() {
	m.taskGroup = nil
	m.clearedFields[tasklog.FieldTaskGroup] = struct{}{}
}

// TaskGroupCleared returns if the "taskGroup" field was cleared in this mutation.
func (m *TaskLogMutation) TaskGroupCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldTaskGroup]
	return ok
}

// ResetTaskGroup resets all changes to the "taskGroup" field.
func (m *TaskLogMutation) ResetTaskGroup() {
	m.taskGroup = nil
	delete(m.clearedFields, tasklog.FieldTaskGroup)
}

// SetTaskCode sets the "taskCode" field.
func (m *TaskLogMutation) SetTaskCode(s string) {
	m.taskCode = &s
}

// TaskCode returns the value of the "taskCode" field in the mutation.
func (m *TaskLogMutation) TaskCode() (r string, exists bool) {
	v := m.taskCode
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskCode returns the old "taskCode" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldTaskCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskCode: %w", err)
	}
	return oldValue.TaskCode, nil
}

// ClearTaskCode clears the value of the "taskCode" field.
func (m *TaskLogMutation) ClearTaskCode() {
	m.taskCode = nil
	m.clearedFields[tasklog.FieldTaskCode] = struct{}{}
}

// TaskCodeCleared returns if the "taskCode" field was cleared in this mutation.
func (m *TaskLogMutation) TaskCodeCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldTaskCode]
	return ok
}

// ResetTaskCode resets all changes to the "taskCode" field.
func (m *TaskLogMutation) ResetTaskCode() {
	m.taskCode = nil
	delete(m.clearedFields, tasklog.FieldTaskCode)
}

// SetTaskId sets the "taskId" field.
func (m *TaskLogMutation) SetTaskId(i int64) {
	m.taskId = &i
	m.addtaskId = nil
}

// TaskId returns the value of the "taskId" field in the mutation.
func (m *TaskLogMutation) TaskId() (r int64, exists bool) {
	v := m.taskId
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskId returns the old "taskId" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldTaskId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskId: %w", err)
	}
	return oldValue.TaskId, nil
}

// AddTaskId adds i to the "taskId" field.
func (m *TaskLogMutation) AddTaskId(i int64) {
	if m.addtaskId != nil {
		*m.addtaskId += i
	} else {
		m.addtaskId = &i
	}
}

// AddedTaskId returns the value that was added to the "taskId" field in this mutation.
func (m *TaskLogMutation) AddedTaskId() (r int64, exists bool) {
	v := m.addtaskId
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaskId clears the value of the "taskId" field.
func (m *TaskLogMutation) ClearTaskId() {
	m.taskId = nil
	m.addtaskId = nil
	m.clearedFields[tasklog.FieldTaskId] = struct{}{}
}

// TaskIdCleared returns if the "taskId" field was cleared in this mutation.
func (m *TaskLogMutation) TaskIdCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldTaskId]
	return ok
}

// ResetTaskId resets all changes to the "taskId" field.
func (m *TaskLogMutation) ResetTaskId() {
	m.taskId = nil
	m.addtaskId = nil
	delete(m.clearedFields, tasklog.FieldTaskId)
}

// SetTaskName sets the "taskName" field.
func (m *TaskLogMutation) SetTaskName(s string) {
	m.taskName = &s
}

// TaskName returns the value of the "taskName" field in the mutation.
func (m *TaskLogMutation) TaskName() (r string, exists bool) {
	v := m.taskName
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "taskName" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ClearTaskName clears the value of the "taskName" field.
func (m *TaskLogMutation) ClearTaskName() {
	m.taskName = nil
	m.clearedFields[tasklog.FieldTaskName] = struct{}{}
}

// TaskNameCleared returns if the "taskName" field was cleared in this mutation.
func (m *TaskLogMutation) TaskNameCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldTaskName]
	return ok
}

// ResetTaskName resets all changes to the "taskName" field.
func (m *TaskLogMutation) ResetTaskName() {
	m.taskName = nil
	delete(m.clearedFields, tasklog.FieldTaskName)
}

// SetAmount sets the "amount" field.
func (m *TaskLogMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TaskLogMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TaskLogMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TaskLogMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *TaskLogMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[tasklog.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *TaskLogMutation) AmountCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *TaskLogMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, tasklog.FieldAmount)
}

// SetReward sets the "reward" field.
func (m *TaskLogMutation) SetReward(i int64) {
	m.reward = &i
	m.addreward = nil
}

// Reward returns the value of the "reward" field in the mutation.
func (m *TaskLogMutation) Reward() (r int64, exists bool) {
	v := m.reward
	if v == nil {
		return
	}
	return *v, true
}

// OldReward returns the old "reward" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldReward(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReward: %w", err)
	}
	return oldValue.Reward, nil
}

// AddReward adds i to the "reward" field.
func (m *TaskLogMutation) AddReward(i int64) {
	if m.addreward != nil {
		*m.addreward += i
	} else {
		m.addreward = &i
	}
}

// AddedReward returns the value that was added to the "reward" field in this mutation.
func (m *TaskLogMutation) AddedReward() (r int64, exists bool) {
	v := m.addreward
	if v == nil {
		return
	}
	return *v, true
}

// ClearReward clears the value of the "reward" field.
func (m *TaskLogMutation) ClearReward() {
	m.reward = nil
	m.addreward = nil
	m.clearedFields[tasklog.FieldReward] = struct{}{}
}

// RewardCleared returns if the "reward" field was cleared in this mutation.
func (m *TaskLogMutation) RewardCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldReward]
	return ok
}

// ResetReward resets all changes to the "reward" field.
func (m *TaskLogMutation) ResetReward() {
	m.reward = nil
	m.addreward = nil
	delete(m.clearedFields, tasklog.FieldReward)
}

// SetAmountItem sets the "amountItem" field.
func (m *TaskLogMutation) SetAmountItem(i int32) {
	m.amountItem = &i
	m.addamountItem = nil
}

// AmountItem returns the value of the "amountItem" field in the mutation.
func (m *TaskLogMutation) AmountItem() (r int32, exists bool) {
	v := m.amountItem
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountItem returns the old "amountItem" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldAmountItem(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountItem: %w", err)
	}
	return oldValue.AmountItem, nil
}

// AddAmountItem adds i to the "amountItem" field.
func (m *TaskLogMutation) AddAmountItem(i int32) {
	if m.addamountItem != nil {
		*m.addamountItem += i
	} else {
		m.addamountItem = &i
	}
}

// AddedAmountItem returns the value that was added to the "amountItem" field in this mutation.
func (m *TaskLogMutation) AddedAmountItem() (r int32, exists bool) {
	v := m.addamountItem
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmountItem clears the value of the "amountItem" field.
func (m *TaskLogMutation) ClearAmountItem() {
	m.amountItem = nil
	m.addamountItem = nil
	m.clearedFields[tasklog.FieldAmountItem] = struct{}{}
}

// AmountItemCleared returns if the "amountItem" field was cleared in this mutation.
func (m *TaskLogMutation) AmountItemCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldAmountItem]
	return ok
}

// ResetAmountItem resets all changes to the "amountItem" field.
func (m *TaskLogMutation) ResetAmountItem() {
	m.amountItem = nil
	m.addamountItem = nil
	delete(m.clearedFields, tasklog.FieldAmountItem)
}

// SetRewardItem sets the "rewardItem" field.
func (m *TaskLogMutation) SetRewardItem(i int32) {
	m.rewardItem = &i
	m.addrewardItem = nil
}

// RewardItem returns the value of the "rewardItem" field in the mutation.
func (m *TaskLogMutation) RewardItem() (r int32, exists bool) {
	v := m.rewardItem
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardItem returns the old "rewardItem" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldRewardItem(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardItem: %w", err)
	}
	return oldValue.RewardItem, nil
}

// AddRewardItem adds i to the "rewardItem" field.
func (m *TaskLogMutation) AddRewardItem(i int32) {
	if m.addrewardItem != nil {
		*m.addrewardItem += i
	} else {
		m.addrewardItem = &i
	}
}

// AddedRewardItem returns the value that was added to the "rewardItem" field in this mutation.
func (m *TaskLogMutation) AddedRewardItem() (r int32, exists bool) {
	v := m.addrewardItem
	if v == nil {
		return
	}
	return *v, true
}

// ClearRewardItem clears the value of the "rewardItem" field.
func (m *TaskLogMutation) ClearRewardItem() {
	m.rewardItem = nil
	m.addrewardItem = nil
	m.clearedFields[tasklog.FieldRewardItem] = struct{}{}
}

// RewardItemCleared returns if the "rewardItem" field was cleared in this mutation.
func (m *TaskLogMutation) RewardItemCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldRewardItem]
	return ok
}

// ResetRewardItem resets all changes to the "rewardItem" field.
func (m *TaskLogMutation) ResetRewardItem() {
	m.rewardItem = nil
	m.addrewardItem = nil
	delete(m.clearedFields, tasklog.FieldRewardItem)
}

// SetTargetAmount sets the "targetAmount" field.
func (m *TaskLogMutation) SetTargetAmount(i int64) {
	m.targetAmount = &i
	m.addtargetAmount = nil
}

// TargetAmount returns the value of the "targetAmount" field in the mutation.
func (m *TaskLogMutation) TargetAmount() (r int64, exists bool) {
	v := m.targetAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAmount returns the old "targetAmount" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldTargetAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAmount: %w", err)
	}
	return oldValue.TargetAmount, nil
}

// AddTargetAmount adds i to the "targetAmount" field.
func (m *TaskLogMutation) AddTargetAmount(i int64) {
	if m.addtargetAmount != nil {
		*m.addtargetAmount += i
	} else {
		m.addtargetAmount = &i
	}
}

// AddedTargetAmount returns the value that was added to the "targetAmount" field in this mutation.
func (m *TaskLogMutation) AddedTargetAmount() (r int64, exists bool) {
	v := m.addtargetAmount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetAmount clears the value of the "targetAmount" field.
func (m *TaskLogMutation) ClearTargetAmount() {
	m.targetAmount = nil
	m.addtargetAmount = nil
	m.clearedFields[tasklog.FieldTargetAmount] = struct{}{}
}

// TargetAmountCleared returns if the "targetAmount" field was cleared in this mutation.
func (m *TaskLogMutation) TargetAmountCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldTargetAmount]
	return ok
}

// ResetTargetAmount resets all changes to the "targetAmount" field.
func (m *TaskLogMutation) ResetTargetAmount() {
	m.targetAmount = nil
	m.addtargetAmount = nil
	delete(m.clearedFields, tasklog.FieldTargetAmount)
}

// SetDoneAmount sets the "doneAmount" field.
func (m *TaskLogMutation) SetDoneAmount(i int64) {
	m.doneAmount = &i
	m.adddoneAmount = nil
}

// DoneAmount returns the value of the "doneAmount" field in the mutation.
func (m *TaskLogMutation) DoneAmount() (r int64, exists bool) {
	v := m.doneAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldDoneAmount returns the old "doneAmount" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldDoneAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoneAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoneAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoneAmount: %w", err)
	}
	return oldValue.DoneAmount, nil
}

// AddDoneAmount adds i to the "doneAmount" field.
func (m *TaskLogMutation) AddDoneAmount(i int64) {
	if m.adddoneAmount != nil {
		*m.adddoneAmount += i
	} else {
		m.adddoneAmount = &i
	}
}

// AddedDoneAmount returns the value that was added to the "doneAmount" field in this mutation.
func (m *TaskLogMutation) AddedDoneAmount() (r int64, exists bool) {
	v := m.adddoneAmount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDoneAmount clears the value of the "doneAmount" field.
func (m *TaskLogMutation) ClearDoneAmount() {
	m.doneAmount = nil
	m.adddoneAmount = nil
	m.clearedFields[tasklog.FieldDoneAmount] = struct{}{}
}

// DoneAmountCleared returns if the "doneAmount" field was cleared in this mutation.
func (m *TaskLogMutation) DoneAmountCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldDoneAmount]
	return ok
}

// ResetDoneAmount resets all changes to the "doneAmount" field.
func (m *TaskLogMutation) ResetDoneAmount() {
	m.doneAmount = nil
	m.adddoneAmount = nil
	delete(m.clearedFields, tasklog.FieldDoneAmount)
}

// SetState sets the "state" field.
func (m *TaskLogMutation) SetState(i int64) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *TaskLogMutation) State() (r int64, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldState(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *TaskLogMutation) AddState(i int64) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *TaskLogMutation) AddedState() (r int64, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ClearState clears the value of the "state" field.
func (m *TaskLogMutation) ClearState() {
	m.state = nil
	m.addstate = nil
	m.clearedFields[tasklog.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *TaskLogMutation) StateCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *TaskLogMutation) ResetState() {
	m.state = nil
	m.addstate = nil
	delete(m.clearedFields, tasklog.FieldState)
}

// SetDoneAt sets the "doneAt" field.
func (m *TaskLogMutation) SetDoneAt(t time.Time) {
	m.doneAt = &t
}

// DoneAt returns the value of the "doneAt" field in the mutation.
func (m *TaskLogMutation) DoneAt() (r time.Time, exists bool) {
	v := m.doneAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDoneAt returns the old "doneAt" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldDoneAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoneAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoneAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoneAt: %w", err)
	}
	return oldValue.DoneAt, nil
}

// ClearDoneAt clears the value of the "doneAt" field.
func (m *TaskLogMutation) ClearDoneAt() {
	m.doneAt = nil
	m.clearedFields[tasklog.FieldDoneAt] = struct{}{}
}

// DoneAtCleared returns if the "doneAt" field was cleared in this mutation.
func (m *TaskLogMutation) DoneAtCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldDoneAt]
	return ok
}

// ResetDoneAt resets all changes to the "doneAt" field.
func (m *TaskLogMutation) ResetDoneAt() {
	m.doneAt = nil
	delete(m.clearedFields, tasklog.FieldDoneAt)
}

// SetObtainAt sets the "obtainAt" field.
func (m *TaskLogMutation) SetObtainAt(t time.Time) {
	m.obtainAt = &t
}

// ObtainAt returns the value of the "obtainAt" field in the mutation.
func (m *TaskLogMutation) ObtainAt() (r time.Time, exists bool) {
	v := m.obtainAt
	if v == nil {
		return
	}
	return *v, true
}

// OldObtainAt returns the old "obtainAt" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldObtainAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObtainAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObtainAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObtainAt: %w", err)
	}
	return oldValue.ObtainAt, nil
}

// ClearObtainAt clears the value of the "obtainAt" field.
func (m *TaskLogMutation) ClearObtainAt() {
	m.obtainAt = nil
	m.clearedFields[tasklog.FieldObtainAt] = struct{}{}
}

// ObtainAtCleared returns if the "obtainAt" field was cleared in this mutation.
func (m *TaskLogMutation) ObtainAtCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldObtainAt]
	return ok
}

// ResetObtainAt resets all changes to the "obtainAt" field.
func (m *TaskLogMutation) ResetObtainAt() {
	m.obtainAt = nil
	delete(m.clearedFields, tasklog.FieldObtainAt)
}

// SetDoneTimes sets the "doneTimes" field.
func (m *TaskLogMutation) SetDoneTimes(i int32) {
	m.doneTimes = &i
	m.adddoneTimes = nil
}

// DoneTimes returns the value of the "doneTimes" field in the mutation.
func (m *TaskLogMutation) DoneTimes() (r int32, exists bool) {
	v := m.doneTimes
	if v == nil {
		return
	}
	return *v, true
}

// OldDoneTimes returns the old "doneTimes" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldDoneTimes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoneTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoneTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoneTimes: %w", err)
	}
	return oldValue.DoneTimes, nil
}

// AddDoneTimes adds i to the "doneTimes" field.
func (m *TaskLogMutation) AddDoneTimes(i int32) {
	if m.adddoneTimes != nil {
		*m.adddoneTimes += i
	} else {
		m.adddoneTimes = &i
	}
}

// AddedDoneTimes returns the value that was added to the "doneTimes" field in this mutation.
func (m *TaskLogMutation) AddedDoneTimes() (r int32, exists bool) {
	v := m.adddoneTimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearDoneTimes clears the value of the "doneTimes" field.
func (m *TaskLogMutation) ClearDoneTimes() {
	m.doneTimes = nil
	m.adddoneTimes = nil
	m.clearedFields[tasklog.FieldDoneTimes] = struct{}{}
}

// DoneTimesCleared returns if the "doneTimes" field was cleared in this mutation.
func (m *TaskLogMutation) DoneTimesCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldDoneTimes]
	return ok
}

// ResetDoneTimes resets all changes to the "doneTimes" field.
func (m *TaskLogMutation) ResetDoneTimes() {
	m.doneTimes = nil
	m.adddoneTimes = nil
	delete(m.clearedFields, tasklog.FieldDoneTimes)
}

// SetAllTimes sets the "allTimes" field.
func (m *TaskLogMutation) SetAllTimes(i int32) {
	m.allTimes = &i
	m.addallTimes = nil
}

// AllTimes returns the value of the "allTimes" field in the mutation.
func (m *TaskLogMutation) AllTimes() (r int32, exists bool) {
	v := m.allTimes
	if v == nil {
		return
	}
	return *v, true
}

// OldAllTimes returns the old "allTimes" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldAllTimes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllTimes: %w", err)
	}
	return oldValue.AllTimes, nil
}

// AddAllTimes adds i to the "allTimes" field.
func (m *TaskLogMutation) AddAllTimes(i int32) {
	if m.addallTimes != nil {
		*m.addallTimes += i
	} else {
		m.addallTimes = &i
	}
}

// AddedAllTimes returns the value that was added to the "allTimes" field in this mutation.
func (m *TaskLogMutation) AddedAllTimes() (r int32, exists bool) {
	v := m.addallTimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllTimes clears the value of the "allTimes" field.
func (m *TaskLogMutation) ClearAllTimes() {
	m.allTimes = nil
	m.addallTimes = nil
	m.clearedFields[tasklog.FieldAllTimes] = struct{}{}
}

// AllTimesCleared returns if the "allTimes" field was cleared in this mutation.
func (m *TaskLogMutation) AllTimesCleared() bool {
	_, ok := m.clearedFields[tasklog.FieldAllTimes]
	return ok
}

// ResetAllTimes resets all changes to the "allTimes" field.
func (m *TaskLogMutation) ResetAllTimes() {
	m.allTimes = nil
	m.addallTimes = nil
	delete(m.clearedFields, tasklog.FieldAllTimes)
}

// SetEffectTime sets the "effectTime" field.
func (m *TaskLogMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *TaskLogMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *TaskLogMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *TaskLogMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *TaskLogMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *TaskLogMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TaskLogMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TaskLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TaskLogMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TaskLogMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TaskLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TaskLogMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *TaskLogMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *TaskLogMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *TaskLogMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *TaskLogMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *TaskLogMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *TaskLogMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *TaskLogMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *TaskLogMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *TaskLogMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *TaskLogMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *TaskLogMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *TaskLogMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the TaskLog entity.
// If the TaskLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLogMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *TaskLogMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *TaskLogMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *TaskLogMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *TaskLogMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *TaskLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *TaskLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TaskLogMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TaskLogMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TaskLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TaskLogMutation builder.
func (m *TaskLogMutation) Where(ps ...predicate.TaskLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskLog).
func (m *TaskLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskLogMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.user != nil {
		fields = append(fields, tasklog.FieldUserId)
	}
	if m.taskGroup != nil {
		fields = append(fields, tasklog.FieldTaskGroup)
	}
	if m.taskCode != nil {
		fields = append(fields, tasklog.FieldTaskCode)
	}
	if m.taskId != nil {
		fields = append(fields, tasklog.FieldTaskId)
	}
	if m.taskName != nil {
		fields = append(fields, tasklog.FieldTaskName)
	}
	if m.amount != nil {
		fields = append(fields, tasklog.FieldAmount)
	}
	if m.reward != nil {
		fields = append(fields, tasklog.FieldReward)
	}
	if m.amountItem != nil {
		fields = append(fields, tasklog.FieldAmountItem)
	}
	if m.rewardItem != nil {
		fields = append(fields, tasklog.FieldRewardItem)
	}
	if m.targetAmount != nil {
		fields = append(fields, tasklog.FieldTargetAmount)
	}
	if m.doneAmount != nil {
		fields = append(fields, tasklog.FieldDoneAmount)
	}
	if m.state != nil {
		fields = append(fields, tasklog.FieldState)
	}
	if m.doneAt != nil {
		fields = append(fields, tasklog.FieldDoneAt)
	}
	if m.obtainAt != nil {
		fields = append(fields, tasklog.FieldObtainAt)
	}
	if m.doneTimes != nil {
		fields = append(fields, tasklog.FieldDoneTimes)
	}
	if m.allTimes != nil {
		fields = append(fields, tasklog.FieldAllTimes)
	}
	if m.effectTime != nil {
		fields = append(fields, tasklog.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, tasklog.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, tasklog.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, tasklog.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, tasklog.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, tasklog.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, tasklog.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasklog.FieldUserId:
		return m.UserId()
	case tasklog.FieldTaskGroup:
		return m.TaskGroup()
	case tasklog.FieldTaskCode:
		return m.TaskCode()
	case tasklog.FieldTaskId:
		return m.TaskId()
	case tasklog.FieldTaskName:
		return m.TaskName()
	case tasklog.FieldAmount:
		return m.Amount()
	case tasklog.FieldReward:
		return m.Reward()
	case tasklog.FieldAmountItem:
		return m.AmountItem()
	case tasklog.FieldRewardItem:
		return m.RewardItem()
	case tasklog.FieldTargetAmount:
		return m.TargetAmount()
	case tasklog.FieldDoneAmount:
		return m.DoneAmount()
	case tasklog.FieldState:
		return m.State()
	case tasklog.FieldDoneAt:
		return m.DoneAt()
	case tasklog.FieldObtainAt:
		return m.ObtainAt()
	case tasklog.FieldDoneTimes:
		return m.DoneTimes()
	case tasklog.FieldAllTimes:
		return m.AllTimes()
	case tasklog.FieldEffectTime:
		return m.EffectTime()
	case tasklog.FieldExpiredTime:
		return m.ExpiredTime()
	case tasklog.FieldCreatedAt:
		return m.CreatedAt()
	case tasklog.FieldUpdatedAt:
		return m.UpdatedAt()
	case tasklog.FieldCreateBy:
		return m.CreateBy()
	case tasklog.FieldUpdateBy:
		return m.UpdateBy()
	case tasklog.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasklog.FieldUserId:
		return m.OldUserId(ctx)
	case tasklog.FieldTaskGroup:
		return m.OldTaskGroup(ctx)
	case tasklog.FieldTaskCode:
		return m.OldTaskCode(ctx)
	case tasklog.FieldTaskId:
		return m.OldTaskId(ctx)
	case tasklog.FieldTaskName:
		return m.OldTaskName(ctx)
	case tasklog.FieldAmount:
		return m.OldAmount(ctx)
	case tasklog.FieldReward:
		return m.OldReward(ctx)
	case tasklog.FieldAmountItem:
		return m.OldAmountItem(ctx)
	case tasklog.FieldRewardItem:
		return m.OldRewardItem(ctx)
	case tasklog.FieldTargetAmount:
		return m.OldTargetAmount(ctx)
	case tasklog.FieldDoneAmount:
		return m.OldDoneAmount(ctx)
	case tasklog.FieldState:
		return m.OldState(ctx)
	case tasklog.FieldDoneAt:
		return m.OldDoneAt(ctx)
	case tasklog.FieldObtainAt:
		return m.OldObtainAt(ctx)
	case tasklog.FieldDoneTimes:
		return m.OldDoneTimes(ctx)
	case tasklog.FieldAllTimes:
		return m.OldAllTimes(ctx)
	case tasklog.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case tasklog.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case tasklog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasklog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tasklog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case tasklog.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case tasklog.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown TaskLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasklog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case tasklog.FieldTaskGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskGroup(v)
		return nil
	case tasklog.FieldTaskCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskCode(v)
		return nil
	case tasklog.FieldTaskId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskId(v)
		return nil
	case tasklog.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case tasklog.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case tasklog.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReward(v)
		return nil
	case tasklog.FieldAmountItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountItem(v)
		return nil
	case tasklog.FieldRewardItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardItem(v)
		return nil
	case tasklog.FieldTargetAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAmount(v)
		return nil
	case tasklog.FieldDoneAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoneAmount(v)
		return nil
	case tasklog.FieldState:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case tasklog.FieldDoneAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoneAt(v)
		return nil
	case tasklog.FieldObtainAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObtainAt(v)
		return nil
	case tasklog.FieldDoneTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoneTimes(v)
		return nil
	case tasklog.FieldAllTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllTimes(v)
		return nil
	case tasklog.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case tasklog.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case tasklog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasklog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tasklog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case tasklog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case tasklog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown TaskLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskLogMutation) AddedFields() []string {
	var fields []string
	if m.addtaskId != nil {
		fields = append(fields, tasklog.FieldTaskId)
	}
	if m.addamount != nil {
		fields = append(fields, tasklog.FieldAmount)
	}
	if m.addreward != nil {
		fields = append(fields, tasklog.FieldReward)
	}
	if m.addamountItem != nil {
		fields = append(fields, tasklog.FieldAmountItem)
	}
	if m.addrewardItem != nil {
		fields = append(fields, tasklog.FieldRewardItem)
	}
	if m.addtargetAmount != nil {
		fields = append(fields, tasklog.FieldTargetAmount)
	}
	if m.adddoneAmount != nil {
		fields = append(fields, tasklog.FieldDoneAmount)
	}
	if m.addstate != nil {
		fields = append(fields, tasklog.FieldState)
	}
	if m.adddoneTimes != nil {
		fields = append(fields, tasklog.FieldDoneTimes)
	}
	if m.addallTimes != nil {
		fields = append(fields, tasklog.FieldAllTimes)
	}
	if m.addcreateBy != nil {
		fields = append(fields, tasklog.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, tasklog.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, tasklog.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tasklog.FieldTaskId:
		return m.AddedTaskId()
	case tasklog.FieldAmount:
		return m.AddedAmount()
	case tasklog.FieldReward:
		return m.AddedReward()
	case tasklog.FieldAmountItem:
		return m.AddedAmountItem()
	case tasklog.FieldRewardItem:
		return m.AddedRewardItem()
	case tasklog.FieldTargetAmount:
		return m.AddedTargetAmount()
	case tasklog.FieldDoneAmount:
		return m.AddedDoneAmount()
	case tasklog.FieldState:
		return m.AddedState()
	case tasklog.FieldDoneTimes:
		return m.AddedDoneTimes()
	case tasklog.FieldAllTimes:
		return m.AddedAllTimes()
	case tasklog.FieldCreateBy:
		return m.AddedCreateBy()
	case tasklog.FieldUpdateBy:
		return m.AddedUpdateBy()
	case tasklog.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tasklog.FieldTaskId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskId(v)
		return nil
	case tasklog.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case tasklog.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReward(v)
		return nil
	case tasklog.FieldAmountItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountItem(v)
		return nil
	case tasklog.FieldRewardItem:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardItem(v)
		return nil
	case tasklog.FieldTargetAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetAmount(v)
		return nil
	case tasklog.FieldDoneAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoneAmount(v)
		return nil
	case tasklog.FieldState:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case tasklog.FieldDoneTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoneTimes(v)
		return nil
	case tasklog.FieldAllTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllTimes(v)
		return nil
	case tasklog.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case tasklog.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case tasklog.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown TaskLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tasklog.FieldTaskGroup) {
		fields = append(fields, tasklog.FieldTaskGroup)
	}
	if m.FieldCleared(tasklog.FieldTaskCode) {
		fields = append(fields, tasklog.FieldTaskCode)
	}
	if m.FieldCleared(tasklog.FieldTaskId) {
		fields = append(fields, tasklog.FieldTaskId)
	}
	if m.FieldCleared(tasklog.FieldTaskName) {
		fields = append(fields, tasklog.FieldTaskName)
	}
	if m.FieldCleared(tasklog.FieldAmount) {
		fields = append(fields, tasklog.FieldAmount)
	}
	if m.FieldCleared(tasklog.FieldReward) {
		fields = append(fields, tasklog.FieldReward)
	}
	if m.FieldCleared(tasklog.FieldAmountItem) {
		fields = append(fields, tasklog.FieldAmountItem)
	}
	if m.FieldCleared(tasklog.FieldRewardItem) {
		fields = append(fields, tasklog.FieldRewardItem)
	}
	if m.FieldCleared(tasklog.FieldTargetAmount) {
		fields = append(fields, tasklog.FieldTargetAmount)
	}
	if m.FieldCleared(tasklog.FieldDoneAmount) {
		fields = append(fields, tasklog.FieldDoneAmount)
	}
	if m.FieldCleared(tasklog.FieldState) {
		fields = append(fields, tasklog.FieldState)
	}
	if m.FieldCleared(tasklog.FieldDoneAt) {
		fields = append(fields, tasklog.FieldDoneAt)
	}
	if m.FieldCleared(tasklog.FieldObtainAt) {
		fields = append(fields, tasklog.FieldObtainAt)
	}
	if m.FieldCleared(tasklog.FieldDoneTimes) {
		fields = append(fields, tasklog.FieldDoneTimes)
	}
	if m.FieldCleared(tasklog.FieldAllTimes) {
		fields = append(fields, tasklog.FieldAllTimes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskLogMutation) ClearField(name string) error {
	switch name {
	case tasklog.FieldTaskGroup:
		m.ClearTaskGroup()
		return nil
	case tasklog.FieldTaskCode:
		m.ClearTaskCode()
		return nil
	case tasklog.FieldTaskId:
		m.ClearTaskId()
		return nil
	case tasklog.FieldTaskName:
		m.ClearTaskName()
		return nil
	case tasklog.FieldAmount:
		m.ClearAmount()
		return nil
	case tasklog.FieldReward:
		m.ClearReward()
		return nil
	case tasklog.FieldAmountItem:
		m.ClearAmountItem()
		return nil
	case tasklog.FieldRewardItem:
		m.ClearRewardItem()
		return nil
	case tasklog.FieldTargetAmount:
		m.ClearTargetAmount()
		return nil
	case tasklog.FieldDoneAmount:
		m.ClearDoneAmount()
		return nil
	case tasklog.FieldState:
		m.ClearState()
		return nil
	case tasklog.FieldDoneAt:
		m.ClearDoneAt()
		return nil
	case tasklog.FieldObtainAt:
		m.ClearObtainAt()
		return nil
	case tasklog.FieldDoneTimes:
		m.ClearDoneTimes()
		return nil
	case tasklog.FieldAllTimes:
		m.ClearAllTimes()
		return nil
	}
	return fmt.Errorf("unknown TaskLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskLogMutation) ResetField(name string) error {
	switch name {
	case tasklog.FieldUserId:
		m.ResetUserId()
		return nil
	case tasklog.FieldTaskGroup:
		m.ResetTaskGroup()
		return nil
	case tasklog.FieldTaskCode:
		m.ResetTaskCode()
		return nil
	case tasklog.FieldTaskId:
		m.ResetTaskId()
		return nil
	case tasklog.FieldTaskName:
		m.ResetTaskName()
		return nil
	case tasklog.FieldAmount:
		m.ResetAmount()
		return nil
	case tasklog.FieldReward:
		m.ResetReward()
		return nil
	case tasklog.FieldAmountItem:
		m.ResetAmountItem()
		return nil
	case tasklog.FieldRewardItem:
		m.ResetRewardItem()
		return nil
	case tasklog.FieldTargetAmount:
		m.ResetTargetAmount()
		return nil
	case tasklog.FieldDoneAmount:
		m.ResetDoneAmount()
		return nil
	case tasklog.FieldState:
		m.ResetState()
		return nil
	case tasklog.FieldDoneAt:
		m.ResetDoneAt()
		return nil
	case tasklog.FieldObtainAt:
		m.ResetObtainAt()
		return nil
	case tasklog.FieldDoneTimes:
		m.ResetDoneTimes()
		return nil
	case tasklog.FieldAllTimes:
		m.ResetAllTimes()
		return nil
	case tasklog.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case tasklog.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case tasklog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasklog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tasklog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case tasklog.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case tasklog.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown TaskLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, tasklog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasklog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, tasklog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskLogMutation) EdgeCleared(name string) bool {
	switch name {
	case tasklog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskLogMutation) ClearEdge(name string) error {
	switch name {
	case tasklog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TaskLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskLogMutation) ResetEdge(name string) error {
	switch name {
	case tasklog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TaskLog edge %s", name)
}

// UserEventMutation represents an operation that mutates the UserEvent nodes in the graph.
type UserEventMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	eventType     *string
	novelId       *int64
	addnovelId    *int64
	chapterId     *int64
	addchapterId  *int64
	coin          *int64
	addcoin       *int64
	coupon        *int64
	addcoupon     *int64
	money         *int64
	addmoney      *int64
	keyword       *string
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserEvent, error)
	predicates    []predicate.UserEvent
}

var _ ent.Mutation = (*UserEventMutation)(nil)

// usereventOption allows management of the mutation configuration using functional options.
type usereventOption func(*UserEventMutation)

// newUserEventMutation creates new mutation for the UserEvent entity.
func newUserEventMutation(c config, op Op, opts ...usereventOption) *UserEventMutation {
	m := &UserEventMutation{
		config:        c,
		op:            op,
		typ:           TypeUserEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserEventID sets the ID field of the mutation.
func withUserEventID(id int64) usereventOption {
	return func(m *UserEventMutation) {
		var (
			err   error
			once  sync.Once
			value *UserEvent
		)
		m.oldValue = func(ctx context.Context) (*UserEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserEvent sets the old UserEvent of the mutation.
func withUserEvent(node *UserEvent) usereventOption {
	return func(m *UserEventMutation) {
		m.oldValue = func(context.Context) (*UserEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserEventMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserEventMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *UserEventMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserEventMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserEventMutation) ResetUserId() {
	m.user = nil
}

// SetEventType sets the "eventType" field.
func (m *UserEventMutation) SetEventType(s string) {
	m.eventType = &s
}

// EventType returns the value of the "eventType" field in the mutation.
func (m *UserEventMutation) EventType() (r string, exists bool) {
	v := m.eventType
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "eventType" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ClearEventType clears the value of the "eventType" field.
func (m *UserEventMutation) ClearEventType() {
	m.eventType = nil
	m.clearedFields[userevent.FieldEventType] = struct{}{}
}

// EventTypeCleared returns if the "eventType" field was cleared in this mutation.
func (m *UserEventMutation) EventTypeCleared() bool {
	_, ok := m.clearedFields[userevent.FieldEventType]
	return ok
}

// ResetEventType resets all changes to the "eventType" field.
func (m *UserEventMutation) ResetEventType() {
	m.eventType = nil
	delete(m.clearedFields, userevent.FieldEventType)
}

// SetNovelId sets the "novelId" field.
func (m *UserEventMutation) SetNovelId(i int64) {
	m.novelId = &i
	m.addnovelId = nil
}

// NovelId returns the value of the "novelId" field in the mutation.
func (m *UserEventMutation) NovelId() (r int64, exists bool) {
	v := m.novelId
	if v == nil {
		return
	}
	return *v, true
}

// OldNovelId returns the old "novelId" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldNovelId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNovelId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNovelId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNovelId: %w", err)
	}
	return oldValue.NovelId, nil
}

// AddNovelId adds i to the "novelId" field.
func (m *UserEventMutation) AddNovelId(i int64) {
	if m.addnovelId != nil {
		*m.addnovelId += i
	} else {
		m.addnovelId = &i
	}
}

// AddedNovelId returns the value that was added to the "novelId" field in this mutation.
func (m *UserEventMutation) AddedNovelId() (r int64, exists bool) {
	v := m.addnovelId
	if v == nil {
		return
	}
	return *v, true
}

// ClearNovelId clears the value of the "novelId" field.
func (m *UserEventMutation) ClearNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	m.clearedFields[userevent.FieldNovelId] = struct{}{}
}

// NovelIdCleared returns if the "novelId" field was cleared in this mutation.
func (m *UserEventMutation) NovelIdCleared() bool {
	_, ok := m.clearedFields[userevent.FieldNovelId]
	return ok
}

// ResetNovelId resets all changes to the "novelId" field.
func (m *UserEventMutation) ResetNovelId() {
	m.novelId = nil
	m.addnovelId = nil
	delete(m.clearedFields, userevent.FieldNovelId)
}

// SetChapterId sets the "chapterId" field.
func (m *UserEventMutation) SetChapterId(i int64) {
	m.chapterId = &i
	m.addchapterId = nil
}

// ChapterId returns the value of the "chapterId" field in the mutation.
func (m *UserEventMutation) ChapterId() (r int64, exists bool) {
	v := m.chapterId
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterId returns the old "chapterId" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldChapterId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterId: %w", err)
	}
	return oldValue.ChapterId, nil
}

// AddChapterId adds i to the "chapterId" field.
func (m *UserEventMutation) AddChapterId(i int64) {
	if m.addchapterId != nil {
		*m.addchapterId += i
	} else {
		m.addchapterId = &i
	}
}

// AddedChapterId returns the value that was added to the "chapterId" field in this mutation.
func (m *UserEventMutation) AddedChapterId() (r int64, exists bool) {
	v := m.addchapterId
	if v == nil {
		return
	}
	return *v, true
}

// ClearChapterId clears the value of the "chapterId" field.
func (m *UserEventMutation) ClearChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
	m.clearedFields[userevent.FieldChapterId] = struct{}{}
}

// ChapterIdCleared returns if the "chapterId" field was cleared in this mutation.
func (m *UserEventMutation) ChapterIdCleared() bool {
	_, ok := m.clearedFields[userevent.FieldChapterId]
	return ok
}

// ResetChapterId resets all changes to the "chapterId" field.
func (m *UserEventMutation) ResetChapterId() {
	m.chapterId = nil
	m.addchapterId = nil
	delete(m.clearedFields, userevent.FieldChapterId)
}

// SetCoin sets the "coin" field.
func (m *UserEventMutation) SetCoin(i int64) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *UserEventMutation) Coin() (r int64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldCoin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *UserEventMutation) AddCoin(i int64) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *UserEventMutation) AddedCoin() (r int64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoin clears the value of the "coin" field.
func (m *UserEventMutation) ClearCoin() {
	m.coin = nil
	m.addcoin = nil
	m.clearedFields[userevent.FieldCoin] = struct{}{}
}

// CoinCleared returns if the "coin" field was cleared in this mutation.
func (m *UserEventMutation) CoinCleared() bool {
	_, ok := m.clearedFields[userevent.FieldCoin]
	return ok
}

// ResetCoin resets all changes to the "coin" field.
func (m *UserEventMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
	delete(m.clearedFields, userevent.FieldCoin)
}

// SetCoupon sets the "coupon" field.
func (m *UserEventMutation) SetCoupon(i int64) {
	m.coupon = &i
	m.addcoupon = nil
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *UserEventMutation) Coupon() (r int64, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldCoupon(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// AddCoupon adds i to the "coupon" field.
func (m *UserEventMutation) AddCoupon(i int64) {
	if m.addcoupon != nil {
		*m.addcoupon += i
	} else {
		m.addcoupon = &i
	}
}

// AddedCoupon returns the value that was added to the "coupon" field in this mutation.
func (m *UserEventMutation) AddedCoupon() (r int64, exists bool) {
	v := m.addcoupon
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoupon clears the value of the "coupon" field.
func (m *UserEventMutation) ClearCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	m.clearedFields[userevent.FieldCoupon] = struct{}{}
}

// CouponCleared returns if the "coupon" field was cleared in this mutation.
func (m *UserEventMutation) CouponCleared() bool {
	_, ok := m.clearedFields[userevent.FieldCoupon]
	return ok
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *UserEventMutation) ResetCoupon() {
	m.coupon = nil
	m.addcoupon = nil
	delete(m.clearedFields, userevent.FieldCoupon)
}

// SetMoney sets the "money" field.
func (m *UserEventMutation) SetMoney(i int64) {
	m.money = &i
	m.addmoney = nil
}

// Money returns the value of the "money" field in the mutation.
func (m *UserEventMutation) Money() (r int64, exists bool) {
	v := m.money
	if v == nil {
		return
	}
	return *v, true
}

// OldMoney returns the old "money" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldMoney(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoney is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoney requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoney: %w", err)
	}
	return oldValue.Money, nil
}

// AddMoney adds i to the "money" field.
func (m *UserEventMutation) AddMoney(i int64) {
	if m.addmoney != nil {
		*m.addmoney += i
	} else {
		m.addmoney = &i
	}
}

// AddedMoney returns the value that was added to the "money" field in this mutation.
func (m *UserEventMutation) AddedMoney() (r int64, exists bool) {
	v := m.addmoney
	if v == nil {
		return
	}
	return *v, true
}

// ClearMoney clears the value of the "money" field.
func (m *UserEventMutation) ClearMoney() {
	m.money = nil
	m.addmoney = nil
	m.clearedFields[userevent.FieldMoney] = struct{}{}
}

// MoneyCleared returns if the "money" field was cleared in this mutation.
func (m *UserEventMutation) MoneyCleared() bool {
	_, ok := m.clearedFields[userevent.FieldMoney]
	return ok
}

// ResetMoney resets all changes to the "money" field.
func (m *UserEventMutation) ResetMoney() {
	m.money = nil
	m.addmoney = nil
	delete(m.clearedFields, userevent.FieldMoney)
}

// SetKeyword sets the "keyword" field.
func (m *UserEventMutation) SetKeyword(s string) {
	m.keyword = &s
}

// Keyword returns the value of the "keyword" field in the mutation.
func (m *UserEventMutation) Keyword() (r string, exists bool) {
	v := m.keyword
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyword returns the old "keyword" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldKeyword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyword: %w", err)
	}
	return oldValue.Keyword, nil
}

// ClearKeyword clears the value of the "keyword" field.
func (m *UserEventMutation) ClearKeyword() {
	m.keyword = nil
	m.clearedFields[userevent.FieldKeyword] = struct{}{}
}

// KeywordCleared returns if the "keyword" field was cleared in this mutation.
func (m *UserEventMutation) KeywordCleared() bool {
	_, ok := m.clearedFields[userevent.FieldKeyword]
	return ok
}

// ResetKeyword resets all changes to the "keyword" field.
func (m *UserEventMutation) ResetKeyword() {
	m.keyword = nil
	delete(m.clearedFields, userevent.FieldKeyword)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserEventMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserEventMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserEventMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserEventMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserEventMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserEventMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *UserEventMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *UserEventMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserEventMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserEventMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserEventMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *UserEventMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *UserEventMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserEventMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *UserEventMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *UserEventMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the UserEvent entity.
// If the UserEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserEventMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *UserEventMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *UserEventMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *UserEventMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *UserEventMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *UserEventMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *UserEventMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserEventMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserEventMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserEventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserEventMutation builder.
func (m *UserEventMutation) Where(ps ...predicate.UserEvent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserEventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserEvent).
func (m *UserEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserEventMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, userevent.FieldUserId)
	}
	if m.eventType != nil {
		fields = append(fields, userevent.FieldEventType)
	}
	if m.novelId != nil {
		fields = append(fields, userevent.FieldNovelId)
	}
	if m.chapterId != nil {
		fields = append(fields, userevent.FieldChapterId)
	}
	if m.coin != nil {
		fields = append(fields, userevent.FieldCoin)
	}
	if m.coupon != nil {
		fields = append(fields, userevent.FieldCoupon)
	}
	if m.money != nil {
		fields = append(fields, userevent.FieldMoney)
	}
	if m.keyword != nil {
		fields = append(fields, userevent.FieldKeyword)
	}
	if m.createdAt != nil {
		fields = append(fields, userevent.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userevent.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, userevent.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, userevent.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, userevent.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userevent.FieldUserId:
		return m.UserId()
	case userevent.FieldEventType:
		return m.EventType()
	case userevent.FieldNovelId:
		return m.NovelId()
	case userevent.FieldChapterId:
		return m.ChapterId()
	case userevent.FieldCoin:
		return m.Coin()
	case userevent.FieldCoupon:
		return m.Coupon()
	case userevent.FieldMoney:
		return m.Money()
	case userevent.FieldKeyword:
		return m.Keyword()
	case userevent.FieldCreatedAt:
		return m.CreatedAt()
	case userevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case userevent.FieldCreateBy:
		return m.CreateBy()
	case userevent.FieldUpdateBy:
		return m.UpdateBy()
	case userevent.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userevent.FieldUserId:
		return m.OldUserId(ctx)
	case userevent.FieldEventType:
		return m.OldEventType(ctx)
	case userevent.FieldNovelId:
		return m.OldNovelId(ctx)
	case userevent.FieldChapterId:
		return m.OldChapterId(ctx)
	case userevent.FieldCoin:
		return m.OldCoin(ctx)
	case userevent.FieldCoupon:
		return m.OldCoupon(ctx)
	case userevent.FieldMoney:
		return m.OldMoney(ctx)
	case userevent.FieldKeyword:
		return m.OldKeyword(ctx)
	case userevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userevent.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case userevent.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case userevent.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown UserEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userevent.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case userevent.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNovelId(v)
		return nil
	case userevent.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterId(v)
		return nil
	case userevent.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case userevent.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case userevent.FieldMoney:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoney(v)
		return nil
	case userevent.FieldKeyword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyword(v)
		return nil
	case userevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userevent.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case userevent.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case userevent.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserEventMutation) AddedFields() []string {
	var fields []string
	if m.addnovelId != nil {
		fields = append(fields, userevent.FieldNovelId)
	}
	if m.addchapterId != nil {
		fields = append(fields, userevent.FieldChapterId)
	}
	if m.addcoin != nil {
		fields = append(fields, userevent.FieldCoin)
	}
	if m.addcoupon != nil {
		fields = append(fields, userevent.FieldCoupon)
	}
	if m.addmoney != nil {
		fields = append(fields, userevent.FieldMoney)
	}
	if m.addcreateBy != nil {
		fields = append(fields, userevent.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, userevent.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, userevent.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userevent.FieldNovelId:
		return m.AddedNovelId()
	case userevent.FieldChapterId:
		return m.AddedChapterId()
	case userevent.FieldCoin:
		return m.AddedCoin()
	case userevent.FieldCoupon:
		return m.AddedCoupon()
	case userevent.FieldMoney:
		return m.AddedMoney()
	case userevent.FieldCreateBy:
		return m.AddedCreateBy()
	case userevent.FieldUpdateBy:
		return m.AddedUpdateBy()
	case userevent.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userevent.FieldNovelId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNovelId(v)
		return nil
	case userevent.FieldChapterId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChapterId(v)
		return nil
	case userevent.FieldCoin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case userevent.FieldCoupon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoupon(v)
		return nil
	case userevent.FieldMoney:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoney(v)
		return nil
	case userevent.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case userevent.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case userevent.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userevent.FieldEventType) {
		fields = append(fields, userevent.FieldEventType)
	}
	if m.FieldCleared(userevent.FieldNovelId) {
		fields = append(fields, userevent.FieldNovelId)
	}
	if m.FieldCleared(userevent.FieldChapterId) {
		fields = append(fields, userevent.FieldChapterId)
	}
	if m.FieldCleared(userevent.FieldCoin) {
		fields = append(fields, userevent.FieldCoin)
	}
	if m.FieldCleared(userevent.FieldCoupon) {
		fields = append(fields, userevent.FieldCoupon)
	}
	if m.FieldCleared(userevent.FieldMoney) {
		fields = append(fields, userevent.FieldMoney)
	}
	if m.FieldCleared(userevent.FieldKeyword) {
		fields = append(fields, userevent.FieldKeyword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserEventMutation) ClearField(name string) error {
	switch name {
	case userevent.FieldEventType:
		m.ClearEventType()
		return nil
	case userevent.FieldNovelId:
		m.ClearNovelId()
		return nil
	case userevent.FieldChapterId:
		m.ClearChapterId()
		return nil
	case userevent.FieldCoin:
		m.ClearCoin()
		return nil
	case userevent.FieldCoupon:
		m.ClearCoupon()
		return nil
	case userevent.FieldMoney:
		m.ClearMoney()
		return nil
	case userevent.FieldKeyword:
		m.ClearKeyword()
		return nil
	}
	return fmt.Errorf("unknown UserEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserEventMutation) ResetField(name string) error {
	switch name {
	case userevent.FieldUserId:
		m.ResetUserId()
		return nil
	case userevent.FieldEventType:
		m.ResetEventType()
		return nil
	case userevent.FieldNovelId:
		m.ResetNovelId()
		return nil
	case userevent.FieldChapterId:
		m.ResetChapterId()
		return nil
	case userevent.FieldCoin:
		m.ResetCoin()
		return nil
	case userevent.FieldCoupon:
		m.ResetCoupon()
		return nil
	case userevent.FieldMoney:
		m.ResetMoney()
		return nil
	case userevent.FieldKeyword:
		m.ResetKeyword()
		return nil
	case userevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userevent.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case userevent.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case userevent.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown UserEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userevent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userevent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userevent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserEventMutation) EdgeCleared(name string) bool {
	switch name {
	case userevent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserEventMutation) ClearEdge(name string) error {
	switch name {
	case userevent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserEventMutation) ResetEdge(name string) error {
	switch name {
	case userevent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserEvent edge %s", name)
}

// UserMsgMutation represents an operation that mutates the UserMsg nodes in the graph.
type UserMsgMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	msgId         *int64
	addmsgId      *int64
	isRead        *bool
	createdAt     *time.Time
	updatedAt     *time.Time
	createBy      *int64
	addcreateBy   *int64
	updateBy      *int64
	addupdateBy   *int64
	tenantId      *int64
	addtenantId   *int64
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserMsg, error)
	predicates    []predicate.UserMsg
}

var _ ent.Mutation = (*UserMsgMutation)(nil)

// usermsgOption allows management of the mutation configuration using functional options.
type usermsgOption func(*UserMsgMutation)

// newUserMsgMutation creates new mutation for the UserMsg entity.
func newUserMsgMutation(c config, op Op, opts ...usermsgOption) *UserMsgMutation {
	m := &UserMsgMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMsg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserMsgID sets the ID field of the mutation.
func withUserMsgID(id int64) usermsgOption {
	return func(m *UserMsgMutation) {
		var (
			err   error
			once  sync.Once
			value *UserMsg
		)
		m.oldValue = func(ctx context.Context) (*UserMsg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserMsg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserMsg sets the old UserMsg of the mutation.
func withUserMsg(node *UserMsg) usermsgOption {
	return func(m *UserMsgMutation) {
		m.oldValue = func(context.Context) (*UserMsg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMsgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMsgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMsgMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMsgMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserMsg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *UserMsgMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserMsgMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserMsgMutation) ResetUserId() {
	m.user = nil
}

// SetMsgId sets the "msgId" field.
func (m *UserMsgMutation) SetMsgId(i int64) {
	m.msgId = &i
	m.addmsgId = nil
}

// MsgId returns the value of the "msgId" field in the mutation.
func (m *UserMsgMutation) MsgId() (r int64, exists bool) {
	v := m.msgId
	if v == nil {
		return
	}
	return *v, true
}

// OldMsgId returns the old "msgId" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldMsgId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsgId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsgId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsgId: %w", err)
	}
	return oldValue.MsgId, nil
}

// AddMsgId adds i to the "msgId" field.
func (m *UserMsgMutation) AddMsgId(i int64) {
	if m.addmsgId != nil {
		*m.addmsgId += i
	} else {
		m.addmsgId = &i
	}
}

// AddedMsgId returns the value that was added to the "msgId" field in this mutation.
func (m *UserMsgMutation) AddedMsgId() (r int64, exists bool) {
	v := m.addmsgId
	if v == nil {
		return
	}
	return *v, true
}

// ClearMsgId clears the value of the "msgId" field.
func (m *UserMsgMutation) ClearMsgId() {
	m.msgId = nil
	m.addmsgId = nil
	m.clearedFields[usermsg.FieldMsgId] = struct{}{}
}

// MsgIdCleared returns if the "msgId" field was cleared in this mutation.
func (m *UserMsgMutation) MsgIdCleared() bool {
	_, ok := m.clearedFields[usermsg.FieldMsgId]
	return ok
}

// ResetMsgId resets all changes to the "msgId" field.
func (m *UserMsgMutation) ResetMsgId() {
	m.msgId = nil
	m.addmsgId = nil
	delete(m.clearedFields, usermsg.FieldMsgId)
}

// SetIsRead sets the "isRead" field.
func (m *UserMsgMutation) SetIsRead(b bool) {
	m.isRead = &b
}

// IsRead returns the value of the "isRead" field in the mutation.
func (m *UserMsgMutation) IsRead() (r bool, exists bool) {
	v := m.isRead
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "isRead" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ClearIsRead clears the value of the "isRead" field.
func (m *UserMsgMutation) ClearIsRead() {
	m.isRead = nil
	m.clearedFields[usermsg.FieldIsRead] = struct{}{}
}

// IsReadCleared returns if the "isRead" field was cleared in this mutation.
func (m *UserMsgMutation) IsReadCleared() bool {
	_, ok := m.clearedFields[usermsg.FieldIsRead]
	return ok
}

// ResetIsRead resets all changes to the "isRead" field.
func (m *UserMsgMutation) ResetIsRead() {
	m.isRead = nil
	delete(m.clearedFields, usermsg.FieldIsRead)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMsgMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMsgMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMsgMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMsgMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMsgMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMsgMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserMsgMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserMsgMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *UserMsgMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *UserMsgMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserMsgMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserMsgMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserMsgMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *UserMsgMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *UserMsgMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserMsgMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *UserMsgMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *UserMsgMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the UserMsg entity.
// If the UserMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMsgMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *UserMsgMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *UserMsgMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *UserMsgMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *UserMsgMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *UserMsgMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *UserMsgMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserMsgMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserMsgMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserMsgMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserMsgMutation builder.
func (m *UserMsgMutation) Where(ps ...predicate.UserMsg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMsgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserMsg).
func (m *UserMsgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMsgMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user != nil {
		fields = append(fields, usermsg.FieldUserId)
	}
	if m.msgId != nil {
		fields = append(fields, usermsg.FieldMsgId)
	}
	if m.isRead != nil {
		fields = append(fields, usermsg.FieldIsRead)
	}
	if m.createdAt != nil {
		fields = append(fields, usermsg.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, usermsg.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, usermsg.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, usermsg.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, usermsg.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMsgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermsg.FieldUserId:
		return m.UserId()
	case usermsg.FieldMsgId:
		return m.MsgId()
	case usermsg.FieldIsRead:
		return m.IsRead()
	case usermsg.FieldCreatedAt:
		return m.CreatedAt()
	case usermsg.FieldUpdatedAt:
		return m.UpdatedAt()
	case usermsg.FieldCreateBy:
		return m.CreateBy()
	case usermsg.FieldUpdateBy:
		return m.UpdateBy()
	case usermsg.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMsgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermsg.FieldUserId:
		return m.OldUserId(ctx)
	case usermsg.FieldMsgId:
		return m.OldMsgId(ctx)
	case usermsg.FieldIsRead:
		return m.OldIsRead(ctx)
	case usermsg.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usermsg.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usermsg.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case usermsg.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case usermsg.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown UserMsg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMsgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermsg.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usermsg.FieldMsgId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsgId(v)
		return nil
	case usermsg.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	case usermsg.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usermsg.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usermsg.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case usermsg.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case usermsg.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserMsg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMsgMutation) AddedFields() []string {
	var fields []string
	if m.addmsgId != nil {
		fields = append(fields, usermsg.FieldMsgId)
	}
	if m.addcreateBy != nil {
		fields = append(fields, usermsg.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, usermsg.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, usermsg.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMsgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usermsg.FieldMsgId:
		return m.AddedMsgId()
	case usermsg.FieldCreateBy:
		return m.AddedCreateBy()
	case usermsg.FieldUpdateBy:
		return m.AddedUpdateBy()
	case usermsg.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMsgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usermsg.FieldMsgId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMsgId(v)
		return nil
	case usermsg.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case usermsg.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case usermsg.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown UserMsg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMsgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usermsg.FieldMsgId) {
		fields = append(fields, usermsg.FieldMsgId)
	}
	if m.FieldCleared(usermsg.FieldIsRead) {
		fields = append(fields, usermsg.FieldIsRead)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMsgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMsgMutation) ClearField(name string) error {
	switch name {
	case usermsg.FieldMsgId:
		m.ClearMsgId()
		return nil
	case usermsg.FieldIsRead:
		m.ClearIsRead()
		return nil
	}
	return fmt.Errorf("unknown UserMsg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMsgMutation) ResetField(name string) error {
	switch name {
	case usermsg.FieldUserId:
		m.ResetUserId()
		return nil
	case usermsg.FieldMsgId:
		m.ResetMsgId()
		return nil
	case usermsg.FieldIsRead:
		m.ResetIsRead()
		return nil
	case usermsg.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usermsg.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usermsg.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case usermsg.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case usermsg.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown UserMsg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMsgMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usermsg.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMsgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermsg.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMsgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMsgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMsgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usermsg.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMsgMutation) EdgeCleared(name string) bool {
	switch name {
	case usermsg.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMsgMutation) ClearEdge(name string) error {
	switch name {
	case usermsg.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserMsg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMsgMutation) ResetEdge(name string) error {
	switch name {
	case usermsg.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserMsg edge %s", name)
}

// VipUserMutation represents an operation that mutates the VipUser nodes in the graph.
type VipUserMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	vipType         *int64
	addvipType      *int64
	svipType        *int64
	addsvipType     *int64
	svipEffectTime  *time.Time
	svipExpiredTime *time.Time
	remark          *string
	effectTime      *time.Time
	expiredTime     *time.Time
	createdAt       *time.Time
	updatedAt       *time.Time
	createBy        *int64
	addcreateBy     *int64
	updateBy        *int64
	addupdateBy     *int64
	tenantId        *int64
	addtenantId     *int64
	clearedFields   map[string]struct{}
	user            *int64
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*VipUser, error)
	predicates      []predicate.VipUser
}

var _ ent.Mutation = (*VipUserMutation)(nil)

// vipuserOption allows management of the mutation configuration using functional options.
type vipuserOption func(*VipUserMutation)

// newVipUserMutation creates new mutation for the VipUser entity.
func newVipUserMutation(c config, op Op, opts ...vipuserOption) *VipUserMutation {
	m := &VipUserMutation{
		config:        c,
		op:            op,
		typ:           TypeVipUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVipUserID sets the ID field of the mutation.
func withVipUserID(id int64) vipuserOption {
	return func(m *VipUserMutation) {
		var (
			err   error
			once  sync.Once
			value *VipUser
		)
		m.oldValue = func(ctx context.Context) (*VipUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VipUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVipUser sets the old VipUser of the mutation.
func withVipUser(node *VipUser) vipuserOption {
	return func(m *VipUserMutation) {
		m.oldValue = func(context.Context) (*VipUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VipUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VipUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VipUserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VipUserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VipUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *VipUserMutation) SetUserId(i int64) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *VipUserMutation) UserId() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *VipUserMutation) ResetUserId() {
	m.user = nil
}

// SetVipType sets the "vipType" field.
func (m *VipUserMutation) SetVipType(i int64) {
	m.vipType = &i
	m.addvipType = nil
}

// VipType returns the value of the "vipType" field in the mutation.
func (m *VipUserMutation) VipType() (r int64, exists bool) {
	v := m.vipType
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vipType" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldVipType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vipType" field.
func (m *VipUserMutation) AddVipType(i int64) {
	if m.addvipType != nil {
		*m.addvipType += i
	} else {
		m.addvipType = &i
	}
}

// AddedVipType returns the value that was added to the "vipType" field in this mutation.
func (m *VipUserMutation) AddedVipType() (r int64, exists bool) {
	v := m.addvipType
	if v == nil {
		return
	}
	return *v, true
}

// ClearVipType clears the value of the "vipType" field.
func (m *VipUserMutation) ClearVipType() {
	m.vipType = nil
	m.addvipType = nil
	m.clearedFields[vipuser.FieldVipType] = struct{}{}
}

// VipTypeCleared returns if the "vipType" field was cleared in this mutation.
func (m *VipUserMutation) VipTypeCleared() bool {
	_, ok := m.clearedFields[vipuser.FieldVipType]
	return ok
}

// ResetVipType resets all changes to the "vipType" field.
func (m *VipUserMutation) ResetVipType() {
	m.vipType = nil
	m.addvipType = nil
	delete(m.clearedFields, vipuser.FieldVipType)
}

// SetSvipType sets the "svipType" field.
func (m *VipUserMutation) SetSvipType(i int64) {
	m.svipType = &i
	m.addsvipType = nil
}

// SvipType returns the value of the "svipType" field in the mutation.
func (m *VipUserMutation) SvipType() (r int64, exists bool) {
	v := m.svipType
	if v == nil {
		return
	}
	return *v, true
}

// OldSvipType returns the old "svipType" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldSvipType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvipType: %w", err)
	}
	return oldValue.SvipType, nil
}

// AddSvipType adds i to the "svipType" field.
func (m *VipUserMutation) AddSvipType(i int64) {
	if m.addsvipType != nil {
		*m.addsvipType += i
	} else {
		m.addsvipType = &i
	}
}

// AddedSvipType returns the value that was added to the "svipType" field in this mutation.
func (m *VipUserMutation) AddedSvipType() (r int64, exists bool) {
	v := m.addsvipType
	if v == nil {
		return
	}
	return *v, true
}

// ClearSvipType clears the value of the "svipType" field.
func (m *VipUserMutation) ClearSvipType() {
	m.svipType = nil
	m.addsvipType = nil
	m.clearedFields[vipuser.FieldSvipType] = struct{}{}
}

// SvipTypeCleared returns if the "svipType" field was cleared in this mutation.
func (m *VipUserMutation) SvipTypeCleared() bool {
	_, ok := m.clearedFields[vipuser.FieldSvipType]
	return ok
}

// ResetSvipType resets all changes to the "svipType" field.
func (m *VipUserMutation) ResetSvipType() {
	m.svipType = nil
	m.addsvipType = nil
	delete(m.clearedFields, vipuser.FieldSvipType)
}

// SetSvipEffectTime sets the "svipEffectTime" field.
func (m *VipUserMutation) SetSvipEffectTime(t time.Time) {
	m.svipEffectTime = &t
}

// SvipEffectTime returns the value of the "svipEffectTime" field in the mutation.
func (m *VipUserMutation) SvipEffectTime() (r time.Time, exists bool) {
	v := m.svipEffectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldSvipEffectTime returns the old "svipEffectTime" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldSvipEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvipEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvipEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvipEffectTime: %w", err)
	}
	return oldValue.SvipEffectTime, nil
}

// ClearSvipEffectTime clears the value of the "svipEffectTime" field.
func (m *VipUserMutation) ClearSvipEffectTime() {
	m.svipEffectTime = nil
	m.clearedFields[vipuser.FieldSvipEffectTime] = struct{}{}
}

// SvipEffectTimeCleared returns if the "svipEffectTime" field was cleared in this mutation.
func (m *VipUserMutation) SvipEffectTimeCleared() bool {
	_, ok := m.clearedFields[vipuser.FieldSvipEffectTime]
	return ok
}

// ResetSvipEffectTime resets all changes to the "svipEffectTime" field.
func (m *VipUserMutation) ResetSvipEffectTime() {
	m.svipEffectTime = nil
	delete(m.clearedFields, vipuser.FieldSvipEffectTime)
}

// SetSvipExpiredTime sets the "svipExpiredTime" field.
func (m *VipUserMutation) SetSvipExpiredTime(t time.Time) {
	m.svipExpiredTime = &t
}

// SvipExpiredTime returns the value of the "svipExpiredTime" field in the mutation.
func (m *VipUserMutation) SvipExpiredTime() (r time.Time, exists bool) {
	v := m.svipExpiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldSvipExpiredTime returns the old "svipExpiredTime" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldSvipExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvipExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvipExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvipExpiredTime: %w", err)
	}
	return oldValue.SvipExpiredTime, nil
}

// ClearSvipExpiredTime clears the value of the "svipExpiredTime" field.
func (m *VipUserMutation) ClearSvipExpiredTime() {
	m.svipExpiredTime = nil
	m.clearedFields[vipuser.FieldSvipExpiredTime] = struct{}{}
}

// SvipExpiredTimeCleared returns if the "svipExpiredTime" field was cleared in this mutation.
func (m *VipUserMutation) SvipExpiredTimeCleared() bool {
	_, ok := m.clearedFields[vipuser.FieldSvipExpiredTime]
	return ok
}

// ResetSvipExpiredTime resets all changes to the "svipExpiredTime" field.
func (m *VipUserMutation) ResetSvipExpiredTime() {
	m.svipExpiredTime = nil
	delete(m.clearedFields, vipuser.FieldSvipExpiredTime)
}

// SetRemark sets the "remark" field.
func (m *VipUserMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *VipUserMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *VipUserMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[vipuser.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *VipUserMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[vipuser.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *VipUserMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, vipuser.FieldRemark)
}

// SetEffectTime sets the "effectTime" field.
func (m *VipUserMutation) SetEffectTime(t time.Time) {
	m.effectTime = &t
}

// EffectTime returns the value of the "effectTime" field in the mutation.
func (m *VipUserMutation) EffectTime() (r time.Time, exists bool) {
	v := m.effectTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectTime returns the old "effectTime" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldEffectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectTime: %w", err)
	}
	return oldValue.EffectTime, nil
}

// ResetEffectTime resets all changes to the "effectTime" field.
func (m *VipUserMutation) ResetEffectTime() {
	m.effectTime = nil
}

// SetExpiredTime sets the "expiredTime" field.
func (m *VipUserMutation) SetExpiredTime(t time.Time) {
	m.expiredTime = &t
}

// ExpiredTime returns the value of the "expiredTime" field in the mutation.
func (m *VipUserMutation) ExpiredTime() (r time.Time, exists bool) {
	v := m.expiredTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expiredTime" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldExpiredTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// ResetExpiredTime resets all changes to the "expiredTime" field.
func (m *VipUserMutation) ResetExpiredTime() {
	m.expiredTime = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *VipUserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *VipUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *VipUserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *VipUserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *VipUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *VipUserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreateBy sets the "createBy" field.
func (m *VipUserMutation) SetCreateBy(i int64) {
	m.createBy = &i
	m.addcreateBy = nil
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *VipUserMutation) CreateBy() (r int64, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds i to the "createBy" field.
func (m *VipUserMutation) AddCreateBy(i int64) {
	if m.addcreateBy != nil {
		*m.addcreateBy += i
	} else {
		m.addcreateBy = &i
	}
}

// AddedCreateBy returns the value that was added to the "createBy" field in this mutation.
func (m *VipUserMutation) AddedCreateBy() (r int64, exists bool) {
	v := m.addcreateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *VipUserMutation) ResetCreateBy() {
	m.createBy = nil
	m.addcreateBy = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *VipUserMutation) SetUpdateBy(i int64) {
	m.updateBy = &i
	m.addupdateBy = nil
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *VipUserMutation) UpdateBy() (r int64, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldUpdateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds i to the "updateBy" field.
func (m *VipUserMutation) AddUpdateBy(i int64) {
	if m.addupdateBy != nil {
		*m.addupdateBy += i
	} else {
		m.addupdateBy = &i
	}
}

// AddedUpdateBy returns the value that was added to the "updateBy" field in this mutation.
func (m *VipUserMutation) AddedUpdateBy() (r int64, exists bool) {
	v := m.addupdateBy
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *VipUserMutation) ResetUpdateBy() {
	m.updateBy = nil
	m.addupdateBy = nil
}

// SetTenantId sets the "tenantId" field.
func (m *VipUserMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the value of the "tenantId" field in the mutation.
func (m *VipUserMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old "tenantId" field's value of the VipUser entity.
// If the VipUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipUserMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to the "tenantId" field.
func (m *VipUserMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the "tenantId" field in this mutation.
func (m *VipUserMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId resets all changes to the "tenantId" field.
func (m *VipUserMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetUserID sets the "user" edge to the SocialUser entity by id.
func (m *VipUserMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the SocialUser entity.
func (m *VipUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the SocialUser entity was cleared.
func (m *VipUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VipUserMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VipUserMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VipUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VipUserMutation builder.
func (m *VipUserMutation) Where(ps ...predicate.VipUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VipUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VipUser).
func (m *VipUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VipUserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, vipuser.FieldUserId)
	}
	if m.vipType != nil {
		fields = append(fields, vipuser.FieldVipType)
	}
	if m.svipType != nil {
		fields = append(fields, vipuser.FieldSvipType)
	}
	if m.svipEffectTime != nil {
		fields = append(fields, vipuser.FieldSvipEffectTime)
	}
	if m.svipExpiredTime != nil {
		fields = append(fields, vipuser.FieldSvipExpiredTime)
	}
	if m.remark != nil {
		fields = append(fields, vipuser.FieldRemark)
	}
	if m.effectTime != nil {
		fields = append(fields, vipuser.FieldEffectTime)
	}
	if m.expiredTime != nil {
		fields = append(fields, vipuser.FieldExpiredTime)
	}
	if m.createdAt != nil {
		fields = append(fields, vipuser.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, vipuser.FieldUpdatedAt)
	}
	if m.createBy != nil {
		fields = append(fields, vipuser.FieldCreateBy)
	}
	if m.updateBy != nil {
		fields = append(fields, vipuser.FieldUpdateBy)
	}
	if m.tenantId != nil {
		fields = append(fields, vipuser.FieldTenantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VipUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vipuser.FieldUserId:
		return m.UserId()
	case vipuser.FieldVipType:
		return m.VipType()
	case vipuser.FieldSvipType:
		return m.SvipType()
	case vipuser.FieldSvipEffectTime:
		return m.SvipEffectTime()
	case vipuser.FieldSvipExpiredTime:
		return m.SvipExpiredTime()
	case vipuser.FieldRemark:
		return m.Remark()
	case vipuser.FieldEffectTime:
		return m.EffectTime()
	case vipuser.FieldExpiredTime:
		return m.ExpiredTime()
	case vipuser.FieldCreatedAt:
		return m.CreatedAt()
	case vipuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case vipuser.FieldCreateBy:
		return m.CreateBy()
	case vipuser.FieldUpdateBy:
		return m.UpdateBy()
	case vipuser.FieldTenantId:
		return m.TenantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VipUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vipuser.FieldUserId:
		return m.OldUserId(ctx)
	case vipuser.FieldVipType:
		return m.OldVipType(ctx)
	case vipuser.FieldSvipType:
		return m.OldSvipType(ctx)
	case vipuser.FieldSvipEffectTime:
		return m.OldSvipEffectTime(ctx)
	case vipuser.FieldSvipExpiredTime:
		return m.OldSvipExpiredTime(ctx)
	case vipuser.FieldRemark:
		return m.OldRemark(ctx)
	case vipuser.FieldEffectTime:
		return m.OldEffectTime(ctx)
	case vipuser.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case vipuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vipuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vipuser.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case vipuser.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case vipuser.FieldTenantId:
		return m.OldTenantId(ctx)
	}
	return nil, fmt.Errorf("unknown VipUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vipuser.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case vipuser.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case vipuser.FieldSvipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvipType(v)
		return nil
	case vipuser.FieldSvipEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvipEffectTime(v)
		return nil
	case vipuser.FieldSvipExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvipExpiredTime(v)
		return nil
	case vipuser.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case vipuser.FieldEffectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectTime(v)
		return nil
	case vipuser.FieldExpiredTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case vipuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vipuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vipuser.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case vipuser.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case vipuser.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown VipUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VipUserMutation) AddedFields() []string {
	var fields []string
	if m.addvipType != nil {
		fields = append(fields, vipuser.FieldVipType)
	}
	if m.addsvipType != nil {
		fields = append(fields, vipuser.FieldSvipType)
	}
	if m.addcreateBy != nil {
		fields = append(fields, vipuser.FieldCreateBy)
	}
	if m.addupdateBy != nil {
		fields = append(fields, vipuser.FieldUpdateBy)
	}
	if m.addtenantId != nil {
		fields = append(fields, vipuser.FieldTenantId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VipUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vipuser.FieldVipType:
		return m.AddedVipType()
	case vipuser.FieldSvipType:
		return m.AddedSvipType()
	case vipuser.FieldCreateBy:
		return m.AddedCreateBy()
	case vipuser.FieldUpdateBy:
		return m.AddedUpdateBy()
	case vipuser.FieldTenantId:
		return m.AddedTenantId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vipuser.FieldVipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	case vipuser.FieldSvipType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSvipType(v)
		return nil
	case vipuser.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case vipuser.FieldUpdateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case vipuser.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	}
	return fmt.Errorf("unknown VipUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VipUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vipuser.FieldVipType) {
		fields = append(fields, vipuser.FieldVipType)
	}
	if m.FieldCleared(vipuser.FieldSvipType) {
		fields = append(fields, vipuser.FieldSvipType)
	}
	if m.FieldCleared(vipuser.FieldSvipEffectTime) {
		fields = append(fields, vipuser.FieldSvipEffectTime)
	}
	if m.FieldCleared(vipuser.FieldSvipExpiredTime) {
		fields = append(fields, vipuser.FieldSvipExpiredTime)
	}
	if m.FieldCleared(vipuser.FieldRemark) {
		fields = append(fields, vipuser.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VipUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VipUserMutation) ClearField(name string) error {
	switch name {
	case vipuser.FieldVipType:
		m.ClearVipType()
		return nil
	case vipuser.FieldSvipType:
		m.ClearSvipType()
		return nil
	case vipuser.FieldSvipEffectTime:
		m.ClearSvipEffectTime()
		return nil
	case vipuser.FieldSvipExpiredTime:
		m.ClearSvipExpiredTime()
		return nil
	case vipuser.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown VipUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VipUserMutation) ResetField(name string) error {
	switch name {
	case vipuser.FieldUserId:
		m.ResetUserId()
		return nil
	case vipuser.FieldVipType:
		m.ResetVipType()
		return nil
	case vipuser.FieldSvipType:
		m.ResetSvipType()
		return nil
	case vipuser.FieldSvipEffectTime:
		m.ResetSvipEffectTime()
		return nil
	case vipuser.FieldSvipExpiredTime:
		m.ResetSvipExpiredTime()
		return nil
	case vipuser.FieldRemark:
		m.ResetRemark()
		return nil
	case vipuser.FieldEffectTime:
		m.ResetEffectTime()
		return nil
	case vipuser.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case vipuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vipuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vipuser.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case vipuser.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case vipuser.FieldTenantId:
		m.ResetTenantId()
		return nil
	}
	return fmt.Errorf("unknown VipUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VipUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, vipuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VipUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vipuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VipUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VipUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VipUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, vipuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VipUserMutation) EdgeCleared(name string) bool {
	switch name {
	case vipuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VipUserMutation) ClearEdge(name string) error {
	switch name {
	case vipuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VipUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VipUserMutation) ResetEdge(name string) error {
	switch name {
	case vipuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown VipUser edge %s", name)
}
