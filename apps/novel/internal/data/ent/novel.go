// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"hope/apps/novel/internal/data/ent/novel"
	"hope/apps/novel/internal/data/ent/novelclassify"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// Novel is the model entity for the Novel schema.
type Novel struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// ClassifyId holds the value of the "classifyId" field.
	// 分类ID
	ClassifyId int64 `json:"classifyId,omitempty"`
	// ClassifyName holds the value of the "classifyName" field.
	// 分类名称
	ClassifyName string `json:"classifyName,omitempty"`
	// AuthorId holds the value of the "authorId" field.
	// 作者ID,本站小说有
	AuthorId string `json:"authorId,omitempty"`
	// Title holds the value of the "title" field.
	// 小说标题
	Title string `json:"title,omitempty"`
	// Summary holds the value of the "summary" field.
	// 小说摘要
	Summary string `json:"summary,omitempty"`
	// Author holds the value of the "author" field.
	// 作者
	Author string `json:"author,omitempty"`
	// Anchor holds the value of the "anchor" field.
	// 主播
	Anchor string `json:"anchor,omitempty"`
	// Hits holds the value of the "hits" field.
	// 点击量
	Hits int64 `json:"hits,omitempty"`
	// Keywords holds the value of the "keywords" field.
	// 关键字，用逗号隔开
	Keywords string `json:"keywords,omitempty"`
	// Source holds the value of the "source" field.
	// 来源
	Source string `json:"source,omitempty"`
	// Score holds the value of the "score" field.
	// 评分
	Score int32 `json:"score,omitempty"`
	// Cover holds the value of the "cover" field.
	// 封面
	Cover string `json:"cover,omitempty"`
	// TagIds holds the value of the "tagIds" field.
	// 标签,关联标签表novel_tag
	TagIds string `json:"tagIds,omitempty"`
	// WordNum holds the value of the "wordNum" field.
	// 书本字数
	WordNum int32 `json:"wordNum,omitempty"`
	// FreeNum holds the value of the "freeNum" field.
	// 免费章节数量
	FreeNum int32 `json:"freeNum,omitempty"`
	// OnlineState holds the value of the "onlineState" field.
	// 连载状态
	OnlineState int32 `json:"onlineState,omitempty"`
	// Price holds the value of the "price" field.
	// 整本价格
	Price int64 `json:"price,omitempty"`
	// Publish holds the value of the "publish" field.
	// 发布状态
	Publish int32 `json:"publish,omitempty"`
	// OriginalPrice holds the value of the "originalPrice" field.
	// 原价,展示用
	OriginalPrice int64 `json:"originalPrice,omitempty"`
	// ChapterPrice holds the value of the "chapterPrice" field.
	// 千字价格
	ChapterPrice int32 `json:"chapterPrice,omitempty"`
	// ChapterCount holds the value of the "chapterCount" field.
	// 章节数量
	ChapterCount int32 `json:"chapterCount,omitempty"`
	// SignType holds the value of the "signType" field.
	// 签约类型 0
	SignType int32 `json:"signType,omitempty"`
	// SignDate holds the value of the "signDate" field.
	// 签约时间
	SignDate time.Time `json:"signDate,omitempty"`
	// LeadingMan holds the value of the "leadingMan" field.
	// 男主角
	LeadingMan string `json:"leadingMan,omitempty"`
	// LeadingLady holds the value of the "leadingLady" field.
	// 女主角
	LeadingLady string `json:"leadingLady,omitempty"`
	// Remark holds the value of the "remark" field.
	// 备注
	Remark string `json:"remark,omitempty"`
	// MediaKey holds the value of the "mediaKey" field.
	// 阿里云音频目录
	MediaKey string `json:"mediaKey,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	// 创建时间
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	// 更新时间
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
	// CreateBy holds the value of the "createBy" field.
	// 创建者
	CreateBy int64 `json:"createBy,omitempty"`
	// UpdateBy holds the value of the "updateBy" field.
	// 更新者
	UpdateBy int64 `json:"updateBy,omitempty"`
	// TenantId holds the value of the "tenantId" field.
	// 租户
	TenantId int64 `json:"tenantId,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the NovelQuery when eager-loading is set.
	Edges NovelEdges `json:"edges"`
}

// NovelEdges holds the relations/edges for other nodes in the graph.
type NovelEdges struct {
	// Chapters holds the value of the chapters edge.
	Chapters []*NovelChapter `json:"chapters,omitempty"`
	// Pkgs holds the value of the pkgs edge.
	Pkgs []*BookPackage `json:"pkgs,omitempty"`
	// Classify holds the value of the classify edge.
	Classify *NovelClassify `json:"classify,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// ChaptersOrErr returns the Chapters value or an error if the edge
// was not loaded in eager-loading.
func (e NovelEdges) ChaptersOrErr() ([]*NovelChapter, error) {
	if e.loadedTypes[0] {
		return e.Chapters, nil
	}
	return nil, &NotLoadedError{edge: "chapters"}
}

// PkgsOrErr returns the Pkgs value or an error if the edge
// was not loaded in eager-loading.
func (e NovelEdges) PkgsOrErr() ([]*BookPackage, error) {
	if e.loadedTypes[1] {
		return e.Pkgs, nil
	}
	return nil, &NotLoadedError{edge: "pkgs"}
}

// ClassifyOrErr returns the Classify value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NovelEdges) ClassifyOrErr() (*NovelClassify, error) {
	if e.loadedTypes[2] {
		if e.Classify == nil {
			// The edge classify was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: novelclassify.Label}
		}
		return e.Classify, nil
	}
	return nil, &NotLoadedError{edge: "classify"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Novel) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case novel.FieldID, novel.FieldClassifyId, novel.FieldHits, novel.FieldScore, novel.FieldWordNum, novel.FieldFreeNum, novel.FieldOnlineState, novel.FieldPrice, novel.FieldPublish, novel.FieldOriginalPrice, novel.FieldChapterPrice, novel.FieldChapterCount, novel.FieldSignType, novel.FieldCreateBy, novel.FieldUpdateBy, novel.FieldTenantId:
			values[i] = new(sql.NullInt64)
		case novel.FieldClassifyName, novel.FieldAuthorId, novel.FieldTitle, novel.FieldSummary, novel.FieldAuthor, novel.FieldAnchor, novel.FieldKeywords, novel.FieldSource, novel.FieldCover, novel.FieldTagIds, novel.FieldLeadingMan, novel.FieldLeadingLady, novel.FieldRemark, novel.FieldMediaKey:
			values[i] = new(sql.NullString)
		case novel.FieldSignDate, novel.FieldCreatedAt, novel.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Novel", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Novel fields.
func (n *Novel) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case novel.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			n.ID = int64(value.Int64)
		case novel.FieldClassifyId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field classifyId", values[i])
			} else if value.Valid {
				n.ClassifyId = value.Int64
			}
		case novel.FieldClassifyName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field classifyName", values[i])
			} else if value.Valid {
				n.ClassifyName = value.String
			}
		case novel.FieldAuthorId:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field authorId", values[i])
			} else if value.Valid {
				n.AuthorId = value.String
			}
		case novel.FieldTitle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field title", values[i])
			} else if value.Valid {
				n.Title = value.String
			}
		case novel.FieldSummary:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field summary", values[i])
			} else if value.Valid {
				n.Summary = value.String
			}
		case novel.FieldAuthor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field author", values[i])
			} else if value.Valid {
				n.Author = value.String
			}
		case novel.FieldAnchor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field anchor", values[i])
			} else if value.Valid {
				n.Anchor = value.String
			}
		case novel.FieldHits:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field hits", values[i])
			} else if value.Valid {
				n.Hits = value.Int64
			}
		case novel.FieldKeywords:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field keywords", values[i])
			} else if value.Valid {
				n.Keywords = value.String
			}
		case novel.FieldSource:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source", values[i])
			} else if value.Valid {
				n.Source = value.String
			}
		case novel.FieldScore:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field score", values[i])
			} else if value.Valid {
				n.Score = int32(value.Int64)
			}
		case novel.FieldCover:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field cover", values[i])
			} else if value.Valid {
				n.Cover = value.String
			}
		case novel.FieldTagIds:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tagIds", values[i])
			} else if value.Valid {
				n.TagIds = value.String
			}
		case novel.FieldWordNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field wordNum", values[i])
			} else if value.Valid {
				n.WordNum = int32(value.Int64)
			}
		case novel.FieldFreeNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field freeNum", values[i])
			} else if value.Valid {
				n.FreeNum = int32(value.Int64)
			}
		case novel.FieldOnlineState:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field onlineState", values[i])
			} else if value.Valid {
				n.OnlineState = int32(value.Int64)
			}
		case novel.FieldPrice:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field price", values[i])
			} else if value.Valid {
				n.Price = value.Int64
			}
		case novel.FieldPublish:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field publish", values[i])
			} else if value.Valid {
				n.Publish = int32(value.Int64)
			}
		case novel.FieldOriginalPrice:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field originalPrice", values[i])
			} else if value.Valid {
				n.OriginalPrice = value.Int64
			}
		case novel.FieldChapterPrice:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field chapterPrice", values[i])
			} else if value.Valid {
				n.ChapterPrice = int32(value.Int64)
			}
		case novel.FieldChapterCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field chapterCount", values[i])
			} else if value.Valid {
				n.ChapterCount = int32(value.Int64)
			}
		case novel.FieldSignType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field signType", values[i])
			} else if value.Valid {
				n.SignType = int32(value.Int64)
			}
		case novel.FieldSignDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field signDate", values[i])
			} else if value.Valid {
				n.SignDate = value.Time
			}
		case novel.FieldLeadingMan:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field leadingMan", values[i])
			} else if value.Valid {
				n.LeadingMan = value.String
			}
		case novel.FieldLeadingLady:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field leadingLady", values[i])
			} else if value.Valid {
				n.LeadingLady = value.String
			}
		case novel.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				n.Remark = value.String
			}
		case novel.FieldMediaKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mediaKey", values[i])
			} else if value.Valid {
				n.MediaKey = value.String
			}
		case novel.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdAt", values[i])
			} else if value.Valid {
				n.CreatedAt = value.Time
			}
		case novel.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedAt", values[i])
			} else if value.Valid {
				n.UpdatedAt = value.Time
			}
		case novel.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field createBy", values[i])
			} else if value.Valid {
				n.CreateBy = value.Int64
			}
		case novel.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updateBy", values[i])
			} else if value.Valid {
				n.UpdateBy = value.Int64
			}
		case novel.FieldTenantId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tenantId", values[i])
			} else if value.Valid {
				n.TenantId = value.Int64
			}
		}
	}
	return nil
}

// QueryChapters queries the "chapters" edge of the Novel entity.
func (n *Novel) QueryChapters() *NovelChapterQuery {
	return (&NovelClient{config: n.config}).QueryChapters(n)
}

// QueryPkgs queries the "pkgs" edge of the Novel entity.
func (n *Novel) QueryPkgs() *BookPackageQuery {
	return (&NovelClient{config: n.config}).QueryPkgs(n)
}

// QueryClassify queries the "classify" edge of the Novel entity.
func (n *Novel) QueryClassify() *NovelClassifyQuery {
	return (&NovelClient{config: n.config}).QueryClassify(n)
}

// Update returns a builder for updating this Novel.
// Note that you need to call Novel.Unwrap() before calling this method if this Novel
// was returned from a transaction, and the transaction was committed or rolled back.
func (n *Novel) Update() *NovelUpdateOne {
	return (&NovelClient{config: n.config}).UpdateOne(n)
}

// Unwrap unwraps the Novel entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (n *Novel) Unwrap() *Novel {
	tx, ok := n.config.driver.(*txDriver)
	if !ok {
		panic("ent: Novel is not a transactional entity")
	}
	n.config.driver = tx.drv
	return n
}

// String implements the fmt.Stringer.
func (n *Novel) String() string {
	var builder strings.Builder
	builder.WriteString("Novel(")
	builder.WriteString(fmt.Sprintf("id=%v", n.ID))
	builder.WriteString(", classifyId=")
	builder.WriteString(fmt.Sprintf("%v", n.ClassifyId))
	builder.WriteString(", classifyName=")
	builder.WriteString(n.ClassifyName)
	builder.WriteString(", authorId=")
	builder.WriteString(n.AuthorId)
	builder.WriteString(", title=")
	builder.WriteString(n.Title)
	builder.WriteString(", summary=")
	builder.WriteString(n.Summary)
	builder.WriteString(", author=")
	builder.WriteString(n.Author)
	builder.WriteString(", anchor=")
	builder.WriteString(n.Anchor)
	builder.WriteString(", hits=")
	builder.WriteString(fmt.Sprintf("%v", n.Hits))
	builder.WriteString(", keywords=")
	builder.WriteString(n.Keywords)
	builder.WriteString(", source=")
	builder.WriteString(n.Source)
	builder.WriteString(", score=")
	builder.WriteString(fmt.Sprintf("%v", n.Score))
	builder.WriteString(", cover=")
	builder.WriteString(n.Cover)
	builder.WriteString(", tagIds=")
	builder.WriteString(n.TagIds)
	builder.WriteString(", wordNum=")
	builder.WriteString(fmt.Sprintf("%v", n.WordNum))
	builder.WriteString(", freeNum=")
	builder.WriteString(fmt.Sprintf("%v", n.FreeNum))
	builder.WriteString(", onlineState=")
	builder.WriteString(fmt.Sprintf("%v", n.OnlineState))
	builder.WriteString(", price=")
	builder.WriteString(fmt.Sprintf("%v", n.Price))
	builder.WriteString(", publish=")
	builder.WriteString(fmt.Sprintf("%v", n.Publish))
	builder.WriteString(", originalPrice=")
	builder.WriteString(fmt.Sprintf("%v", n.OriginalPrice))
	builder.WriteString(", chapterPrice=")
	builder.WriteString(fmt.Sprintf("%v", n.ChapterPrice))
	builder.WriteString(", chapterCount=")
	builder.WriteString(fmt.Sprintf("%v", n.ChapterCount))
	builder.WriteString(", signType=")
	builder.WriteString(fmt.Sprintf("%v", n.SignType))
	builder.WriteString(", signDate=")
	builder.WriteString(n.SignDate.Format(time.ANSIC))
	builder.WriteString(", leadingMan=")
	builder.WriteString(n.LeadingMan)
	builder.WriteString(", leadingLady=")
	builder.WriteString(n.LeadingLady)
	builder.WriteString(", remark=")
	builder.WriteString(n.Remark)
	builder.WriteString(", mediaKey=")
	builder.WriteString(n.MediaKey)
	builder.WriteString(", createdAt=")
	builder.WriteString(n.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updatedAt=")
	builder.WriteString(n.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", createBy=")
	builder.WriteString(fmt.Sprintf("%v", n.CreateBy))
	builder.WriteString(", updateBy=")
	builder.WriteString(fmt.Sprintf("%v", n.UpdateBy))
	builder.WriteString(", tenantId=")
	builder.WriteString(fmt.Sprintf("%v", n.TenantId))
	builder.WriteByte(')')
	return builder.String()
}

// Novels is a parsable slice of Novel.
type Novels []*Novel

func (n Novels) config(cfg config) {
	for _i := range n {
		n[_i].config = cfg
	}
}
