// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type NovelHTTPServer interface {
	BatchDeleteNovel(context.Context, *NovelBatchDeleteReq) (*NovelDeleteReply, error)
	CreateNovel(context.Context, *NovelCreateReq) (*NovelCreateReply, error)
	DeleteNovel(context.Context, *NovelDeleteReq) (*NovelDeleteReply, error)
	GetNovel(context.Context, *NovelReq) (*NovelReply, error)
	GetNovelPage(context.Context, *NovelPageReq) (*NovelPageReply, error)
	UpdateNovel(context.Context, *NovelUpdateReq) (*NovelUpdateReply, error)
}

func RegisterNovelHTTPServer(s *http.Server, srv NovelHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/novel/page", _Novel_GetNovelPage0_HTTP_Handler(srv))
	r.GET("/v1/novel/{id}", _Novel_GetNovel0_HTTP_Handler(srv))
	r.PUT("/v1/novel/{id}", _Novel_UpdateNovel0_HTTP_Handler(srv))
	r.POST("/v1/novel", _Novel_CreateNovel0_HTTP_Handler(srv))
	r.DELETE("/v1/novel/{id}", _Novel_DeleteNovel0_HTTP_Handler(srv))
	r.DELETE("/v1/novel", _Novel_BatchDeleteNovel0_HTTP_Handler(srv))
}

func _Novel_GetNovelPage0_HTTP_Handler(srv NovelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in NovelPageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/novel.v1.Novel/GetNovelPage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetNovelPage(ctx, req.(*NovelPageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*NovelPageReply)
		return ctx.Result(200, reply)
	}
}

func _Novel_GetNovel0_HTTP_Handler(srv NovelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in NovelReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/novel.v1.Novel/GetNovel")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetNovel(ctx, req.(*NovelReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*NovelReply)
		return ctx.Result(200, reply)
	}
}

func _Novel_UpdateNovel0_HTTP_Handler(srv NovelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in NovelUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/novel.v1.Novel/UpdateNovel")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateNovel(ctx, req.(*NovelUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*NovelUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _Novel_CreateNovel0_HTTP_Handler(srv NovelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in NovelCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/novel.v1.Novel/CreateNovel")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateNovel(ctx, req.(*NovelCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*NovelCreateReply)
		return ctx.Result(200, reply)
	}
}

func _Novel_DeleteNovel0_HTTP_Handler(srv NovelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in NovelDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/novel.v1.Novel/DeleteNovel")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteNovel(ctx, req.(*NovelDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*NovelDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _Novel_BatchDeleteNovel0_HTTP_Handler(srv NovelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in NovelBatchDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/novel.v1.Novel/BatchDeleteNovel")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteNovel(ctx, req.(*NovelBatchDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*NovelDeleteReply)
		return ctx.Result(200, reply)
	}
}

type NovelHTTPClient interface {
	BatchDeleteNovel(ctx context.Context, req *NovelBatchDeleteReq, opts ...http.CallOption) (rsp *NovelDeleteReply, err error)
	CreateNovel(ctx context.Context, req *NovelCreateReq, opts ...http.CallOption) (rsp *NovelCreateReply, err error)
	DeleteNovel(ctx context.Context, req *NovelDeleteReq, opts ...http.CallOption) (rsp *NovelDeleteReply, err error)
	GetNovel(ctx context.Context, req *NovelReq, opts ...http.CallOption) (rsp *NovelReply, err error)
	GetNovelPage(ctx context.Context, req *NovelPageReq, opts ...http.CallOption) (rsp *NovelPageReply, err error)
	UpdateNovel(ctx context.Context, req *NovelUpdateReq, opts ...http.CallOption) (rsp *NovelUpdateReply, err error)
}

type NovelHTTPClientImpl struct {
	cc *http.Client
}

func NewNovelHTTPClient(client *http.Client) NovelHTTPClient {
	return &NovelHTTPClientImpl{client}
}

func (c *NovelHTTPClientImpl) BatchDeleteNovel(ctx context.Context, in *NovelBatchDeleteReq, opts ...http.CallOption) (*NovelDeleteReply, error) {
	var out NovelDeleteReply
	pattern := "/v1/novel"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/novel.v1.Novel/BatchDeleteNovel"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *NovelHTTPClientImpl) CreateNovel(ctx context.Context, in *NovelCreateReq, opts ...http.CallOption) (*NovelCreateReply, error) {
	var out NovelCreateReply
	pattern := "/v1/novel"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/novel.v1.Novel/CreateNovel"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *NovelHTTPClientImpl) DeleteNovel(ctx context.Context, in *NovelDeleteReq, opts ...http.CallOption) (*NovelDeleteReply, error) {
	var out NovelDeleteReply
	pattern := "/v1/novel/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/novel.v1.Novel/DeleteNovel"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *NovelHTTPClientImpl) GetNovel(ctx context.Context, in *NovelReq, opts ...http.CallOption) (*NovelReply, error) {
	var out NovelReply
	pattern := "/v1/novel/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/novel.v1.Novel/GetNovel"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *NovelHTTPClientImpl) GetNovelPage(ctx context.Context, in *NovelPageReq, opts ...http.CallOption) (*NovelPageReply, error) {
	var out NovelPageReply
	pattern := "/v1/novel/page"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/novel.v1.Novel/GetNovelPage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *NovelHTTPClientImpl) UpdateNovel(ctx context.Context, in *NovelUpdateReq, opts ...http.CallOption) (*NovelUpdateReply, error) {
	var out NovelUpdateReply
	pattern := "/v1/novel/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/novel.v1.Novel/UpdateNovel"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
