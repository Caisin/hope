// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.3
// source: api/novel/appversion/v1/app_version.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AppVersionClient is the client API for AppVersion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppVersionClient interface {
	// 分页查询AppVersion
	GetAppVersionPage(ctx context.Context, in *AppVersionPageReq, opts ...grpc.CallOption) (*AppVersionPageReply, error)
	// 获取AppVersion
	GetAppVersion(ctx context.Context, in *AppVersionReq, opts ...grpc.CallOption) (*AppVersionReply, error)
	// 更新AppVersion
	UpdateAppVersion(ctx context.Context, in *AppVersionUpdateReq, opts ...grpc.CallOption) (*AppVersionUpdateReply, error)
	// 创建AppVersion
	CreateAppVersion(ctx context.Context, in *AppVersionCreateReq, opts ...grpc.CallOption) (*AppVersionCreateReply, error)
	// 删除AppVersion
	DeleteAppVersion(ctx context.Context, in *AppVersionDeleteReq, opts ...grpc.CallOption) (*AppVersionDeleteReply, error)
	// 批量删除AppVersion
	BatchDeleteAppVersion(ctx context.Context, in *AppVersionBatchDeleteReq, opts ...grpc.CallOption) (*AppVersionDeleteReply, error)
}

type appVersionClient struct {
	cc grpc.ClientConnInterface
}

func NewAppVersionClient(cc grpc.ClientConnInterface) AppVersionClient {
	return &appVersionClient{cc}
}

func (c *appVersionClient) GetAppVersionPage(ctx context.Context, in *AppVersionPageReq, opts ...grpc.CallOption) (*AppVersionPageReply, error) {
	out := new(AppVersionPageReply)
	err := c.cc.Invoke(ctx, "/appversion.v1.AppVersion/GetAppVersionPage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appVersionClient) GetAppVersion(ctx context.Context, in *AppVersionReq, opts ...grpc.CallOption) (*AppVersionReply, error) {
	out := new(AppVersionReply)
	err := c.cc.Invoke(ctx, "/appversion.v1.AppVersion/GetAppVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appVersionClient) UpdateAppVersion(ctx context.Context, in *AppVersionUpdateReq, opts ...grpc.CallOption) (*AppVersionUpdateReply, error) {
	out := new(AppVersionUpdateReply)
	err := c.cc.Invoke(ctx, "/appversion.v1.AppVersion/UpdateAppVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appVersionClient) CreateAppVersion(ctx context.Context, in *AppVersionCreateReq, opts ...grpc.CallOption) (*AppVersionCreateReply, error) {
	out := new(AppVersionCreateReply)
	err := c.cc.Invoke(ctx, "/appversion.v1.AppVersion/CreateAppVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appVersionClient) DeleteAppVersion(ctx context.Context, in *AppVersionDeleteReq, opts ...grpc.CallOption) (*AppVersionDeleteReply, error) {
	out := new(AppVersionDeleteReply)
	err := c.cc.Invoke(ctx, "/appversion.v1.AppVersion/DeleteAppVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appVersionClient) BatchDeleteAppVersion(ctx context.Context, in *AppVersionBatchDeleteReq, opts ...grpc.CallOption) (*AppVersionDeleteReply, error) {
	out := new(AppVersionDeleteReply)
	err := c.cc.Invoke(ctx, "/appversion.v1.AppVersion/BatchDeleteAppVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppVersionServer is the server API for AppVersion service.
// All implementations must embed UnimplementedAppVersionServer
// for forward compatibility
type AppVersionServer interface {
	// 分页查询AppVersion
	GetAppVersionPage(context.Context, *AppVersionPageReq) (*AppVersionPageReply, error)
	// 获取AppVersion
	GetAppVersion(context.Context, *AppVersionReq) (*AppVersionReply, error)
	// 更新AppVersion
	UpdateAppVersion(context.Context, *AppVersionUpdateReq) (*AppVersionUpdateReply, error)
	// 创建AppVersion
	CreateAppVersion(context.Context, *AppVersionCreateReq) (*AppVersionCreateReply, error)
	// 删除AppVersion
	DeleteAppVersion(context.Context, *AppVersionDeleteReq) (*AppVersionDeleteReply, error)
	// 批量删除AppVersion
	BatchDeleteAppVersion(context.Context, *AppVersionBatchDeleteReq) (*AppVersionDeleteReply, error)
	mustEmbedUnimplementedAppVersionServer()
}

// UnimplementedAppVersionServer must be embedded to have forward compatible implementations.
type UnimplementedAppVersionServer struct {
}

func (UnimplementedAppVersionServer) GetAppVersionPage(context.Context, *AppVersionPageReq) (*AppVersionPageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppVersionPage not implemented")
}
func (UnimplementedAppVersionServer) GetAppVersion(context.Context, *AppVersionReq) (*AppVersionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppVersion not implemented")
}
func (UnimplementedAppVersionServer) UpdateAppVersion(context.Context, *AppVersionUpdateReq) (*AppVersionUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppVersion not implemented")
}
func (UnimplementedAppVersionServer) CreateAppVersion(context.Context, *AppVersionCreateReq) (*AppVersionCreateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAppVersion not implemented")
}
func (UnimplementedAppVersionServer) DeleteAppVersion(context.Context, *AppVersionDeleteReq) (*AppVersionDeleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAppVersion not implemented")
}
func (UnimplementedAppVersionServer) BatchDeleteAppVersion(context.Context, *AppVersionBatchDeleteReq) (*AppVersionDeleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteAppVersion not implemented")
}
func (UnimplementedAppVersionServer) mustEmbedUnimplementedAppVersionServer() {}

// UnsafeAppVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppVersionServer will
// result in compilation errors.
type UnsafeAppVersionServer interface {
	mustEmbedUnimplementedAppVersionServer()
}

func RegisterAppVersionServer(s grpc.ServiceRegistrar, srv AppVersionServer) {
	s.RegisterService(&AppVersion_ServiceDesc, srv)
}

func _AppVersion_GetAppVersionPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppVersionPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppVersionServer).GetAppVersionPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appversion.v1.AppVersion/GetAppVersionPage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppVersionServer).GetAppVersionPage(ctx, req.(*AppVersionPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppVersion_GetAppVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppVersionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppVersionServer).GetAppVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appversion.v1.AppVersion/GetAppVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppVersionServer).GetAppVersion(ctx, req.(*AppVersionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppVersion_UpdateAppVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppVersionUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppVersionServer).UpdateAppVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appversion.v1.AppVersion/UpdateAppVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppVersionServer).UpdateAppVersion(ctx, req.(*AppVersionUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppVersion_CreateAppVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppVersionCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppVersionServer).CreateAppVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appversion.v1.AppVersion/CreateAppVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppVersionServer).CreateAppVersion(ctx, req.(*AppVersionCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppVersion_DeleteAppVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppVersionDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppVersionServer).DeleteAppVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appversion.v1.AppVersion/DeleteAppVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppVersionServer).DeleteAppVersion(ctx, req.(*AppVersionDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppVersion_BatchDeleteAppVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppVersionBatchDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppVersionServer).BatchDeleteAppVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appversion.v1.AppVersion/BatchDeleteAppVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppVersionServer).BatchDeleteAppVersion(ctx, req.(*AppVersionBatchDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AppVersion_ServiceDesc is the grpc.ServiceDesc for AppVersion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppVersion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "appversion.v1.AppVersion",
	HandlerType: (*AppVersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAppVersionPage",
			Handler:    _AppVersion_GetAppVersionPage_Handler,
		},
		{
			MethodName: "GetAppVersion",
			Handler:    _AppVersion_GetAppVersion_Handler,
		},
		{
			MethodName: "UpdateAppVersion",
			Handler:    _AppVersion_UpdateAppVersion_Handler,
		},
		{
			MethodName: "CreateAppVersion",
			Handler:    _AppVersion_CreateAppVersion_Handler,
		},
		{
			MethodName: "DeleteAppVersion",
			Handler:    _AppVersion_DeleteAppVersion_Handler,
		},
		{
			MethodName: "BatchDeleteAppVersion",
			Handler:    _AppVersion_BatchDeleteAppVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/novel/appversion/v1/app_version.proto",
}
