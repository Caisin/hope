package main

import (
	"bytes"
	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"entgo.io/ent/entc/load"
	"entgo.io/ent/schema/field"
	"fmt"
	"hope/pkg/command"
	"hope/pkg/file"
	"hope/pkg/str"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"
)

func main() {
	target := filepath.Join(os.TempDir(), "ent")
	os.MkdirAll(target, os.ModePerm)
	defer os.RemoveAll(target)
	storage, _ := gen.NewStorage("sql")
	projectPath := "D:/work/code/go/hope"
	prods := []string{"admin", "param", "novel"}
	s := fmt.Sprintf("%s/build/template/api.proto.tpl", projectPath)
	readStr, _ := file.ReadStr(s)
	apiTemplate, err := template.New("apiTemplate").Funcs(
		template.FuncMap{
			"genPageFields":   genPageFields,
			"genCreateFields": genCreateFields,
			"genFields":       genFields,
			"add":             add,
			"parseType":       parseType,
		}).Parse(readStr)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	for _, prod := range prods {
		tmpDir := fmt.Sprintf("%s/build/%s/schema", projectPath, prod)
		file.MakeDir(tmpDir)
		sprintf := fmt.Sprintf("%s/apps/%s/internal/data/ent/schema", projectPath, prod)
		err := file.CopyDir(sprintf, tmpDir)
		if err != nil {
			fmt.Errorf("%s", err.Error())
			continue
		}

		graph, err := entc.LoadGraph(tmpDir, &gen.Config{
			Storage: storage,
			IDType:  &field.TypeInfo{Type: field.TypeInt},
			Target:  target,
			Package: "entgo.io/ent/entc/integration/ent",
			/*Templates: []*gen.Template{
				gen.MustParse(gen.NewTemplate("template").
					Funcs(gen.Funcs).
					ParseGlob("../integration/ent/template/*.tmpl")),
			},*/

		})
		if err != nil {
			fmt.Printf("%s", err.Error())
			continue
		}
		for _, sc := range graph.Schemas {
			genConvert(projectPath, prod, sc)
			fields := sc.Fields
			name := sc.Name
			//sc.Name
			log.Printf("%v", fields)
			bf := bytes.Buffer{}
			m := make(map[string]interface{})
			m["model"] = prod
			m["name"] = name
			lower := strings.ToLower(name)
			m["pkg"] = lower
			m["fields"] = fields
			err := apiTemplate.Execute(&bf, m)
			if err != nil {
				fmt.Println(err.Error())
				continue
			}
			fileName := fmt.Sprintf("%s/api/%s/%s/v1/%s.proto", projectPath, prod, lower, str.Camel2Case(name))
			dir := path.Dir(fileName)
			file.MakeDir(dir)
			file.FileCreate(bf, fileName)
		}
		file.RemoveAll(tmpDir)
	}

}

func parseType(t field.Type) string {
	switch t.String() {
	case "int":
		return "int32"
	case "time.Time":
		return "google.protobuf.Timestamp"
	case "time.Duration":
		return "google.protobuf.Duration"
	default:
		return t.String()
	}
}

func genFields(fields []*load.Field, isModify bool) string {
	bf := str.NewBuffer()
	bf.Append("    int64 id = 1;\n")
	tab := "    "
	space := " "
	//len := len(fields)
	for i, f := range fields {
		name := f.Name
		if name == "createdAt" && isModify {
			break
		}
		//备注
		bf.Append(tab).Append("//").Append(f.Comment).Append("\n")
		//字段
		bf.Append(tab).Append(parseType(f.Info.Type)).Append(space).Append(name).
			Append(space).Append("=").Append(space).Append(i + 2).Append(";\n")
	}
	return bf.String()
}

func genPageFields(fields []*load.Field) string {
	bf := str.NewBuffer()
	bf.Append("    int64 page = 1;\n")
	bf.Append("    int64 pageSize = 2;\n")
	bf.Append("    int64 id = 3;\n")
	tab := "    "
	space := " "
	//len := len(fields)
	for i, f := range fields {
		name := f.Name
		//备注
		bf.Append(tab).Append("//").Append(f.Comment).Append("\n")
		//字段
		bf.Append(tab).Append(parseType(f.Info.Type)).Append(space).Append(name).
			Append(space).Append("=").Append(space).Append(i + 4).Append(";\n")
	}
	return bf.String()
}

func genCreateFields(fields []*load.Field) string {
	bf := str.NewBuffer()
	//bf.Append("    int64 id = 1;\n")
	tab := "    "
	space := " "
	//len := len(fields)
	for i, f := range fields {
		name := f.Name
		if name == "createdAt" {
			break
		}
		//备注
		bf.Append(tab).Append("//").Append(f.Comment).Append("\n")
		//字段
		bf.Append(tab).Append(parseType(f.Info.Type)).Append(space).Append(name).
			Append(space).Append("=").Append(space).Append(i + 1).Append(";\n")
	}
	return bf.String()
}

func add(a, b int) int {
	return a + b
}

//生成转化代码
func genConvert(projectPath, model string, sc *load.Schema) bool {
	bf := str.NewBuffer()
	bf.Append(fmt.Sprintf(`// Code generated by Caisin. DO NOT EDIT.
// source: %s

package convert

`, fmt.Sprintf("apps/%s/internal/data/ent/schema/%s.go", model, str.Camel2Case(sc.Name))))
	importTemp := `import (
	"google.golang.org/protobuf/types/known/timestamppb"
	v1 "hope/api/%s/%s/v1"
	"hope/apps/%s/internal/data/ent"
)`
	name := sc.Name
	lower := strings.ToLower(name)
	bf.Append(fmt.Sprintf(importTemp, model, lower, model))
	funTmp := `
func %s(v *%s) *%s {
	return &%s{
%s
	}
}

`
	update2Data := str.NewBuffer()
	data2Update := str.NewBuffer()
	update2Data.Append("\t\tID:       v.Id,\n")
	data2Update.Append("\t\tId:       v.ID,\n")
	create2Data := str.NewBuffer()
	data2Create := str.NewBuffer()
	req2Data := str.NewBuffer()
	data2Req := str.NewBuffer()
	reply2Data := str.NewBuffer()
	data2Reply := str.NewBuffer()
	reply2Data.Append("\t\tID:       v.Id,\n")
	data2Reply.Append("\t\tId:       v.ID,\n")
	fields := sc.Fields
	l := len(fields)
	for i, f := range fields {
		fieldName := f.Name
		//字段
		lu := str.LeftUpper(fieldName)
		if f.Info.Type == field.TypeTime {
			s := fmt.Sprintf("\t\t%s:       v.%s.AsTime(),\n", lu, lu)
			timeNew := fmt.Sprintf("\t\t%s:       timestamppb.New(v.%s),\n", lu, lu)
			reply2Data.Append(s)
			data2Reply.Append(timeNew)
			if l-i > 6 {
				create2Data.Append(s)
				data2Create.Append(timeNew)
				update2Data.Append(s)
				data2Update.Append(timeNew)
				req2Data.Append(s)
				data2Req.Append(timeNew)
			}
		} else {
			s := fmt.Sprintf("\t\t%s:       v.%s,\n", lu, lu)
			reply2Data.Append(s)
			data2Reply.Append(s)
			if l-i > 6 {
				create2Data.Append(s)
				data2Create.Append(s)
				update2Data.Append(s)
				data2Update.Append(s)
				req2Data.Append(s)
				data2Req.Append(s)
			}
		}
	}
	appendFun(bf, update2Data, data2Update, funTmp, name, "Update", "Req")
	appendFun(bf, create2Data, data2Create, funTmp, name, "Create", "Req")
	appendFun(bf, req2Data, data2Req, funTmp, name, "", "Req")
	appendFun(bf, reply2Data, data2Reply, funTmp, name, "", "Reply")
	buffer := bf.Buffer
	fileName := fmt.Sprintf("%s/apps/%s/internal/convert/%s.go", projectPath, model, str.Camel2Case(name))
	dir := path.Dir(fileName)
	file.MakeDir(dir)
	file.FileCreate(*buffer, fileName)
	command.RunCommand(dir, "gofmt", "–w", ".")
	return true
}

func appendFun(bf, toData, toReq *str.Buffer, funTmp, name, mode, typ string) {
	modeName := name + mode
	entName := "ent." + name
	v1Name := "v1." + modeName + typ
	bf.Append(fmt.Sprintf(funTmp, modeName+typ+"2Data", v1Name, entName, entName, toData.String()))
	bf.Append(fmt.Sprintf(funTmp, name+"Data2"+mode+typ, entName, v1Name, v1Name, toReq.String()))
}
