// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type UserEventHTTPServer interface {
	BatchDeleteUserEvent(context.Context, *UserEventBatchDeleteReq) (*UserEventDeleteReply, error)
	CreateUserEvent(context.Context, *UserEventCreateReq) (*UserEventCreateReply, error)
	DeleteUserEvent(context.Context, *UserEventDeleteReq) (*UserEventDeleteReply, error)
	GetUserEvent(context.Context, *UserEventReq) (*UserEventReply, error)
	GetUserEventPage(context.Context, *UserEventPageReq) (*UserEventPageReply, error)
	UpdateUserEvent(context.Context, *UserEventUpdateReq) (*UserEventUpdateReply, error)
}

func RegisterUserEventHTTPServer(s *http.Server, srv UserEventHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/user/event/page", _UserEvent_GetUserEventPage0_HTTP_Handler(srv))
	r.GET("/v1/user/event/{id}", _UserEvent_GetUserEvent0_HTTP_Handler(srv))
	r.PUT("/v1/user/event/{id}", _UserEvent_UpdateUserEvent0_HTTP_Handler(srv))
	r.POST("/v1/user/event", _UserEvent_CreateUserEvent0_HTTP_Handler(srv))
	r.DELETE("/v1/user/event/{id}", _UserEvent_DeleteUserEvent0_HTTP_Handler(srv))
	r.DELETE("/v1/user/event", _UserEvent_BatchDeleteUserEvent0_HTTP_Handler(srv))
}

func _UserEvent_GetUserEventPage0_HTTP_Handler(srv UserEventHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserEventPageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/userevent.v1.UserEvent/GetUserEventPage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUserEventPage(ctx, req.(*UserEventPageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserEventPageReply)
		return ctx.Result(200, reply)
	}
}

func _UserEvent_GetUserEvent0_HTTP_Handler(srv UserEventHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserEventReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/userevent.v1.UserEvent/GetUserEvent")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUserEvent(ctx, req.(*UserEventReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserEventReply)
		return ctx.Result(200, reply)
	}
}

func _UserEvent_UpdateUserEvent0_HTTP_Handler(srv UserEventHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserEventUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/userevent.v1.UserEvent/UpdateUserEvent")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateUserEvent(ctx, req.(*UserEventUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserEventUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _UserEvent_CreateUserEvent0_HTTP_Handler(srv UserEventHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserEventCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/userevent.v1.UserEvent/CreateUserEvent")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateUserEvent(ctx, req.(*UserEventCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserEventCreateReply)
		return ctx.Result(200, reply)
	}
}

func _UserEvent_DeleteUserEvent0_HTTP_Handler(srv UserEventHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserEventDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/userevent.v1.UserEvent/DeleteUserEvent")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteUserEvent(ctx, req.(*UserEventDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserEventDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _UserEvent_BatchDeleteUserEvent0_HTTP_Handler(srv UserEventHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserEventBatchDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/userevent.v1.UserEvent/BatchDeleteUserEvent")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteUserEvent(ctx, req.(*UserEventBatchDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserEventDeleteReply)
		return ctx.Result(200, reply)
	}
}

type UserEventHTTPClient interface {
	BatchDeleteUserEvent(ctx context.Context, req *UserEventBatchDeleteReq, opts ...http.CallOption) (rsp *UserEventDeleteReply, err error)
	CreateUserEvent(ctx context.Context, req *UserEventCreateReq, opts ...http.CallOption) (rsp *UserEventCreateReply, err error)
	DeleteUserEvent(ctx context.Context, req *UserEventDeleteReq, opts ...http.CallOption) (rsp *UserEventDeleteReply, err error)
	GetUserEvent(ctx context.Context, req *UserEventReq, opts ...http.CallOption) (rsp *UserEventReply, err error)
	GetUserEventPage(ctx context.Context, req *UserEventPageReq, opts ...http.CallOption) (rsp *UserEventPageReply, err error)
	UpdateUserEvent(ctx context.Context, req *UserEventUpdateReq, opts ...http.CallOption) (rsp *UserEventUpdateReply, err error)
}

type UserEventHTTPClientImpl struct {
	cc *http.Client
}

func NewUserEventHTTPClient(client *http.Client) UserEventHTTPClient {
	return &UserEventHTTPClientImpl{client}
}

func (c *UserEventHTTPClientImpl) BatchDeleteUserEvent(ctx context.Context, in *UserEventBatchDeleteReq, opts ...http.CallOption) (*UserEventDeleteReply, error) {
	var out UserEventDeleteReply
	pattern := "/v1/user/event"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/userevent.v1.UserEvent/BatchDeleteUserEvent"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *UserEventHTTPClientImpl) CreateUserEvent(ctx context.Context, in *UserEventCreateReq, opts ...http.CallOption) (*UserEventCreateReply, error) {
	var out UserEventCreateReply
	pattern := "/v1/user/event"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/userevent.v1.UserEvent/CreateUserEvent"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *UserEventHTTPClientImpl) DeleteUserEvent(ctx context.Context, in *UserEventDeleteReq, opts ...http.CallOption) (*UserEventDeleteReply, error) {
	var out UserEventDeleteReply
	pattern := "/v1/user/event/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/userevent.v1.UserEvent/DeleteUserEvent"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *UserEventHTTPClientImpl) GetUserEvent(ctx context.Context, in *UserEventReq, opts ...http.CallOption) (*UserEventReply, error) {
	var out UserEventReply
	pattern := "/v1/user/event/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/userevent.v1.UserEvent/GetUserEvent"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *UserEventHTTPClientImpl) GetUserEventPage(ctx context.Context, in *UserEventPageReq, opts ...http.CallOption) (*UserEventPageReply, error) {
	var out UserEventPageReply
	pattern := "/v1/user/event/page"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/userevent.v1.UserEvent/GetUserEventPage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *UserEventHTTPClientImpl) UpdateUserEvent(ctx context.Context, in *UserEventUpdateReq, opts ...http.CallOption) (*UserEventUpdateReply, error) {
	var out UserEventUpdateReply
	pattern := "/v1/user/event/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/userevent.v1.UserEvent/UpdateUserEvent"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
