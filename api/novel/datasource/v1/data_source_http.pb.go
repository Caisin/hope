// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type DataSourceHTTPServer interface {
	BatchDeleteDataSource(context.Context, *DataSourceBatchDeleteReq) (*DataSourceDeleteReply, error)
	CreateDataSource(context.Context, *DataSourceCreateReq) (*DataSourceCreateReply, error)
	DeleteDataSource(context.Context, *DataSourceDeleteReq) (*DataSourceDeleteReply, error)
	GetDataSource(context.Context, *DataSourceReq) (*DataSourceReply, error)
	GetDataSourcePage(context.Context, *DataSourcePageReq) (*DataSourcePageReply, error)
	UpdateDataSource(context.Context, *DataSourceUpdateReq) (*DataSourceUpdateReply, error)
}

func RegisterDataSourceHTTPServer(s *http.Server, srv DataSourceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/data/source/page", _DataSource_GetDataSourcePage0_HTTP_Handler(srv))
	r.GET("/v1/data/source/{id}", _DataSource_GetDataSource0_HTTP_Handler(srv))
	r.PUT("/v1/data/source/{id}", _DataSource_UpdateDataSource0_HTTP_Handler(srv))
	r.POST("/v1/data/source", _DataSource_CreateDataSource0_HTTP_Handler(srv))
	r.DELETE("/v1/data/source/{id}", _DataSource_DeleteDataSource0_HTTP_Handler(srv))
	r.DELETE("/v1/data/source", _DataSource_BatchDeleteDataSource0_HTTP_Handler(srv))
}

func _DataSource_GetDataSourcePage0_HTTP_Handler(srv DataSourceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DataSourcePageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/datasource.v1.DataSource/GetDataSourcePage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDataSourcePage(ctx, req.(*DataSourcePageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DataSourcePageReply)
		return ctx.Result(200, reply)
	}
}

func _DataSource_GetDataSource0_HTTP_Handler(srv DataSourceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DataSourceReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/datasource.v1.DataSource/GetDataSource")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDataSource(ctx, req.(*DataSourceReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DataSourceReply)
		return ctx.Result(200, reply)
	}
}

func _DataSource_UpdateDataSource0_HTTP_Handler(srv DataSourceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DataSourceUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/datasource.v1.DataSource/UpdateDataSource")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateDataSource(ctx, req.(*DataSourceUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DataSourceUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _DataSource_CreateDataSource0_HTTP_Handler(srv DataSourceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DataSourceCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/datasource.v1.DataSource/CreateDataSource")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateDataSource(ctx, req.(*DataSourceCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DataSourceCreateReply)
		return ctx.Result(200, reply)
	}
}

func _DataSource_DeleteDataSource0_HTTP_Handler(srv DataSourceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DataSourceDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/datasource.v1.DataSource/DeleteDataSource")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteDataSource(ctx, req.(*DataSourceDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DataSourceDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _DataSource_BatchDeleteDataSource0_HTTP_Handler(srv DataSourceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DataSourceBatchDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/datasource.v1.DataSource/BatchDeleteDataSource")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteDataSource(ctx, req.(*DataSourceBatchDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DataSourceDeleteReply)
		return ctx.Result(200, reply)
	}
}

type DataSourceHTTPClient interface {
	BatchDeleteDataSource(ctx context.Context, req *DataSourceBatchDeleteReq, opts ...http.CallOption) (rsp *DataSourceDeleteReply, err error)
	CreateDataSource(ctx context.Context, req *DataSourceCreateReq, opts ...http.CallOption) (rsp *DataSourceCreateReply, err error)
	DeleteDataSource(ctx context.Context, req *DataSourceDeleteReq, opts ...http.CallOption) (rsp *DataSourceDeleteReply, err error)
	GetDataSource(ctx context.Context, req *DataSourceReq, opts ...http.CallOption) (rsp *DataSourceReply, err error)
	GetDataSourcePage(ctx context.Context, req *DataSourcePageReq, opts ...http.CallOption) (rsp *DataSourcePageReply, err error)
	UpdateDataSource(ctx context.Context, req *DataSourceUpdateReq, opts ...http.CallOption) (rsp *DataSourceUpdateReply, err error)
}

type DataSourceHTTPClientImpl struct {
	cc *http.Client
}

func NewDataSourceHTTPClient(client *http.Client) DataSourceHTTPClient {
	return &DataSourceHTTPClientImpl{client}
}

func (c *DataSourceHTTPClientImpl) BatchDeleteDataSource(ctx context.Context, in *DataSourceBatchDeleteReq, opts ...http.CallOption) (*DataSourceDeleteReply, error) {
	var out DataSourceDeleteReply
	pattern := "/v1/data/source"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/datasource.v1.DataSource/BatchDeleteDataSource"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DataSourceHTTPClientImpl) CreateDataSource(ctx context.Context, in *DataSourceCreateReq, opts ...http.CallOption) (*DataSourceCreateReply, error) {
	var out DataSourceCreateReply
	pattern := "/v1/data/source"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/datasource.v1.DataSource/CreateDataSource"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DataSourceHTTPClientImpl) DeleteDataSource(ctx context.Context, in *DataSourceDeleteReq, opts ...http.CallOption) (*DataSourceDeleteReply, error) {
	var out DataSourceDeleteReply
	pattern := "/v1/data/source/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/datasource.v1.DataSource/DeleteDataSource"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DataSourceHTTPClientImpl) GetDataSource(ctx context.Context, in *DataSourceReq, opts ...http.CallOption) (*DataSourceReply, error) {
	var out DataSourceReply
	pattern := "/v1/data/source/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/datasource.v1.DataSource/GetDataSource"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DataSourceHTTPClientImpl) GetDataSourcePage(ctx context.Context, in *DataSourcePageReq, opts ...http.CallOption) (*DataSourcePageReply, error) {
	var out DataSourcePageReply
	pattern := "/v1/data/source/page"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/datasource.v1.DataSource/GetDataSourcePage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DataSourceHTTPClientImpl) UpdateDataSource(ctx context.Context, in *DataSourceUpdateReq, opts ...http.CallOption) (*DataSourceUpdateReply, error) {
	var out DataSourceUpdateReply
	pattern := "/v1/data/source/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/datasource.v1.DataSource/UpdateDataSource"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
