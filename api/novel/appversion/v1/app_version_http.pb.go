// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type AppVersionHTTPServer interface {
	BatchDeleteAppVersion(context.Context, *AppVersionBatchDeleteReq) (*AppVersionDeleteReply, error)
	CreateAppVersion(context.Context, *AppVersionCreateReq) (*AppVersionCreateReply, error)
	DeleteAppVersion(context.Context, *AppVersionDeleteReq) (*AppVersionDeleteReply, error)
	GetAppVersion(context.Context, *AppVersionReq) (*AppVersionReply, error)
	GetPageAppVersion(context.Context, *AppVersionPageReq) (*AppVersionPageReply, error)
	UpdateAppVersion(context.Context, *AppVersionUpdateReq) (*AppVersionUpdateReply, error)
}

func RegisterAppVersionHTTPServer(s *http.Server, srv AppVersionHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/appversion/page", _AppVersion_GetPageAppVersion0_HTTP_Handler(srv))
	r.GET("/v1/appversion/{id}", _AppVersion_GetAppVersion0_HTTP_Handler(srv))
	r.PUT("/v1/appversion/{id}", _AppVersion_UpdateAppVersion0_HTTP_Handler(srv))
	r.POST("/v1/appversion", _AppVersion_CreateAppVersion0_HTTP_Handler(srv))
	r.DELETE("/v1/appversion/{id}", _AppVersion_DeleteAppVersion0_HTTP_Handler(srv))
	r.DELETE("/v1/appversion", _AppVersion_BatchDeleteAppVersion0_HTTP_Handler(srv))
}

func _AppVersion_GetPageAppVersion0_HTTP_Handler(srv AppVersionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AppVersionPageReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/appversion.v1.AppVersion/GetPageAppVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetPageAppVersion(ctx, req.(*AppVersionPageReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AppVersionPageReply)
		return ctx.Result(200, reply)
	}
}

func _AppVersion_GetAppVersion0_HTTP_Handler(srv AppVersionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AppVersionReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/appversion.v1.AppVersion/GetAppVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetAppVersion(ctx, req.(*AppVersionReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AppVersionReply)
		return ctx.Result(200, reply)
	}
}

func _AppVersion_UpdateAppVersion0_HTTP_Handler(srv AppVersionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AppVersionUpdateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/appversion.v1.AppVersion/UpdateAppVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateAppVersion(ctx, req.(*AppVersionUpdateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AppVersionUpdateReply)
		return ctx.Result(200, reply)
	}
}

func _AppVersion_CreateAppVersion0_HTTP_Handler(srv AppVersionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AppVersionCreateReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/appversion.v1.AppVersion/CreateAppVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateAppVersion(ctx, req.(*AppVersionCreateReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AppVersionCreateReply)
		return ctx.Result(200, reply)
	}
}

func _AppVersion_DeleteAppVersion0_HTTP_Handler(srv AppVersionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AppVersionDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/appversion.v1.AppVersion/DeleteAppVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteAppVersion(ctx, req.(*AppVersionDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AppVersionDeleteReply)
		return ctx.Result(200, reply)
	}
}

func _AppVersion_BatchDeleteAppVersion0_HTTP_Handler(srv AppVersionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AppVersionBatchDeleteReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/appversion.v1.AppVersion/BatchDeleteAppVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteAppVersion(ctx, req.(*AppVersionBatchDeleteReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AppVersionDeleteReply)
		return ctx.Result(200, reply)
	}
}

type AppVersionHTTPClient interface {
	BatchDeleteAppVersion(ctx context.Context, req *AppVersionBatchDeleteReq, opts ...http.CallOption) (rsp *AppVersionDeleteReply, err error)
	CreateAppVersion(ctx context.Context, req *AppVersionCreateReq, opts ...http.CallOption) (rsp *AppVersionCreateReply, err error)
	DeleteAppVersion(ctx context.Context, req *AppVersionDeleteReq, opts ...http.CallOption) (rsp *AppVersionDeleteReply, err error)
	GetAppVersion(ctx context.Context, req *AppVersionReq, opts ...http.CallOption) (rsp *AppVersionReply, err error)
	GetPageAppVersion(ctx context.Context, req *AppVersionPageReq, opts ...http.CallOption) (rsp *AppVersionPageReply, err error)
	UpdateAppVersion(ctx context.Context, req *AppVersionUpdateReq, opts ...http.CallOption) (rsp *AppVersionUpdateReply, err error)
}

type AppVersionHTTPClientImpl struct {
	cc *http.Client
}

func NewAppVersionHTTPClient(client *http.Client) AppVersionHTTPClient {
	return &AppVersionHTTPClientImpl{client}
}

func (c *AppVersionHTTPClientImpl) BatchDeleteAppVersion(ctx context.Context, in *AppVersionBatchDeleteReq, opts ...http.CallOption) (*AppVersionDeleteReply, error) {
	var out AppVersionDeleteReply
	pattern := "/v1/appversion"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/appversion.v1.AppVersion/BatchDeleteAppVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AppVersionHTTPClientImpl) CreateAppVersion(ctx context.Context, in *AppVersionCreateReq, opts ...http.CallOption) (*AppVersionCreateReply, error) {
	var out AppVersionCreateReply
	pattern := "/v1/appversion"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/appversion.v1.AppVersion/CreateAppVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AppVersionHTTPClientImpl) DeleteAppVersion(ctx context.Context, in *AppVersionDeleteReq, opts ...http.CallOption) (*AppVersionDeleteReply, error) {
	var out AppVersionDeleteReply
	pattern := "/v1/appversion/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/appversion.v1.AppVersion/DeleteAppVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AppVersionHTTPClientImpl) GetAppVersion(ctx context.Context, in *AppVersionReq, opts ...http.CallOption) (*AppVersionReply, error) {
	var out AppVersionReply
	pattern := "/v1/appversion/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/appversion.v1.AppVersion/GetAppVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AppVersionHTTPClientImpl) GetPageAppVersion(ctx context.Context, in *AppVersionPageReq, opts ...http.CallOption) (*AppVersionPageReply, error) {
	var out AppVersionPageReply
	pattern := "/v1/appversion/page"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/appversion.v1.AppVersion/GetPageAppVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AppVersionHTTPClientImpl) UpdateAppVersion(ctx context.Context, in *AppVersionUpdateReq, opts ...http.CallOption) (*AppVersionUpdateReply, error) {
	var out AppVersionUpdateReply
	pattern := "/v1/appversion/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/appversion.v1.AppVersion/UpdateAppVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
